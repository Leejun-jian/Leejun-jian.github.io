<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-重载函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.442Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>除非 为了实现虚函数和虚继承引入的隐藏成员变量外，C++类实例的大小完全取决于一个类及其基类的成员变量！成员函数基本上不影响类实例的大小。</p>
<p>只有成员变量才占用类实例的空间</p>
<p>C++提供继承的目的是在不同的类型之间提取共性。</p>
<p>既然派生类要保留基类的所有属性和行为，自然地，每个派生类的实例都包含了一份完整的基类实例数据。在D中，并不是说基类C的数据一定要放在D的数据之前，只不过这样放的话，能够保证D中的C对象地址，恰好是D对象地址的第一个字节。这种安排之下，<strong>有了派生类D的指针，要获得基类C的指针，就不必要计算偏移量 了。几乎所有知名的C++厂商都采用这种内存安排（基类成员在前）。</strong> <strong>在单继承类层次下，每一个新的派生类都简单地把自己的成员变量添加到基类的成员变量之后 。</strong> 看看上图，C对象指针和D对象指针指向同一地址。</p>
<p>与<strong>单继承相同的是，F实例拷贝了每个基类的所有数据。</strong> <strong>与单继承不同的是，在多重继承下，内嵌的两个基类的对象指针不可能全都与派生类对象指针相同：</strong> </p>
<p>不许return 一个临时对象，临时对象在函数生命周期结束时就会被析构；return的对象的生命周期要不受函数影响，才能被return返回。</p>
<p>引用返回时，将会在函数中构造一个一个将亡值；当以对象的方式返回时，会在主函数中构造一个将亡值。<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220111213711093.png" alt="image-20220111213711093"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Complex operator(const Complex* const this,const Complex &amp;c)</span><br><span class="line">Complex operator+(const Complex &amp;C)const</span><br><span class="line">&#123;</span><br><span class="line">    double r=this-&gt;Real+c.Real;</span><br><span class="line">    double i=this-&gt;Image+c.Image;</span><br><span class="line"></span><br><span class="line">    return Compkex(r,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自己设计的任何一个类型都会有如下函数</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220111214413863.png" alt="image-20220111214413863"></p>
<p>以上六个函数如果自己不写，编译器就会自动添加的缺省函数。</p>
<p>赋值符号的重载：</p>
<p>不能使用const修饰</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220111215525711.png" alt="image-20220111215525711"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220111215030628.png" alt="image-20220111215030628"></p>
<p>不能进行连续赋值，因为返回值是无类型</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220111215221449.png" alt="image-20220111215221449"></p>
<p>防止自赋值，只需要添加一个判断，判断参数对象是否等于this。</p>
<p><strong>因为vs2019在每次运行的时候，会有地址随机算法让对象每次申请内存的时候地址不同，所以当对象被析构之后，通过打印函数还可打印出被析构的对象的值，因为此时对象值的空间可能没受到影响。所以临时对象的值还可以被打印出来。所以说尽量不要用引用返回函数的值，因为我们不能保证每次被析构的对象其空间都不收到其他函数的干扰。</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220113191613268.png" alt="image-20220113191613268"></p>
<h4 id="左值，将亡值，右值，纯右值"><a href="#左值，将亡值，右值，纯右值" class="headerlink" title="左值，将亡值，右值，纯右值"></a>左值，将亡值，右值，纯右值</h4><h5 id="左值：凡是可以寻址的值"><a href="#左值：凡是可以寻址的值" class="headerlink" title="左值：凡是可以寻址的值"></a>左值：凡是可以寻址的值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; a=<span class="number">10</span>;<span class="comment">//常引用是万能引用</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	const int&amp;a =10;可以扩展为</span></span><br><span class="line"><span class="comment">    	int tmp=10;</span></span><br><span class="line"><span class="comment">    	const int* const a=&amp;tmp;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> &amp;&amp; b=<span class="number">10</span>;<span class="comment">//&amp;&amp; 是右值应用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将亡值：函数返回时产生的值"><a href="#将亡值：函数返回时产生的值" class="headerlink" title="将亡值：函数返回时产生的值"></a>将亡值：函数返回时产生的值</h5><p>右值引用会加长将亡值的生存期。</p>
<h5 id="右值：常量或者函数返回时产生的将亡值。"><a href="#右值：常量或者函数返回时产生的将亡值。" class="headerlink" title="右值：常量或者函数返回时产生的将亡值。"></a>右值：常量或者函数返回时产生的将亡值。</h5><h4 id="不允许在构造对象的函数中使用memset-函数"><a href="#不允许在构造对象的函数中使用memset-函数" class="headerlink" title="不允许在构造对象的函数中使用memset()函数"></a>不允许在构造对象的函数中使用memset()函数</h4><p>有的对象中含有虚函数，在构造对象之前会先产生虚表，如果使用memset会将虚表又重新置为零，导致程序出现很难查询的错误。</p>
<h4 id="不能够重载的运算符"><a href="#不能够重载的运算符" class="headerlink" title="不能够重载的运算符"></a>不能够重载的运算符</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220120121514393.png" alt="image-20220120121514393"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220120122237965.png" alt="image-20220120122237965"></p>
<p>以上操作静态对象初始化只执行一次，所以多次操作时无法更新旧的值。  </p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220120143403202.png" alt="image-20220120143403202"></p>
<p>后置加加之所以要加一个int的参数是为了区别于前置加加，参数为占位参数，没有实际的意义。在调用的时候也要加上一个占位的参数。</p>
<h4 id="运算符运算的结果是返回自身时可以以引用返回，当以将亡值值返回时不可以用将亡值返回。"><a href="#运算符运算的结果是返回自身时可以以引用返回，当以将亡值值返回时不可以用将亡值返回。" class="headerlink" title="运算符运算的结果是返回自身时可以以引用返回，当以将亡值值返回时不可以用将亡值返回。"></a>运算符运算的结果是返回自身时可以以引用返回，当以将亡值值返回时不可以用将亡值返回。</h4><p>构造函数的作用：构造对象；赋值对象；类型转换（必须是单参数的）。</p>
<p>如果不允许我们的构造函数进行隐式转换，需要加上关键字explicit;</p>
<p>强转运算符的重载不需要返回值类型。</p>
<p>mutable 异变关键字：</p>
<p>重载了（）运算符的成员函数实现后被称为仿函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=Add()(a,b);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220120153252984.png" alt="image-20220120153252984"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220120153648565.png" alt="image-20220120153648565"></p>
<p>创建对象的顺序：先构建外部对象，在构建内部对象；先析构外部对象，在析构外部对象。（<strong>先构造的后析构，后构造的先析构</strong>）</p>
<p>内部类型 的构造和参数的声明顺序有关，与参数列表的顺序无关。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/" data-id="cllwc4xjz001tjsmof402e1lk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-正则表达式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.434Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p>
<p>正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感</p>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等</p>
<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括<strong>没有显式指定为元字符的所有可打印和不可打印字符</strong>。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h4 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h4><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如，<code> \cM</code> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code>。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 <code>\x0a </code>和<code> \cJ</code>。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code>。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于<code> [^ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于<code> \x09</code> 和 <code>\cI</code>。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code>。</td>
</tr>
</tbody></table>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的”<em>.txt”中的</em>，简单的说就是表示任何字符串的意思。如果要查找文件名中有 * 的文件，则需要对 * 进行转义，即在其前加一个\。ls *.txt。</p>
<p><strong>许多元字符要求在试图匹配它们时特别对待</strong>。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符 () 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<table>
<thead>
<tr>
<th>特别字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td><strong>匹配输入字符串的结尾位置</strong>。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用<code> \$</code>。</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 <code>\*</code>。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\+</code>。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n之外的任何单字符。要匹配 .，请使用<code> \.</code>。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code>。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用<code> \?</code>。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code>。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。要匹配 {，请使用<code> \&#123;</code>。</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择。要匹配 |，请使用 <code>|</code>。</td>
</tr>
</tbody></table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。</p>
<p>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。<strong>请注意在逗号和两个数之间不能有空格</strong>。</td>
</tr>
</tbody></table>
<p>*<strong>、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</strong></p>
<p>通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p>
<p>定位符用来描述字符串或单词的边界，<strong>^和$分别指字符串的开始与结束</strong>，<code>\b</code><strong>描述单词的前或后边界</strong>，<code>\B</code><strong>表示非单词边界。</strong></p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m})  后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串  “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|)  来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’  更简略的表达式。</td>
</tr>
<tr>
<td>(?&#x3D;pattern)</td>
<td>正向预查，在任何匹配 pattern  的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows  (?&#x3D;95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1”  中的  “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows  (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000”  中的  “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m  的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
</tr>
<tr>
<td>\nml</td>
<td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
</tr>
</tbody></table>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?&#x3D;), []</td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*, +, ?, {n}, {n,}, {n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^, $, \任何元字符、任何字符</td>
<td>定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td>|</td>
<td>替换，”或”操作  字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td>
</tr>
</tbody></table>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><h4 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h4><ul>
<li>一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^once</span><br></pre></td></tr></table></figure>

<p>这个模式包含一个特殊的字符 <code>^</code>，表示该模式只匹配那些以 <code>once</code>开头的字符串。例如该模式与字符串 “once upon a time” 匹配，与 “There once was a man from NewYork” 不匹配。</p>
<ul>
<li>正如如 <code>^</code> 符号表示开头一样，<code>$</code> 符号用来匹配那些以给定模式结尾的字符串。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket$ </span><br></pre></td></tr></table></figure>

<p>这个模式与 “Who kept all of this cash in a bucket” 匹配，与 “buckets” 不匹配。</p>
<ul>
<li>字符 <code>^</code> 和 <code>$</code> 同时使用时，表示精确匹配（字符串与模式一样）。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^bucket$</span><br></pre></td></tr></table></figure>

<p>只匹配字符串 “bucket”。</p>
<ul>
<li>如果一个模式不包括 <code>^</code> 和 <code>$</code>，那么它与任何包含该模式的字符串匹配。例如模式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">once</span><br></pre></td></tr></table></figure>

<p>与字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">There once was a man from NewYork</span><br><span class="line">Who kept all of his cash in a bucket.</span><br></pre></td></tr></table></figure>

<p>是匹配的。</p>
<p>在该模式中的字母 (<code>o-n-c-e</code>) 是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。</p>
<p>所有的转义序列都用反斜杠 <code>\</code> 打头。制表符的转义序列是 <code>\t</code>。</p>
<ul>
<li>所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\t</span><br></pre></td></tr></table></figure>

<p>类似的，用 <code>\n</code> 表示”新行”，<code>\r</code> 表示回车。</p>
<p>其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用 <code>\\</code> 表示，句号 <code>.</code> 用 <code>\.</code> 表示，以此类推。</p>
<h4 id="字符族"><a href="#字符族" class="headerlink" title="字符族"></a>字符族</h4><p><strong>在 INTERNET 的程序中，正则表达式通常用来验证用户的输入</strong>。</p>
<ul>
<li>当用户提交一个 FORM 以后，要判断输入的电话号码、地址、EMAIL 地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。</li>
</ul>
<p>所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。</p>
<ul>
<li>要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure>

<ul>
<li>这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a-z] // 匹配所有的小写字母 </span><br><span class="line">[A-Z] // 匹配所有的大写字母 </span><br><span class="line">[a-zA-Z] // 匹配所有的字母 </span><br><span class="line">[0-9] // 匹配所有的数字 </span><br><span class="line">[0-9\.\-] // 匹配所有的数字，句号和减号 </span><br><span class="line">[ \f\r\t\n] // 匹配所有的白字符</span><br></pre></td></tr></table></figure>

<p>同样的，这些也只表示一个字符，这是一个非常重要的。</p>
<ul>
<li>如果要匹配一个由一个小写字母和一位数字组成的字符串，比如 “z2”、”t6” 或 “g7”，但不是 “ab2”、”r2d3” 或 “b52” 的话，用这个模式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-z][0-9]$</span><br></pre></td></tr></table></figure>

<p>尽管<code>[a-z]</code>代表 26 个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。</p>
<p>前面曾经提到<code>^</code>表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 <code>^</code> 时，它表示”非”或”排除”的意思，常常用来剔除某个字符。还用前面的例子，</p>
<ul>
<li>我们要求第一个字符不能是数字：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[^0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>这个模式与 “&amp;5”、”g7”及”-2” 是匹配的，但与 “12”、”66” 是不匹配的。</p>
<ul>
<li>下面是几个排除特定字符的例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[^a-z] //除了小写字母以外的所有字符 </span><br><span class="line">[^\\\/\^] //除了(\)(/)(^)之外的所有字符 </span><br><span class="line">[^\&quot;\&#x27;] //除了双引号(&quot;)和单引号(&#x27;)之外的所有字符</span><br></pre></td></tr></table></figure>

<p>特殊字符 <code>.</code>(点，句号)在正则表达式中用来<strong>表示除了”新行”之外的所有字符</strong>。所以模式 <code>^.5$</code> 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。</p>
<ul>
<li>模式 . 可以匹配任何字符串，换行符（<code>\n</code>、<code>\r</code>）除外。</li>
</ul>
<p>PHP的正则表达式有一些内置的通用字符簇，列表如下：</p>
<table>
<thead>
<tr>
<th>字符族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[[:alpha:]]</td>
<td>任何字母</td>
</tr>
<tr>
<td>[[:digit:]]</td>
<td>任何数字</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>任何字母和数字</td>
</tr>
<tr>
<td>[[:space:]]</td>
<td>任何空白字符</td>
</tr>
<tr>
<td>[[:upper:]]</td>
<td>任何大写字母</td>
</tr>
<tr>
<td>[[:lower:]]</td>
<td>任何小写字母</td>
</tr>
<tr>
<td>[[:punct:]]</td>
<td>任何标点符号</td>
</tr>
<tr>
<td>[[:xdigit:]]</td>
<td>任何16进制的数字，相当于[0-9a-fA-F]</td>
</tr>
</tbody></table>
<h4 id="确定重复出现"><a href="#确定重复出现" class="headerlink" title="确定重复出现"></a>确定重复出现</h4><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号(<code>&#123;&#125;</code>)用来确定前面的内容的重复出现的次数。</p>
<table>
<thead>
<tr>
<th>字符族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^[a-zA-Z_]$</td>
<td>所有的字母和下划线</td>
</tr>
<tr>
<td>^[[:alpha:]]{3}$</td>
<td>所有的3个字母的单词</td>
</tr>
<tr>
<td>^a$</td>
<td>字母a</td>
</tr>
<tr>
<td>^a{4}$</td>
<td>aaaa</td>
</tr>
<tr>
<td>^a{2,4}$</td>
<td>aa,aaa或aaaa</td>
</tr>
<tr>
<td>^a{1,3}$</td>
<td>a,aa或aaa</td>
</tr>
<tr>
<td>^a{2,}$</td>
<td>包含多于两个a的字符串</td>
</tr>
<tr>
<td>^a{2,}</td>
<td>如：aardvark和aaab，但apple不行</td>
</tr>
<tr>
<td>a{2,}</td>
<td>如：baad和aaa，但Nantucket不行</td>
</tr>
<tr>
<td>\t{2}</td>
<td>两个制表符</td>
</tr>
<tr>
<td>.{2}</td>
<td>所有的两个字符</td>
</tr>
</tbody></table>
<p>这些例子描述了花括号的三种不同的用法：</p>
<ul>
<li><p>一个数字 <code>&#123;x&#125;</code> 的意思是前面的字符或字符簇只出现<code>x</code>次 ；</p>
</li>
<li><p>一个数字加逗号 <code>&#123;x,&#125;</code> 的意思是前面的内容出现<code>x</code>或更多的次数 ；</p>
</li>
<li><p>两个数字用逗号分隔的数字 <code>&#123;x,y&#125;</code> 表示 前面的内容至少出现<code>x</code>次，但不超过<code>y</code>次。</p>
<p>我们可以把模式扩展到更多的单词或数字：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_]&#123;1,&#125;$      // 所有包含一个以上的字母、数字或下划线的字符串 </span><br><span class="line">^[1-9][0-9]&#123;0,&#125;$        // 所有的正整数 </span><br><span class="line">^\-&#123;0,1&#125;[0-9]&#123;1,&#125;$      // 所有的整数 </span><br><span class="line">^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数</span><br></pre></td></tr></table></figure>

<p>最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 (<code>[-]?</code>) 开头 (<code>^</code>)、跟着<code>1</code>个或更多的数字(<code>[0-9]+</code>)、和一个小数点(<code>\.</code>)再跟上<code>1</code>个或多个数字(<code>[0-9]+</code>)，并且后面没有其他任何东西(<code>$</code>)。下面你将知道能够使用的更为简单的方法。</p>
<p>特殊字符 <code>?</code> 与 {<code>0,1</code>} 是相等的，它们都代表着： <code>0</code>个或<code>1</code>个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\-?[0-9]&#123;1,&#125;\.?[0-9]&#123;1,&#125;$</span><br></pre></td></tr></table></figure>

<p>特殊字符 <code>*</code> 与 <code>&#123;0,&#125;</code> 是相等的，它们都代表着 <code>0</code> 个或多个前面的内容 。最后，字符 <code>+</code> 与 <code>&#123;1,&#125;</code> 是相等的，表示 <code>1</code> 个或多个前面的内容 ，所以上面的4个例子可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 </span><br><span class="line">^[1-9][0-9]*$        // 所有的正整数 </span><br><span class="line">^\-?[0-9]+$          // 所有的整数 </span><br><span class="line">^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数</span><br></pre></td></tr></table></figure>

<p>当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。</p>
<h4 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h4><p>下面列出一些正则表达式示例：</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;\b([a-z]+) \1\b&#x2F;gi</td>
<td>一个单词连续出现的位置。</td>
</tr>
<tr>
<td>&#x2F;(\w+)://([^&#x2F;:]+)(:\d*)?([^# ]*)&#x2F;</td>
<td>匹配一个 URL 解析为协议、域、端口及相对路径。</td>
</tr>
<tr>
<td>&#x2F;^(?:Chapter|Section) [1-9][0-9]{0,1}$&#x2F;</td>
<td>定位章节的位置。</td>
</tr>
<tr>
<td>&#x2F;[-a-z]&#x2F;</td>
<td>a 至 z 共 26个 字母再加一个 <code>-</code> 号。</td>
</tr>
<tr>
<td>&#x2F;ter\b&#x2F;</td>
<td>可匹配 chapter，而不能匹配 terminal。</td>
</tr>
<tr>
<td>&#x2F;\Bapt&#x2F;</td>
<td>可匹配 chapter，而不能匹配 aptitude。</td>
</tr>
<tr>
<td>&#x2F;Windows(?&#x3D;95 |98 |NT )&#x2F;</td>
<td>可匹配 Windows95 或 Windows98 或 WindowsNT，当找到一个匹配后，从 Windows 后面开始进行下一次的检索匹配。</td>
</tr>
<tr>
<td>&#x2F;^\s*$&#x2F;</td>
<td>匹配空行。</td>
</tr>
<tr>
<td>&#x2F;\d{2}-\d{5}&#x2F;</td>
<td>验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</td>
</tr>
<tr>
<td>&lt;[a-zA-Z]+.<em>?&gt;([\s\S]</em>?)</td>
<td>匹配 HTML 标记。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hello</td>
<td>匹配 {hello}</td>
</tr>
<tr>
<td>gray|grey</td>
<td>匹配 {gray, grey}</td>
</tr>
<tr>
<td>gr(a|e)y</td>
<td>匹配 {gray, grey}</td>
</tr>
<tr>
<td>gr[ae]y</td>
<td>匹配 {gray, grey}</td>
</tr>
<tr>
<td>b[aeiou]bble</td>
<td>匹配 {babble, bebble, bibble, bobble, bubble}</td>
</tr>
<tr>
<td>[b-chm-pP]at|ot</td>
<td>匹配 {bat, cat, hat, mat, nat, oat, pat, Pat, ot}</td>
</tr>
<tr>
<td>colou?r</td>
<td>匹配 {color, colour}</td>
</tr>
<tr>
<td>rege(x(es)?|xps?)</td>
<td>匹配 {regex, regexes, regexp, regexps}</td>
</tr>
<tr>
<td>go*gle</td>
<td>匹配 {ggle, gogle, google, gooogle, goooogle, …}</td>
</tr>
<tr>
<td>go+gle</td>
<td>匹配 {gogle, google, gooogle, goooogle, …}</td>
</tr>
<tr>
<td>g(oog)+le</td>
<td>匹配 {google, googoogle, googoogoogle, googoogoogoogle, …}</td>
</tr>
<tr>
<td>z{3}</td>
<td>匹配 {zzz}</td>
</tr>
<tr>
<td>z{3,6}</td>
<td>匹配 {zzz, zzzz, zzzzz, zzzzzz}</td>
</tr>
<tr>
<td>z{3,}</td>
<td>匹配 {zzz, zzzz, zzzzz, …}</td>
</tr>
<tr>
<td>[Bb]rainf**k</td>
<td>匹配 {Brainf<strong>k, brainf</strong>k}</td>
</tr>
<tr>
<td>\d</td>
<td>匹配 {0,1,2,3,4,5,6,7,8,9}</td>
</tr>
<tr>
<td>1\d{10}</td>
<td>匹配 11 个数字，以 1 开头</td>
</tr>
<tr>
<td>[2-9]|[12]\d|3[0-6]</td>
<td>匹配 2 到 36 范围内的整数</td>
</tr>
<tr>
<td>Hello\nworld</td>
<td>匹配 Hello 后跟换行符，后跟 world</td>
</tr>
<tr>
<td>\d+(.\d\d)?</td>
<td>包含一个正整数或包含两位小数位的浮点数。</td>
</tr>
<tr>
<td>[^*@#]</td>
<td>排除 *、@ 、# 三个特色符号</td>
</tr>
<tr>
<td>&#x2F;&#x2F;[^\r\n]*[\r\n]</td>
<td>匹配 &#x2F;&#x2F; 开头的注释</td>
</tr>
<tr>
<td>^dog</td>
<td>匹配以 “dog” 开始</td>
</tr>
<tr>
<td>dog$</td>
<td>匹配以 “dog” 结尾</td>
</tr>
<tr>
<td>^dog$</td>
<td>is exactly “dog”</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="cllwc4xiu0016jsmof9ed0yw3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-早期系统采用数据库来管理和存放数据，但随着大数据技术的兴起，大家想要通过大数据技术来找到数据之间可能存在的关系，所以大家设计了一套新的数据存储管理系统，把所有的数据全部存储到数据仓库，然后统一对数据处理，这个系统叫做数据仓库。" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.424Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>早期系统采用数据库来管理和存放数据，但随着大数据技术的兴起，<strong>大家想要通过大数据技术来找到数据之间可能存在的关系，所以大家设计了一套新的数据存储管理系统，把所有的数据全部存储到数据仓库，然后统一对数据处理，这个系统叫做数据仓库。</strong></p>
<h5 id="数据仓库是来自一个或者多个不同源的集成数据中央存储库。"><a href="#数据仓库是来自一个或者多个不同源的集成数据中央存储库。" class="headerlink" title="数据仓库是来自一个或者多个不同源的集成数据中央存储库。"></a>数据仓库是来自一个或者多个不同源的集成数据中央存储库。</h5><p>数据仓库将当前和历史数据存储在一起，以利于各种分析方法如在线分析处理（OLAP），数据挖掘（data mining），帮助决策者能快速从大量的数据中，分析西湖有价值的信息，帮助构建商业智能（BI).</p>
<p>尽管仓库非常适合存储结构化数据，但是许多现在企业必须处理非结构化数据，半结构化数据以及具有高多样性，高速度和高容量的数据。数据仓库不适用于许多此类场景，并且成本效益并非最佳。</p>
<p>数据湖的出现是为了弥补数据仓库只能存储结构化数据的缺陷，数据湖的种类比较丰富可以包罗万象。</p>
<p><strong>数据仓库更加适合成熟的数据当中的分析和处理，数据湖更加适合在异构数据上的价值的挖掘。</strong></p>
<p><strong>数据湖虽然适合存储数据，但是缺少一些关键的功能：他不支持事务处理，不保证数据质量，并且缺乏一致性&#x2F;隔离性，从而几乎无法实现混合追加和读取数据，以及完成批处理和流式作业。</strong></p>
<h4 id="湖仓一体化为什么诞生？"><a href="#湖仓一体化为什么诞生？" class="headerlink" title="湖仓一体化为什么诞生？"></a>湖仓一体化为什么诞生？</h4><p>数据仓库只能处理单一的结构化数据，对于在线的事务分析处理非常实用。<strong>但是现在很多公司对各类数据应用包括SQL分析，实时监控，数据科学和机器学习的灵活性、高性能系统的需求并未减少</strong>。</p>
<p>AI的大部分最新进展是基于更好地处理非结构化数据（如text、images、video、audio）的模型，完全纯数据仓库的二维关系表已经无法承接半&#x2F;非结构化数据的处理，AI引擎不可能只跑在纯数据仓库模型上。</p>
<p>结合数据仓库和数据湖优势，建立互藏一体化，进而解决数据湖和数据仓库的局限性：<strong>直接在用于数据湖的低成本存储上实现与数据仓库中类似的数据结构和数据管理功能。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/" data-id="cllwc4xit0015jsmo3wdkbfyq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-引用、指针和const的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.416Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="引用、指针和const的关系"><a href="#引用、指针和const的关系" class="headerlink" title="引用、指针和const的关系"></a>引用、指针和const的关系</h1><p>右值引用，可以引用指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * &amp;&amp;a1=(<span class="type">int</span> *)<span class="number">0X0000</span> FFFF</span><br></pre></td></tr></table></figure>

<p>右值引用只能引用不具名的对象，就是没有名字的对象，左值引用不能引用没有名字的对象。</p>
<p>函数返回时创建的临时对象就是不具名对象，可以用右值引用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cllwc4xin0012jsmoccfo15h9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-协同过滤算法的分类：" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.409Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="协同过滤算法的分类："><a href="#协同过滤算法的分类：" class="headerlink" title="协同过滤算法的分类："></a>协同过滤算法的分类：</h3><p>基于模型的协同过滤算法；</p>
<p>​		模型构建：将用户的浏览、点击、购买与咨询信息建立用户喜好综合模型。</p>
<p>基于内存的协同过滤算法。</p>
<p>​       以用户的想法为根据的过滤算法，先根据用户的实际需求筛选与其想法类似的协同邻居用户胡，再根据协同邻居用户的关联项目为推荐对象和评分对象，对用户进行推荐。</p>
<p>协同过滤算法的核心思想是在短时间内有效搜寻用户喜好相关的邻居用户，根据邻居用户对项目的喜好进行筛选与排序，将结果推荐给初始用户。</p>
<h3 id="个性化推荐系统模块："><a href="#个性化推荐系统模块：" class="headerlink" title="个性化推荐系统模块："></a>个性化推荐系统模块：</h3><h5 id="源数据管理"><a href="#源数据管理" class="headerlink" title="源数据管理"></a>源数据管理</h5><h5 id="ETL管理："><a href="#ETL管理：" class="headerlink" title="ETL管理："></a>ETL管理：</h5><h5 id="数据策略管理："><a href="#数据策略管理：" class="headerlink" title="数据策略管理："></a>数据策略管理：</h5><h5 id="集群管理："><a href="#集群管理：" class="headerlink" title="集群管理："></a>集群管理：</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/" data-id="cllwc4xib000wjsmo2bzweqrx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.401Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="cllwc4xjd001hjsmo8pob1fa0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.393Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程是程序的 一次执行</p>
<p>线程是进程的一条执行路径。</p>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
<p>线程调度时耗费的资源较少是因为，在其进行线程转换时，操作系统只需要保存少量的线程信息，线程与进程共享一部分资源。</p>
<h4 id="线程的实现方式：用户级线程，内核级线程，组合型线程"><a href="#线程的实现方式：用户级线程，内核级线程，组合型线程" class="headerlink" title="线程的实现方式：用户级线程，内核级线程，组合型线程"></a>线程的实现方式：用户级线程，内核级线程，组合型线程</h4><p>用户级线程：创建的开销小，可以创建很多；但是无法使用多个处理器（因为内核无法感知到）</p>
<p>内核级线程：相对于用户级线程来说，创建的开销大，由内核直接管理，可以使用多个处理器</p>
<p>组合型线程：介于两者之间</p>
<h4 id="线程与进程之间的区别"><a href="#线程与进程之间的区别" class="headerlink" title="线程与进程之间的区别"></a>线程与进程之间的区别</h4><p>◼进程是资源分配的最小单位，线程是 CPU 调度的最小单位 </p>
<p>◼ 进程有自己的独立地址空间，线程共享进程中的地址空间 </p>
<p>◼ 进程的创建消耗资源大，线程的创建相对较小 </p>
<p>◼ 进程的切换开销大，线程的切换开销相对较小</p>
<p><strong>每个线程可以是执行相同的代码，也可以执行不同的代码。</strong></p>
<h4 id="为什么用到多线程："><a href="#为什么用到多线程：" class="headerlink" title="为什么用到多线程："></a>为什么用到多线程：</h4><p>1.因为程序有时候需要完成多个事情，所以要用到多线程，例如QQ要同时发消息和接收消息就是一个多线程</p>
<p>2.为了更大限度的利用计算机的资源，利用多处理器</p>
<p>main函数为入口函数：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220112162315576.png" alt="image-20220112162315576"></p>
<p>多线程之间是并发执行的，</p>
<p>线程的操作可能出现不确定性，所以我们要加以控制。因此需要引入线程同步：互斥量，信号量，条件变量，读写锁。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220112163356747.png" alt="image-20220112163356747">上例的输出结果觉具有不确定性。</p>
<p>如何加以控制：</p>
<p>要在主线程中等一下，其他线程的执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg);<span class="comment">//创建线程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pthread_create()用于创建线程</span></span><br><span class="line"><span class="comment">thread： 接收创建的线程的 ID</span></span><br><span class="line"><span class="comment">attr： 指定线程的属性</span></span><br><span class="line"><span class="comment">start_routine： 指定线程函数</span></span><br><span class="line"><span class="comment">arg： 给线程函数传递的参数</span></span><br><span class="line"><span class="comment">成功返回 0， 失败返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pthread_exit(<span class="type">void</span> *retval);<span class="comment">//副线程退出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pthread_exit()退出线程</span></span><br><span class="line"><span class="comment"> retval：指定退出信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pthread_join(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval);<span class="comment">//主线程等待</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pthread_join()等待 thread 指定的线程退出，线程未退出时，该方法阻塞</span></span><br><span class="line"><span class="comment"> retval：接收 thread 线程退出时，指定的退出信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gcc -o main main.c -lpthread;<span class="comment">//编译多线程的命令</span></span><br></pre></td></tr></table></figure>

<p>一般情况下主线程肯定是最后推出的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、理解线程的同步运行</span><br><span class="line">2、线程同步：信号量 互斥锁 条件变量 读写锁</span><br></pre></td></tr></table></figure>

<h4 id="什么是线程的并发运行-？"><a href="#什么是线程的并发运行-？" class="headerlink" title="什么是线程的并发运行  ？"></a>什么是线程的并发运行  ？</h4><p>并发是指在一段时间内同时做多个事情，比如在1点-2点洗碗、洗衣服等。而并行是指在同一时刻做多个事情，比如1点我左手画圆右手画方。两个很重要的区别就是“一段时间”和“同一时刻”.</p>
<p>在操作系统中就是:</p>
<p>　　<strong>1)并发就是在单核处理中同时处理多个任务.(这里的同时指的是逻辑上的同时)</strong></p>
<p>　　<strong>2)并行就是在多核处理器中同时处理多个任务.(这里的同时指的就是物理上的同时)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void *pthread_fun(void *)</span><br><span class="line">&#123;</span><br><span class="line">int index=*((int *)arg);</span><br><span class="line">for(int i=0;i&lt;3;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;index=%d\n&quot;,index);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t id[5];</span><br><span class="line">    int i=0;</span><br><span class="line">    for(;i&lt;5;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;id[i],NULL,pthread_fun,(void*)&amp;i)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;5;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(id[i],NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下图的操作结果是2，非3。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220112175806759.png" alt="image-20220112175806759"></p>
<p>例如：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220114155503141.png" alt="image-20220114155503141"></p>
<p>​    如上图的程序当中:我们所创建的线程都要对index进行操作，这里只是进行输出而没有进行其他的操作，如果是进行自加或者自减的操作，在最后的结果中有出错的可能性，如果有5个线程，每个线程都对index进行1000++操作，如果我们不进行任何干涉，那最后其结果肯定是&lt;&#x3D;5000的，因为在多处理器上我们的线程是并行的。</p>
<h5 id="在多处理器的机器上，线程之间是并发运行的，当出现上图的情况时，可能会出现多个线程会同时访问同一快内存的现象，然后做得操作相同的话，就会在最后的结果输出的时候出错，所以我们要尽量避免这种情况的发生，这就要引入进程同步的概念了"><a href="#在多处理器的机器上，线程之间是并发运行的，当出现上图的情况时，可能会出现多个线程会同时访问同一快内存的现象，然后做得操作相同的话，就会在最后的结果输出的时候出错，所以我们要尽量避免这种情况的发生，这就要引入进程同步的概念了" class="headerlink" title="在多处理器的机器上，线程之间是并发运行的，当出现上图的情况时，可能会出现多个线程会同时访问同一快内存的现象，然后做得操作相同的话，就会在最后的结果输出的时候出错，所以我们要尽量避免这种情况的发生，这就要引入进程同步的概念了"></a>在多处理器的机器上，线程之间是并发运行的，当出现上图的情况时，可能会出现多个线程会同时访问同一快内存的现象，然后做得操作相同的话，就会在最后的结果输出的时候出错，所以我们要尽量避免这种情况的发生，这就要引入进程同步的概念了</h5><h3 id="线程如何进行同步"><a href="#线程如何进行同步" class="headerlink" title="线程如何进行同步"></a>线程如何进行同步</h3><p>可以通过：<strong>互斥锁，信号量，读写锁，条件变量</strong>来控制线程，达到线程同步的作用。</p>
<h4 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220114162806861.png" alt="image-20220114162806861"></p>
<p>使用信号量与进程间通信的信号量非常相似，但是线程间的信号量不需要我们进行封装操作：</p>
<p>需要添加头文件：#include&lt;semaphore.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;<span class="comment">//信号量初始化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sem : 指向被操作的信号量</span></span><br><span class="line"><span class="comment">pshared : 指定信号量类型，如果为0表示信号量是当前进程的局部信号量，否则该信号量就可以在多个进程之间共享。</span></span><br><span class="line"><span class="comment">value ： 指定信号量的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//信号量P操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//信号量V操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">//信号量销毁</span></span><br></pre></td></tr></table></figure>

<p>信号量操作的实例：</p>
<p><strong>当多线程要做相同的事事，可以使用同一个线程函数来进行操作，当多线程操作的是不同的事时，就要写多个不同的线程函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数要使用函数指针</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">pthread_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;sem);<span class="comment">//信号量减一，P操作（线程获得信号量）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,index++);</span><br><span class="line">        sem_post(&amp;sem);<span class="comment">//信号量加一，V操作（线程释放信号量）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出线程，并返回相应的变量</span></span><br><span class="line">    pthread_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> id[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthrea_create(&amp;id[i],<span class="literal">NULL</span>,pthread_fun,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(&amp;id[i]);<span class="comment">//等待每个线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sem);<span class="comment">//删除信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让三个线程分别输出ABC，最后的输出结果为ABCABCABC…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funA</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;sem[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;sem[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">funB</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;sem[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;sem[<span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">funC</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;sem[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;sem[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_init(&amp;sem[i],<span class="number">0</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> id[<span class="number">3</span>];</span><br><span class="line">    pthread_create(&amp;id[<span class="number">0</span>],<span class="literal">NULL</span>,funA,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id[<span class="number">1</span>],<span class="literal">NULL</span>,funB,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id[<span class="number">2</span>],<span class="literal">NULL</span>,funC,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(&amp;id[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(sem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="互斥锁：同值为1的信号量的操作非常相似"><a href="#互斥锁：同值为1的信号量的操作非常相似" class="headerlink" title="互斥锁：同值为1的信号量的操作非常相似"></a>互斥锁：同值为1的信号量的操作非常相似</h4><p>当我们对资源的访问是一种互斥性的访问就使用互斥锁来操作</p>
<p>互斥锁是包含在#include&lt;pthread.h&gt;中的线程同步的方法，所以不用再加头文件</p>
<p>互斥锁的接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//声明锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">pthread_mutexattr_t</span> *attr)</span>;<span class="comment">//初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置互斥量的属性，我们一般设置为NULL就好，其默认为fast</span></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">//删除锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220114170330556.png" alt="image-20220114170330556"></p>
<p>我们可以看到互斥量的使用其实和值为1的信号量非常相似</p>
<p>互斥锁的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义一个互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,index++);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex，<span class="literal">NULL</span>);<span class="comment">//初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> id[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthrea_create(&amp;id[i],<span class="literal">NULL</span>,pthread_fun,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(&amp;id[i]);<span class="comment">//等待每个线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);<span class="comment">//删除互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>线程安全</strong>：不管在什么样调度的情况下，运行出来的结果总是正确的我们称之为线程安全。线程安全即就是在多线程运行的时候，不论线程的调度顺序怎样，最终的结果都是 一样的、正确的。那么就说这些线程是安全的。</p>
<p>​        要保证线程安全需要做到：</p>
<p> 1） 对线程同步，保证同一时刻只有一个线程访问临界资源。 </p>
<p> 2） 在多线程中使用线程安全的函数（可重入函数），所谓线程安全的函数指的是：如果一个 函数能被多个线程同时调用且不发生竟态条件，则我们程它是线程安全的。</p>
<p>3）多线程中尽量不要使用静态变量，否则难以保证线程安全。</p>
<p><strong>我们在编写程序的时候要既保证线程安全，又要保证程序的运行效率，那么锁的使用就要使得锁的粒度足够小。只保护临界资源即可，其余的程序是可以并行访问的，除了临界资源需要并发访问。</strong></p>
<p><strong>条件变量</strong>：条件变量提供一种线程间的通知机制，当某一共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</p>
<p><strong>mutex是用来保护条件变量的互斥锁，以保证pthread_cond_wait的原子性。在调用pthread_cond_wait的时候必须保证pthread_cond_wait的原子性，否则将出现不可预知的错误。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span>   <span class="comment">//头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond,<span class="type">pthread_condattr_t</span>* attr)</span>;  <span class="comment">//初始化条件变量，pthread_cond_t*cond是条件变量的地址，pthread_condattr_t* attr是条件变量的属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化条件变量的方式：</span></span><br><span class="line"><span class="comment">pthread_cond_t condition = PTHREAD_COND_INITIALIZER;使用宏来初始化条件变量，实际上只是把条件变量的各个字段都初始化为0了；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>*cond,<span class="type">pthread_mutex_t</span>*mutex)</span>;<span class="comment">//用于等待目标条件变量，执行时先调用线程放入条件变量的等待队列中，然后将互斥锁mutex解锁，当pthread_cond_wait()成功返回时，互斥锁mutex将再次被锁上。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;<span class="comment">//唤醒单个等待目标条件变量的进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcost</span><span class="params">(<span class="type">pthread_cond_t</span>*cond)</span>;<span class="comment">//唤醒所有等待目标条件变量的进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>*cond)</span>;<span class="comment">//销毁条件变量，释放其占用的内核资源，</span></span><br><span class="line"><span class="comment">//销毁一个正在被等待的条件变量将失败，并返回EBUSY</span></span><br></pre></td></tr></table></figure>

<p>如下实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s = (<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun1 read:%s\n&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s = (<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun2 read:%s\n&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(s,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;id[<span class="number">0</span>],<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id[<span class="number">1</span>],<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            pthread_cond_broadcast(&amp;cond);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            pthread_cond_signal(&amp;cond);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(id[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读写锁：</strong>读写锁其实同互斥锁非常的像，同时用来控制共享数据的，但是使用互斥锁之后，我们的共享资源就只能被一个线程所使用的，虽然保证了其安全性，但是却失去了他的高效性。这个时候我们就可以使用读写锁来解决这一问题了，顾名思义共享资源就是可以被多个线程所使用的的资源。<strong>我们的共享资源在同一时刻只能被一个线程去写，如果多个线程同时写对一个变量进行修改，那么有些修改可能就是不奏效的，失去了其功能，会造成意想不到的错误；但是多个线程同时去读一个共享变量却不会产生什么不好的影响，由此产生了读写锁。</strong> </p>
<p>​        由上可知，我们的读写锁，在读的时候不允许写，但是允许其他的线程对变量进行读；在写的时候，仅仅只允许一个进程对变量进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">pthread_rwlockattr_t</span> *attr)</span>;<span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//上读锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//上写锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//销毁锁</span></span><br></pre></td></tr></table></figure>

<p><strong>多线程中某个线程调用 fork()，子进程会有和父进程相同数量的线程吗？</strong></p>
<p>​        进程fork后，fork所在的那一条线程会会继续执行。</p>
<p>（1）如果fork()之后，子进程继续向下执行，有创建线程的话，子进程会创建线程；</p>
<p>（2）如果fork()之后，子进程继续向下执行，没有创建线程的话，子进程就不会创建线程；</p>
<p>（3）fork在线程函数里的话，只会把线程复制一份。<br>        不管怎么样，<strong>fork都复制了整个进程，但是只启用了它所在的那个执行路径</strong>，如果它所在的那个执行路径fork后有创建线程的话，子进程会创建线程；如果它所在的那个执行路径fork后没有创建线程而在fork之前有创建线程的话，那么fork不会启用fork之前创建的线程，只会启用当前所在线程，继续执行下去。</p>
<h5 id="父进程被加锁的互斥锁-fork-后在子进程中是否已经加锁？"><a href="#父进程被加锁的互斥锁-fork-后在子进程中是否已经加锁？" class="headerlink" title="父进程被加锁的互斥锁 fork 后在子进程中是否已经加锁？"></a>父进程被加锁的互斥锁 fork 后在子进程中是否已经加锁？</h5><p>答：父进程的锁会被复制到子进程中，fork复制时候，父进程的锁是什么状态，fork的进程的锁就是什么状态。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318195045018.png" alt="image-20220318195045018"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BA%BF%E7%A8%8B/" data-id="cllwc4xja001gjsmoabb102e2" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-网络编程小总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.375Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ifndef-和-pragma-once有什么区别？"><a href="#ifndef-和-pragma-once有什么区别？" class="headerlink" title="#ifndef 和#pragma once有什么区别？"></a>#ifndef 和#pragma once有什么区别？</h2><p><strong>摘要：</strong> 一、相同点     两者的共同点都是为了避免同一个文件被 include 多次，但是 #ifndef #define #endif 不只有这个作用。 在能够支持这两种方式的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。</p>
<p><strong>1.#pragma once</strong><br>    这个是编译器相关，就是说在这个编译系统上能用，在其他编译系统不一定行，即移植性差。不过现在基本上已经是每个编译器都有这个定义了。<br>    此方式由编译器保证同一个文件不会被包含多次。注意：这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。于是不必再费劲想个宏名了，当然也就可以避免宏的名字冲突问题了。 </p>
<p>缺点：如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。 </p>
<p><strong>2.#ifndef #define #endif</strong><br>    该方法与 C++ 语言相关，是 C++ 语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持 C++ 语言的编译器上都是有效的。如果写的程序要跨平台，最好使用这种方式。该方式由于是 C++ 语言本身支持，所以移植性好。它依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。另外，为了保证不同头文件中的宏名不冲突，故采取类似于_ABC_H_的取名方式。其中，abc.h为当前头文件名。</p>
<p><strong>总结：</strong>两者都有避免头文件被重复包含的作用，但是#pragma once的移植性更差，且如果某个文件有多份拷贝，#pragma once 不能保证他们不会被重复包含；#ifndef #define #endif 的功能能更强大，他是C++中的宏定义，移植性更好，且也能保证内容完全相同的两个文件不会被不小心同时包含。</p>
<h4 id="为什么不在文件的的前面声明using-namespace-std-而是要在每一个相对应的对象前加上std-cout"><a href="#为什么不在文件的的前面声明using-namespace-std-而是要在每一个相对应的对象前加上std-cout" class="headerlink" title="为什么不在文件的的前面声明using namespace std;而是要在每一个相对应的对象前加上std::cout."></a>为什么不在文件的的前面声明using namespace std;而是要在每一个相对应的对象前加上std::cout.</h4><p>假如我们一个文件不只一个命名空间，但是多个命名空间中都声明了同一种方法，我们使用不同命名空间中的同名方法时，就难以确定每个方法属于哪个命名空间，造成命名空间的污染。使用后者的优势在于我们可以清楚地知道每个方法来自于哪个命名空间。</p>
<h4 id="初始化列表的好处是？"><a href="#初始化列表的好处是？" class="headerlink" title="初始化列表的好处是？"></a>初始化列表的好处是？</h4><p>1.<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">类成员</a>中存在常量，如const int a,只能用初始化不能赋值</p>
<p>2.类成员中存在引用，同样只能使用初始化不能赋值。</p>
<p>3.提高效率</p>
<h4 id="multimap、map和unorder-mao的区别是什么？"><a href="#multimap、map和unorder-mao的区别是什么？" class="headerlink" title="multimap、map和unorder_mao的区别是什么？"></a>multimap、map和unorder_mao的区别是什么？</h4><p>map是STL的一个关联容器，它提供一对一的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>。</p>
<ul>
<li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>
<li>第二个可能称为该关键字的值(value)；</li>
</ul>
<p>map以模板(<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B&spm=1001.2101.3001.7020">泛型</a>)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。</p>
<p>map的底层是一颗红黑树</p>
<p>unorder_map的底层是hash表</p>
<p>multimap和map的功能类似，就不一一介绍了，下面主要说一下这两者的不同：</p>
<p>1、multimap中的key可以重复</p>
<p>2、multimap中没有重载operator[ ]功能</p>
<h5 id="谈谈unordered-map和map的区别"><a href="#谈谈unordered-map和map的区别" class="headerlink" title="谈谈unordered_map和map的区别"></a>谈谈unordered_map和map的区别</h5><h6 id="1、内部实现机理不同："><a href="#1、内部实现机理不同：" class="headerlink" title="1、内部实现机理不同："></a>1、内部实现机理不同：</h6><p><strong>map :map</strong>内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong>红黑树具有自动排序的功能</strong>，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树 （又名二叉查找树、二叉排序树–特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根结点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map :unordered_map</strong>内部实现了一个<strong>哈希表</strong> （也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序都是无序的。哈表的概念见：详谈哈希表。</p>
<h6 id="2、谈谈各自的优缺点："><a href="#2、谈谈各自的优缺点：" class="headerlink" title="2、谈谈各自的优缺点："></a>2、谈谈各自的优缺点：</h6><p><strong>map</strong><br>1、优点：</p>
<p>    (1)有序性，这是map结构最大的有点，其元素的有序性在很多应用中都会简化很多的操作。</p>
<p>    (2)红黑树，内部实现一个红黑树使得map的很多操作在lg（n）的时间复杂度下就可以实现，因此效率非常的高。</p>
<p>2、缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间。</p>
<p>3、适用处：<strong>对于那些有顺序要求的问题，用map会更高效一些。</strong></p>
<p><strong>unordered_map</strong><br>1、优点：因为内部实现了哈希表，因此其查找速度非常的快。</p>
<p>2、缺点：哈希表的建立比较耗费时间</p>
<p>3、适用处：<strong>对于查找问题，unordered_map 会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</strong></p>
<p>3、总结：</p>
<p>1、内存占有率的问题就转化成红黑树 VS Hash表，还是unorder_map占用的内存要高。</p>
<p>2、但是unorder_map执行效率要比map高很多</p>
<p>3、对于unordered_map 或unordered_set 容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的。</p>
<h4 id="C-有几种类的成员函数？（6）"><a href="#C-有几种类的成员函数？（6）" class="headerlink" title="C++有几种类的成员函数？（6）"></a>C++有几种类的成员函数？（6）</h4><ul>
<li>一、构造函数（特殊的成员函数）</li>
<li>二、析构函数（特殊的成员函数）</li>
<li>三、拷贝构造函数（特殊的成员函数）</li>
<li>四、赋值运算符重载函数</li>
<li>五、取地址操作符重载 和 const修饰的取地址操作符重载</li>
</ul>
<h4 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h4><h5 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h5><p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>
<h5 id="单例模式有两种类型："><a href="#单例模式有两种类型：" class="headerlink" title="单例模式有两种类型："></a>单例模式有两种类型：</h5><ul>
<li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li>
<li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li>
</ul>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728144322594.png" alt="image-20220728144322594"></p>
<h4 id="进程与线程的区别？"><a href="#进程与线程的区别？" class="headerlink" title="进程与线程的区别？"></a>进程与线程的区别？</h4><ol>
<li><p>定义不一样，进程是执行中的一段程序，而一个进程中执行中的每个任务即为一个线程。</p>
</li>
<li><p>一个线程只可以属于一个进程，但一个进程能包含多个线程。</p>
</li>
<li><p>线程无地址空间，它包括在进程的地址空间里。</p>
</li>
<li><p>线程的开销或代价比进程的小。</p>
</li>
</ol>
<h4 id="并发与并行的区别？"><a href="#并发与并行的区别？" class="headerlink" title="并发与并行的区别？"></a>并发与并行的区别？</h4><p>二者都有“多个线程&#x2F;进程同时执行”的意思：</p>
<p><strong>但是</strong>：</p>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
</ul>
<h4 id="通过环境变量设置日志级别-，环境变量是自己设置的，凭什么能代表日志的级别呢？"><a href="#通过环境变量设置日志级别-，环境变量是自己设置的，凭什么能代表日志的级别呢？" class="headerlink" title="通过环境变量设置日志级别 ，环境变量是自己设置的，凭什么能代表日志的级别呢？"></a>通过环境变量设置日志级别 ，环境变量是自己设置的，凭什么能代表日志的级别呢？</h4><p>相当于宏替换，因为在项目当中我们要经常使用日志级别，将其设置在环境变量当中可以及时的进行替换；</p>
<h4 id="为什么要设置环境变量？"><a href="#为什么要设置环境变量？" class="headerlink" title="为什么要设置环境变量？"></a>为什么要设置环境变量？</h4><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，如临时文件夹位置和系统文件夹位置等。</p>
<p>环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程</p>
<h4 id="为什么要定义那几个宏？"><a href="#为什么要定义那几个宏？" class="headerlink" title="为什么要定义那几个宏？"></a>为什么要定义那几个宏？</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220729173324780.png" alt="image-20220729173324780"></p>
<h3 id="网络IO的两个阶段"><a href="#网络IO的两个阶段" class="headerlink" title="网络IO的两个阶段"></a>网络IO的两个阶段</h3><p>第一阶段：数据的准备阶段，将网卡上的数据包放到内核上</p>
<p>第二阶段：数据的拷贝阶段、从内核的缓冲区拷贝到用户空间</p>
<h4 id="IO演进"><a href="#IO演进" class="headerlink" title="IO演进"></a>IO演进</h4><ul>
<li><p>阻塞：读到缓冲区，数据没有准备好就一直阻塞着，缺点是占用线程不干事情</p>
</li>
<li><p>非阻塞（setnoblack）：当访问内核缓冲区的时候数据没有准备好，立即返回，缺点是空转CPU不停地进行系统调用，产生大量的终端</p>
</li>
<li><p>同步</p>
</li>
<li><p>异步</p>
</li>
</ul>
<h4 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h4><h5 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h5><ul>
<li>支持的文件描述符有上限 1024</li>
<li>用户空间拷贝到内核空间</li>
<li>内核空间再拷贝到用户空间</li>
<li>时间复杂度为O(n)</li>
</ul>
<h5 id="poll："><a href="#poll：" class="headerlink" title="poll："></a>poll：</h5><ul>
<li>底层数据结构为链表</li>
<li>还是要发生两次拷贝</li>
<li>时间复杂度还是为O(n)</li>
</ul>
<h5 id="epoll："><a href="#epoll：" class="headerlink" title="epoll："></a>epoll：</h5><ul>
<li>红黑树（为什么不用哈希表）：因为我我们知不道哈希表在什么时候会扩容。</li>
<li><strong>ET</strong>：边沿触发，ET在发现有我们关注的事情发生之后，会立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束。</li>
<li><strong>LT：</strong>电平触发，当发现文件描述符上有我们感性的事件时，触发事件的回调函数，但是当文件描述符上的数据没有读取完毕时，epoll_wait依旧会被使用，直到数据处理完毕</li>
</ul>
<h3 id="reactor"><a href="#reactor" class="headerlink" title="reactor:"></a>reactor:</h3><p>将事件和事件的处理方式绑定到一起，达到异步的处理效果。</p>
<h5 id="服务器端的reactor回调函数该如何写？"><a href="#服务器端的reactor回调函数该如何写？" class="headerlink" title="服务器端的reactor回调函数该如何写？"></a>服务器端的reactor回调函数该如何写？</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220801180320829.png" alt="image-20220801180320829"></p>
<p>主线程负责监听，当监听到事件之后，进行处理，子线程有两个任务一是处理主线程分发下来的任务，第二是处理cfd上发生的IO事件。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220803153026816.png" alt="image-20220803153026816"></p>
<p>Redis和mysql的基础架构都是CS架构，在实现项目的过程中，我们是封装一个客户端去访问mysql和Redis的服务器。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220804124512455.png" alt="image-20220804124512455"></p>
<h4 id="分层文件系统"><a href="#分层文件系统" class="headerlink" title="分层文件系统"></a>分层文件系统</h4><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><h4 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220804124618107.png" alt="image-20220804124618107"></p>
<p>删除容器之前需要先将容器停掉</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%80%BB%E7%BB%93/" data-id="cllwc4xjj001ljsmoghu717u0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-同步、异步和阻塞、非阻塞之间的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.365Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="同步、异步和阻塞、非阻塞之间的关系"><a href="#同步、异步和阻塞、非阻塞之间的关系" class="headerlink" title="同步、异步和阻塞、非阻塞之间的关系"></a>同步、异步和阻塞、非阻塞之间的关系</h1><h2 id="什么是同步I-O？-什么是异步I-O？"><a href="#什么是同步I-O？-什么是异步I-O？" class="headerlink" title="什么是同步I&#x2F;O？ 什么是异步I&#x2F;O？"></a>什么是同步I&#x2F;O？ 什么是异步I&#x2F;O？</h2><ul>
<li><h3 id="同步（阻塞）I-O"><a href="#同步（阻塞）I-O" class="headerlink" title="同步（阻塞）I&#x2F;O"></a>同步（阻塞）I&#x2F;O</h3><p>在一个线程当中，CPU的执行速度极快，然而一旦遇到I&#x2F;O操作，如读写文件，发送网络数据是，就需要等待IO操作完成，才能继续下一步操作。这种情况成为异步IO。</p>
</li>
<li><h3 id="异步（非阻塞）I-O"><a href="#异步（非阻塞）I-O" class="headerlink" title="异步（非阻塞）I&#x2F;O"></a>异步（非阻塞）I&#x2F;O</h3><p>当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果是，再通知CPU进行处理。</p>
</li>
</ul>
<h4 id="同步才有阻塞，异步没有阻塞！"><a href="#同步才有阻塞，异步没有阻塞！" class="headerlink" title="同步才有阻塞，异步没有阻塞！"></a>同步才有阻塞，异步没有阻塞！</h4><h2 id="Linux下有三种I-O复用方式：select，poll，epoll，三者的区别是什么？"><a href="#Linux下有三种I-O复用方式：select，poll，epoll，三者的区别是什么？" class="headerlink" title="Linux下有三种I&#x2F;O复用方式：select，poll，epoll，三者的区别是什么？"></a>Linux下有三种I&#x2F;O复用方式：select，poll，epoll，三者的区别是什么？</h2><ul>
<li>对于select和poll来说，所有的文件描述符都是在用户态被加入文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合都维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且有很多短期活跃连接的情况下，epoll需要频繁的进行系统调用，因此可能会慢于select和poll。</li>
<li>select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层是通过红黑树来描述的，并且维护一个ready_list，将事件表中已经就绪的事件添加到list中，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</li>
<li>select和poll最大的开销来源于判断是否有文件描述符就绪这一过程；每次执行select或者poll 的时候，他们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要进行这些检查，当有活动产生的时候，会自动触发epoll回调函数同志epoll文件描述符，然后内核就将这些就绪的文件描述符放到之前提到的ready_list 中，等待epoll_wait调用后被处理。</li>
<li>select和poll只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。</li>
<li>综上所述，当检测的fd数量较少，且各个fd都很活跃的情况下，建议使用select或者poll；当监听的fd数量较多，且单位时间仅部分fd活动的情况下，使用epoll的效果会更好。</li>
</ul>
<h3 id="epoll对文件描述符的操作有两种模式：LT（电平触发）模式和ET（边缘触发）模式，二者的区别在于你调用epoll-wait-的时候内核里面发生了什么。"><a href="#epoll对文件描述符的操作有两种模式：LT（电平触发）模式和ET（边缘触发）模式，二者的区别在于你调用epoll-wait-的时候内核里面发生了什么。" class="headerlink" title="epoll对文件描述符的操作有两种模式：LT（电平触发）模式和ET（边缘触发）模式，二者的区别在于你调用epoll_wait 的时候内核里面发生了什么。"></a>epoll对文件描述符的操作有两种模式：LT（电平触发）模式和ET（边缘触发）模式，二者的区别在于你调用epoll_wait 的时候内核里面发生了什么。</h3><ul>
<li><h4 id="LT（电平触发）："><a href="#LT（电平触发）：" class="headerlink" title="LT（电平触发）："></a>LT（电平触发）：</h4><p>类似于select，LT回去遍历在epoll事件表中的每个文件描述符，看是否有我们关注的事情发生，如果有（触发该文件描述符上的回调函数），epoll_wait就会以非阻塞的方式返回。若改epoll时间没有被处理完（没有返回EWOULDBLOCK），该事件还会被后续的epoll_wait再次出发，直到读写完毕。</p>
</li>
<li><h4 id="ET（边沿触发）："><a href="#ET（边沿触发）：" class="headerlink" title="ET（边沿触发）："></a>ET（边沿触发）：</h4><p>ET在发现有我们关注的事情发生之后，会立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束。</p>
</li>
</ul>
<p>使用ET模式是，必须要保证文件描述符是非阻塞的（确保在没有数据可读是，该文件描述符不会一直阻塞）；并且每次调用read和write的时候都必须等到他们返回EWOULDBLOCK（确保所有的数据都以读写完成）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cllwc4xid000xjsmo1p5oehyk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-听课的时候遇到的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%90%AC%E8%AF%BE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.357Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121132421140.png" alt="image-20220121132421140"></p>
<p>这点儿没看懂~！！！！</p>
<p>咋反转的？</p>
<p>string的输出函数是怎么回事？没搞懂</p>
<p>在实现poll的时候，可以编译成功，但是不能成功运行。</p>
<p>selcet操作上限：1024</p>
<p>poll就是一个加强版的select；poll可以处理大量的描述符，但是会使得性能降低。epoll就是为了处理大量的进程，为了应对描述符较多的问题；</p>
<p>select ，poll内核实现：轮询 O(n)，每次都要将描述符拷贝到内核</p>
<p>epoll 内核实现：注册回调函数方式O(1），每个描述符只考虑一次</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315103440948.png" alt="image-20220315103440948"></p>
<p>netstat -natp</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316134535362.png" alt="image-20220316134535362"></p>
<p>这里为什么要更改工作路径为根目录，清除掩码为0.</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220228182130897.png" alt="image-20220228182130897"></p>
<p>简单工厂模式？</p>
<p>为啥工厂类要使用静态方法？</p>
<p>唯一性智能指针，的自己编写的删除器是什么原理？</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220325114554266.png" alt="image-20220325114554266"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220325114610750.png" alt="image-20220325114610750"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%90%AC%E8%AF%BE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="cllwc4xii000zjsmo3a1d3tnk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>