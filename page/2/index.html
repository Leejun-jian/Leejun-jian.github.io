<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-腾讯云面试凉经" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%85%BE%E8%AE%AF%E4%BA%91%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.348Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="腾讯云面试凉经"><a href="#腾讯云面试凉经" class="headerlink" title="腾讯云面试凉经"></a>腾讯云面试凉经</h3><h5 id="主要还是根据简历来问的"><a href="#主要还是根据简历来问的" class="headerlink" title="主要还是根据简历来问的"></a>主要还是根据简历来问的</h5><p>1.首先进行自我介绍</p>
<p>2.Linux内存管理的方式，进程之间是如何实现隔离的</p>
<p>3.TCP连接的整个过程是如何进行的</p>
<h4 id="4-如果不调用accept，可以进行三次挥手吗？"><a href="#4-如果不调用accept，可以进行三次挥手吗？" class="headerlink" title="4.如果不调用accept，可以进行三次挥手吗？"></a>4.如果不调用accept，可以进行三次挥手吗？</h4><p>三次握手是发生在accept之前的，不调用accept也会发生三次握手，accept是用来处理已经完成三次握手的请求的。三次握手应该发生在listen和accept之间的。</p>
<p>服务器端只有在完成监听之后，客户端才有进行connect的条件，否则connect会被阻塞。</p>
<h4 id="5-如果不调用close，可以进行四次挥手吗？"><a href="#5-如果不调用close，可以进行四次挥手吗？" class="headerlink" title="5.如果不调用close，可以进行四次挥手吗？"></a>5.如果不调用close，可以进行四次挥手吗？</h4><p>如果进程没有结束，不调用close（）是不能进行四次挥手的。调用close失败的原因是本身描述符就是无效的，或者信号中断。不管怎样我们都不能 在close之后进行数据的收发，如果失败，消息的收发也是要看情况的，如果close（）发起时间很短还没来得及发送FIN是可以进行通信的，其他情况也有可能不能通信。</p>
<h4 id="6-项目当中fork-和epoll具体是怎么实现的？"><a href="#6-项目当中fork-和epoll具体是怎么实现的？" class="headerlink" title="6.项目当中fork()和epoll具体是怎么实现的？"></a>6.项目当中fork()和epoll具体是怎么实现的？</h4><p>编程题：</p>
<p>单链表的逆置</p>
<p>需要了解到方面：</p>
<p>Linux系统还需要深入了解一下</p>
<p>APRU</p>
<p>listen当中的监听队列的大小实际上是已处理请求和未处理请求等两个队列之和的大小。在不同的平台下标准是不一样的，Unix是两个队列之和不超过，linux是已完成三次握手队列的大小不超过，Windows暂时未知！！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%85%BE%E8%AE%AF%E4%BA%91%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/" data-id="cllwbvsb8001md4mo5wfkegk8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法修真篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%AE%97%E6%B3%95%E4%BF%AE%E7%9C%9F%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.342Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="内功心法-一-————-分治策略"><a href="#内功心法-一-————-分治策略" class="headerlink" title="内功心法 一  ————-  分治策略"></a>内功心法 一  ————-  分治策略</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%AE%97%E6%B3%95%E4%BF%AE%E7%9C%9F%E7%AF%87/" data-id="cllwbvsat001fd4moa1226oky" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-守护进程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.335Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="守护进程的编程流程"><a href="#守护进程的编程流程" class="headerlink" title="守护进程的编程流程:"></a>守护进程的编程流程:</h4><p>​					<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220228113200534.png" alt="image-20220228113200534"></p>
<h5 id="守护进程的特点：运行时间长，不需要和用户交互，在后台执行。"><a href="#守护进程的特点：运行时间长，不需要和用户交互，在后台执行。" class="headerlink" title="守护进程的特点：运行时间长，不需要和用户交互，在后台执行。"></a>守护进程的特点：运行时间长，不需要和用户交互，在后台执行。</h5><h4 id="守护进程的相关概念"><a href="#守护进程的相关概念" class="headerlink" title="守护进程的相关概念"></a>守护进程的相关概念</h4><h5 id="会话：在系统中每打开一个-终端-就会打开一个会话"><a href="#会话：在系统中每打开一个-终端-就会打开一个会话" class="headerlink" title="会话：在系统中每打开一个 终端 就会打开一个会话"></a>会话：在系统中每打开一个 终端 就会打开一个会话</h5><h5 id="会话首进程：-打开会话的第一个进程被称为会话首进程的pid"><a href="#会话首进程：-打开会话的第一个进程被称为会话首进程的pid" class="headerlink" title="会话首进程：   打开会话的第一个进程被称为会话首进程的pid"></a>会话首进程：   打开会话的第一个进程被称为会话首进程的pid</h5><h5 id="进程组："><a href="#进程组：" class="headerlink" title="进程组："></a>进程组：</h5><h5 id="进程组长："><a href="#进程组长：" class="headerlink" title="进程组长："></a>进程组长：</h5><h4 id="守护进程的编程示例"><a href="#守护进程的编程示例" class="headerlink" title="守护进程的编程示例"></a>守护进程的编程示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setsid();<span class="comment">//设置新会话</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);<span class="comment">//更改工作路径，到根路目录下</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FILE* fp=fopen(<span class="string">&quot;文件路径&quot;</span>，<span class="string">&quot;打开方式&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">time_t</span> tv;</span><br><span class="line">		time(&amp;tv);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;time is %s&quot;</span>,asctime(localtime(&amp;tv)));</span><br><span class="line">        fclose(fp);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" data-id="cllwbvs9w0012d4moc5mk9hwt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用两个栈实现一个队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.327Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="使用两个栈实现一个队列"><a href="#使用两个栈实现一个队列" class="headerlink" title="使用两个栈实现一个队列"></a>使用两个栈实现一个队列</h3><p>栈的特点：后进先出</p>
<p>队列的特点：先进先出</p>
<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720153802785.png" alt="image-20220720153802785" style="zoom:25%;" />

<p>那么如何用两个栈实现一个队列呢？</p>
<p>我们可以将两个栈进行拼接，一个当做队头，一个当做队伍，例如下面的例子：</p>
<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720154158020.png" alt="image-20220720154158020" style="zoom:50%;" />

<p>由上图我们可以看到，stack1中入栈的顺序是4,3,2,1。其中  4  是先入栈的，我们要想使得这两个栈完成队列的功能，那么就需要让 4 先出栈，显然如果我们只有一个栈是不可能完成这个目的的</p>
<p>但是我们还有另外一个空栈可以使用，我们可以将stack1中的数据先出栈在将出栈的数据同时入到stack2中，这样再从stack2 中依次出栈就可以达到队列的效果了。</p>
<p>从上面的分析我们可以得出，两个栈实现一个队列需要注意的点：</p>
<ol>
<li>push时：如果stack1 满了就先将stack1中的数据转移到stack2中，再向stack1中插入数据。如果两个栈都满了，说明队列满，无法插入。</li>
<li>pop时：出队列时，我们要优先查看stack2中有没有数据，有数据的话先出stack2中的数据。在stack2中没有数据的情况下，我们要将stack1中的所有数据全部转移到stack2中之后，再从stack2中pop数据。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">            stack2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">            stack2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p>我们要实现一个栈的类，除了要实现插入、删除和取得栈顶元素之外，还要完成获取栈中最小值的功能，并使得min函数的时间复杂度为O(1)。</p>
<p>这里想到了用<code>时间换空间</code>的做法，声明两个栈的数据结构，一个栈用来存储数据，一个栈用来当前数据下的最小值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    private:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; s;<span class="comment">//存储数据</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; s_min;<span class="comment">//存储最小值</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        s.push(value);<span class="comment">//数据肯定是要入到栈中</span></span><br><span class="line">        <span class="keyword">if</span>(s_min.empty()||s_min.top() &gt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            s_min.push(value);<span class="comment">//如果新入栈的数据大于小于最小值，就将value入到最小值栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s_min.push(s_min.top());<span class="comment">//如果新入栈的数据大于最小值，就重复入最小值栈中的栈顶元素到最小值栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        s.pop();</span><br><span class="line">        s_min.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="不同路径的数目问题："><a href="#不同路径的数目问题：" class="headerlink" title="不同路径的数目问题："></a>不同路径的数目问题：</h3><p>题目：  一个机器人在m×n大小的地图的左上角（起点）。   机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。  可以有多少种不同的路径从起点走到终点？ <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720164043393.png" alt="image-20220720164043393"></p>
<p>经过分析我们可以看出，机器人想要到达某一点，其能走的路径只有左边和上边。每一个点都是这样。我觉得我可以使用递归的方法求出路径的总和</p>
<p>例如当我们只有2X2个方格时，就只有两种走法<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720164515210.png" alt="image-20220720164515210"></p>
<p>因为机器人每到一个格子的时候必然要经过其左边和右边的格子，所以到达每个格子的路径条数等于左边格子和右边格子路径条数的总和。</p>
<p>K[m,n]&#x3D;K[m-1,n]+K[m,n-1];</p>
<p>如果m&#x3D;&#x3D;1或者n &#x3D;&#x3D; 1时，其路径只有一条。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> uniquePaths(m<span class="number">-1</span>, n)+uniquePaths(m, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>任何一道题能使用递归的方法，肯定也可以使用循环的方式再写一遍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> [][]res = new <span class="type">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j]+res[j][i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" data-id="cllwbvs8w000nd4mo1z6a3c5p" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-十大排序算法的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.318Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">TOC</a></p>
<h2 id="下面的算法可能要用到的简单函数"><a href="#下面的算法可能要用到的简单函数" class="headerlink" title="下面的算法可能要用到的简单函数"></a>下面的算法可能要用到的简单函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Type int</span></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>&amp;a,<span class="type">int</span>&amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Input</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Output</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1、冒泡排序（必会）"><a href="#1、冒泡排序（必会）" class="headerlink" title="1、冒泡排序（必会）"></a>1、冒泡排序（必会）</h2><p>冒泡排序就是把小的元素往前调或者把大的元素往后调，比较是相邻的两个元素比较，交换也发生在这两个元素之间。<br>如果两个相邻的元素是相等的，就不需要将其在交换位置，如果相等的两个元素不相邻，通过交换之后两个元素相邻之后，其相对位置也不会改变，所以冒泡排序是一种稳定的排序算法。</p>
<h4 id="基本冒泡排序："><a href="#基本冒泡排序：" class="headerlink" title="基本冒泡排序："></a><strong>基本冒泡排序：</strong></h4><p>每次循环比较一轮，找到当前循环的最大值，将其放到最后；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubblueSort</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="comment">//因为最后一个元素不用进行排序，所以只需要进行n-2此排序就可以完成所有的排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">    		 <span class="comment">//每次循环都从首位开始比较，将这次排序中的最大值放到后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(br + j) &gt; *(br + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Swap_Int(&amp;br[j], &amp;br[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在整个排序的过程中，本来的数组已经是有序的，没有发生交换，那么就可以直接跳出循环了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubblueSort</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="type">bool</span> flag = flase;</span><br><span class="line">    <span class="comment">//因为最后一个元素不用进行排序，所以只需要进行n-2此排序就可以完成所有的排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">    		 <span class="comment">//每次循环都从首位开始比较，将这次排序中的最大值放到后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(br + j) &gt; *(br + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                Swap_Int(&amp;br[j], &amp;br[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用两个for循环将函数排序：<br>内循环是为了找出此次循环中的最大或者最小值，将其放到末尾，然后依次寻找次小值等，直到循环到最后一次。例如：<br>将原数组     Ar[]&#x3D;{12 ,35 ,43 ,56 ,32, 52,15,8}<br>按照从小到大的顺序进行排列<br><img src="https://img-blog.csdnimg.cn/df4ae0a06f654941abebee7a67fa2037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X5rex6KeB6bm_X3lq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>总之就是外循环进行一次就进行一次比较，有n个数就循环n-1次。第一层循环是为了计数，第二层循环负责比较。</p>
<h4 id="改进之后的冒泡排序："><a href="#改进之后的冒泡排序：" class="headerlink" title="改进之后的冒泡排序："></a><strong>改进之后的冒泡排序：</strong></h4><p>每一次循环比较两次，先从上往下比较找到最大的，再从下往上比较找到最小的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> BubbleSort（<span class="type">int</span> *ar，<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(ar != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>,k=n-j<span class="number">-1</span>; j &lt; n - i &amp;&amp;  k &gt; <span class="number">0</span>  &amp;&amp;  k&gt;=j ; ++j,--k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(ar + j) &gt; *(ar + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(ar[j], ar[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ar[k]&lt;ar[k<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="built_in">Swap</span>(ar[k],ar[k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>原理：</strong>二分查找的前提是有序数组，通过比较中位数和目标数据的大小，来定位下次寻找的区间。</p>
<p>给定一个有序数组nums，在数组中寻找目标值target，如果找到了返回目标值的下标，如果没找到目标值返回-1；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binaryLookUp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (right - left)/<span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eles</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环移动数组"><a href="#循环移动数组" class="headerlink" title="循环移动数组"></a>循环移动数组</h2><p>循环移动数组；<br>示例：<br>int ar[10]&#x3D;{1, 2 , 3 , 4 , 5 , 6 ，7 , 8 , 9 , 10};右移一个数据元素：<br>输出{ 10,1,2,3,4,5,6,7,8,9};<br>右移k个数据元素：<br>如k &#x3D; 3;输出{8，9，10，1，2，3，4，5，6，7}；<br>实现函数: Right_Move_Array;        &#x2F;&#x2F;   右移一个数据元素Right_Move_Array_K;    &#x2F;&#x2F;   右移k 个数据元素Left_Move_Array;<br> Left_Move_Array_K<br>循环移动可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap_Int</span><span class="params">(<span class="type">int</span>* ap, <span class="type">int</span>* bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ap != nullptr&amp;&amp;bp!=nullptr);</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = *ap;</span><br><span class="line">    *bp = *ap;</span><br><span class="line">    *ap = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//让br[]数组的所有元素依次向左移动一位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Left_Move_Array</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(br != nullptr);<span class="comment">//断言很重要，在程序运行的时候如果出现错误可以及时停止程序，减少时间的浪费</span></span><br><span class="line">    <span class="type">int</span> tmp = br[<span class="number">0</span>];</span><br><span class="line">    br[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        br[i<span class="number">-1</span>]=br[i];<span class="comment">//将第一个数取出之后，后面的数字依次向前挪一个位置然后让第一个数赋给最后一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    br[n - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">right_Array_move</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="type">int</span> tmp = br[n<span class="number">-1</span>];</span><br><span class="line">    br[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        br[i] = br[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    br[<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">left_move_array_k</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    k = k % n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Left_Move_Array(br, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*int tmp = br[n - k - 1];</span></span><br><span class="line"><span class="comment">    br[n - 1 - k] = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n - 1; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        br[i] = br[(i + k)%n];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    br[n - 1 - k] = tmp;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">right_move_array_k</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    left_move_array_k(br, n, -k);</span><br><span class="line">    <span class="comment">/*k = k % n;</span></span><br><span class="line"><span class="comment">    while (k--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        right_Array_move(br, n);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-直接插入排序"><a href="#2-直接插入排序" class="headerlink" title="2. 直接插入排序"></a>2. 直接插入排序</h2><p><strong>原理：</strong>插入排序是在一个已经有序的小序列的基础上，一次插入一个一个元素。</p>
<p>最开始的时候这个有序的小序列只有一个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是<strong>想要插入的元素和已经有序的元素的最大值开始比较，如果比他大就直接插入在其后面，否则一直往前找知道找到他该插入的位置。</strong></p>
<p>如果碰到一个和准备插入元素相等的数据，那么把准备插入元素插入在其后面。所以插入排序不会改变相等元素的相对位置，所以插入排序是稳定的。</p>
<ul>
<li><p>例题：使用插入排序将一个含有n个元素的数据，按照升序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> tmp = nums[i];</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j+<span class="number">1</span>] = tmp;<span class="comment">//将tmp放到合适的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h2><p>希尔排序就是加强版的插入排序。无论是冒泡排序还是希尔排序，如果最大值刚好在第一位，要将他挪到正确的位置就需要n-1挪动。也就是说，原数组的一个元素如果距离他正确位置太远的话，则需要与相邻元素交换很多次才能到大正确的位置，这样相对来说比较耗费时间。</p>
<p><strong>希尔排序的思想：</strong>先让数组中任意间隔为h的元素有序，刚开始h的大小可以是h&#x3D;n&#x2F;2，接着h&#x3D;n&#x2F;4，让h一直缩小，当h&#x3D; 1时，也就是此时数组中任意间隔为1的元素有序，此时数组就是有序的了。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</li>
<li>当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> gap = n/<span class="number">2</span>;<span class="comment">//分组大小</span></span><br><span class="line">	<span class="comment">//每次循环使用插入排序的方式，将小分组里面的数据有序</span></span><br><span class="line">	<span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i - gap;</span><br><span class="line">			<span class="type">int</span> tmp = nums[i];<span class="comment">//将插入值提前保存下来，以免被覆盖</span></span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[i]; j -= gap)</span><br><span class="line">			&#123;</span><br><span class="line">				nums[j + gap] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j + gap] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> a : nums)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质上希尔排序就是，在插入排序之前先进性预排序，是的序列基本有序之后，在进行一次插入排序就达到效果。</p>
<p>其核心代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = i - gap;</span><br><span class="line">    <span class="comment">//将插入值提前保存下来，以免被覆盖</span></span><br><span class="line">    <span class="type">int</span> tmp = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[i]; j -= gap)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是将插入排序的步长<strong>从1改为了gap</strong></p>
<h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h2><p>选择排序就是每次选出待排序队列中的中的最小值，然后将其放到已排序队列的最后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="type">int</span> min = j;</span><br><span class="line">        <span class="keyword">for</span>(;j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            min = nums[j] &lt; nums[min] ? j : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;nums[i],&amp;nums[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每个数都要循环比较n次，所以时间复杂度是指数级别的。</p>
<h2 id="5-归并排序（必会）"><a href="#5-归并排序（必会）" class="headerlink" title="5. 归并排序（必会）"></a>5. 归并排序（必会）</h2><p><strong>思想：</strong>将一个大的无序数组有序，可以将这个大的数组分成两个，然后对这两个数组分别进行排序，之后再把这两个数组合并成一个有序数组。由于两个数组都是有序的，所以合并是很快的。</p>
<p>通过递归的方式，直到数组的大小为1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小合并为一个大小为2的，在依次合并直到整个数组都有序。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法采用的是分治法，</p>
<p><strong>步骤：</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergearray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> first,<span class="type">int</span> mid,<span class="type">int</span> last,<span class="type">int</span> temp[])</span>	<span class="comment">//将两个有序数组合并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=first,j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m=mid,n=last;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">			temp[k++]=a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">		temp[k++]=a[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">		temp[k++]=a[j++];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">		a[first+i]=temp[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> first,<span class="type">int</span> last,<span class="type">int</span> temp[])</span>	<span class="comment">//将两个任意数组合并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(first&lt;last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid=(first+last)/<span class="number">2</span>+first;</span><br><span class="line">		<span class="built_in">mergesort</span>(a,first,mid,temp);	<span class="comment">//左边有序 </span></span><br><span class="line">		<span class="built_in">mergesort</span>(a,mid+<span class="number">1</span>,last,temp);	<span class="comment">//右边有序 </span></span><br><span class="line">		<span class="built_in">mergearray</span>(a,first,mid,last,temp);	<span class="comment">//再将两个有序数组合并 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">//分配一个有n个int型元素的数组所占空间，并将该数组的第一个元素的地址赋给int *型指针p。</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="built_in">mergesort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, p);  </span><br><span class="line">    <span class="keyword">delete</span>[] p;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者另一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortCore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; copy, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line">    <span class="comment">//这里减少了copy向nums的赋值部分，千万注意不要把copy 和 nums赋值反了</span></span><br><span class="line">	<span class="built_in">mergeSortCore</span>(copy, nums, low1, high1);</span><br><span class="line">	<span class="built_in">mergeSortCore</span>(copy, nums, low2, high2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> copyIndex = low1;</span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low1] &lt; nums[low2] ? nums[low1++] : nums[low2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (low2 &lt;= high2) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low2++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; begin &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">copyNums</span><span class="params">(nums)</span></span>;<span class="comment">//这里要借助一个一模一样的数组的</span></span><br><span class="line">	<span class="built_in">mergeSortCore</span>(nums, copyNums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	nums.<span class="built_in">assign</span>(copyNums.<span class="built_in">begin</span>(), copyNums.<span class="built_in">end</span>());<span class="comment">//到最后copy数组是排序好的，记得要赋值一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序注重的是分治思想，先将大数组分成一个个的小数组，在从小到大依次合并，合并两个有序数组的时间复杂度可以降低到O(n)，分解的时间复杂度为log（n),那么最终的时间复杂度应该为，O(n*logn)。</p>
<h2 id="6-快速排序（必会）"><a href="#6-快速排序（必会）" class="headerlink" title="6. 快速排序（必会）"></a>6. 快速排序（必会）</h2><p>快速排序也是考察率较高的一种排序算法，主要操作步骤是每次选取一个划分元，将比这个划分元大的数都放到其右边，比划分元小的数都放到其左边，直到划分区间变为一停止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是依靠划分函数来进行排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp = nums[start];<span class="comment">//选取划分元</span></span><br><span class="line">    <span class="type">int</span> left = start , right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; nums[right] &lt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; nums[left] &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">Partation</span>(nums,start,end);</span><br><span class="line">        <span class="built_in">quickSortFun</span>(nums,start,mid);</span><br><span class="line">        <span class="built_in">quickSortFun</span>(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="built_in">quickSortFun</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当快速排序遇到极特殊情况时，如有序数组，那么快速排序的时间复杂度将快速增大，最终退化成冒泡排序时间复杂度为O(n^2)，那么应该如何改进才能使得快速排序在任何情况下的时间复杂度都为 O(nlog(n)) 呢?</p>
<p>关键点在于划分元的选择上，详细描述在我的另一篇文章中有所描述：</p>
<p><a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=118046392">快排</a></p>
<p>非递归版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单趟排</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key = arr[begin];</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (key &lt;= arr[end] &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			--end;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[begin] = arr[end];</span><br><span class="line">		<span class="keyword">while</span> (key &gt;= arr[begin] &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			++begin;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end] = arr[begin];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[begin] = key;</span><br><span class="line">	<span class="type">int</span> meeti = begin;</span><br><span class="line">	<span class="keyword">return</span> meeti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSortNoR</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="comment">//先入右边</span></span><br><span class="line">	st.push(end);</span><br><span class="line">	<span class="comment">//再入左边</span></span><br><span class="line">	st.push(begin);</span><br><span class="line">	<span class="keyword">while</span> (!st.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//左区间</span></span><br><span class="line">		<span class="type">int</span> left = st.top();</span><br><span class="line">		st.pop();</span><br><span class="line">		<span class="comment">//右区间</span></span><br><span class="line">		<span class="type">int</span> right = st.top();</span><br><span class="line">		st.pop();</span><br><span class="line">		<span class="comment">//中间数</span></span><br><span class="line">		<span class="type">int</span> mid = PartSort(arr, left, right);</span><br><span class="line">		<span class="comment">//当左区间&gt;=mid-1则证明左区间已经排好序了</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; mid - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.push(mid - <span class="number">1</span>);</span><br><span class="line">			st.push(left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当mid+1&gt;=右区间则证明右区间已经排好序</span></span><br><span class="line">		<span class="keyword">if</span> (right &gt; mid + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.push(right);</span><br><span class="line">			st.push(mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><p>利用堆这种数据结构完成的排序算法,，堆排序算法是一种选择排序算法，他的最好，最坏时间复杂度都是O(nlogn)，是不稳定的排序算法。</p>
<p>对于堆排序难点在于，二叉树的顺序数组储存到大顶堆（小顶堆）的转换。从数据存储来看，数组存储方式和树的存储方式可以相互转换，既数组可以转换成树，树也可以转换成数组。</p>
<p>堆是具有以下特点的完全二叉树：每个节点都大于会等于其左右孩子节点的值，称为大顶堆；每个节点的值都小于或等于左右孩子的值，称为小顶堆。</p>
<p><strong>代码实现思路：</strong></p>
<ol>
<li><p><strong>构造初始堆</strong>：将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）。</p>
<ul>
<li><p>构建初始堆时，要注意，完全二叉树的第一个非叶子节点的下标是n&#x2F;2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大顶堆实现无序数组的升序排列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//此循环为构建初始堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>;i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断有没有越界</span></span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span> &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较知道根节点左右子树中的较大值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;nums[i],&amp;nums[j]);</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将数组的最大值也就是大顶堆的顶点，放到数组的最后面</span></span><br><span class="line">        <span class="built_in">Swap</span>(&amp;nums[i],&amp;nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//对剩下的n-1个值继续构建大顶堆,寻找次大值，依次循环，直到所有的数据排序完成</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">2</span>*k+<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;nums[k],&amp;nums[j]);</span><br><span class="line">                <span class="comment">//因为发生了交换，不知道有没有影响到子树成堆，所以需要继续比较</span></span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//构建初始堆，和大顶堆正好相反</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>((j + <span class="number">1</span>) &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swap</span>(nums[i], nums[j]);</span><br><span class="line">				i = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将最小值挪到最后</span></span><br><span class="line">		<span class="built_in">Swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">2</span> * k + <span class="number">1</span>) &lt; i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> ((j + <span class="number">1</span>) &lt; i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nums[k] &gt; nums[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swap</span>(nums[k], nums[j]);</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h4><p>堆是一种常用的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">树形结构</a>，是一种特殊的<strong>完全二叉树</strong>，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。</p>
<h4 id="堆的特性："><a href="#堆的特性：" class="headerlink" title="堆的特性："></a>堆的特性：</h4><p>• 堆中某个节点的值总是不大于或不小于其父节点的值</p>
<p>• 堆总是一棵<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">完全二叉树</a></p>
<h4 id="大顶堆和小顶堆"><a href="#大顶堆和小顶堆" class="headerlink" title="大顶堆和小顶堆"></a>大顶堆和小顶堆</h4><p>大顶堆：所有的父节点大于等于孩子节点</p>
<p>小顶堆：所有的父节点小于等于孩子节点</p>
<h4 id="堆排序的基本步骤"><a href="#堆排序的基本步骤" class="headerlink" title="堆排序的基本步骤"></a>堆排序的基本步骤</h4><ol>
<li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p>
</li>
<li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</p>
</li>
<li><p>将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</p>
</li>
</ol>
<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020">计数排序</a>是一个非基于比较的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。</p>
<p>它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当 <img src="https://private.codecogs.com/gif.latex?O(k)%3EO(nlogn)" alt="O(k)&gt;O(nlogn)"> 的时候其效率反而不如基于比较的排序，因为基于比较的排序的时间复杂度在理论上的下限是 <img src="https://private.codecogs.com/gif.latex?O(nlogn)" alt="O(nlogn)">。</p>
<h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h4><p>计数排序对输入的数据有附加的限制条件：</p>
<ol>
<li>输入的线性表的元素属于有限偏序集 S；</li>
<li>设输入的线性表的长度为 n，|S|&#x3D;k（表示集合 S 中元素的总数目为 k），则 k&#x3D;O(n)。</li>
</ol>
<p>在这两个条件下，计数排序的复杂性为O(n)。</p>
<p>​		计数排序的<strong>基本思想</strong>是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。<strong>当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</strong></p>
<h4 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a><strong>算法过程：</strong></h4><ol>
<li>根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；</li>
<li>遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；</li>
<li>对额外空间内数据进行计算，得出每一个元素的正确位置；</li>
<li>将待排序集合每一个元素移动到计算得出的正确位置上。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> max = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//遍历数组找到最大值和最小值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		max = nums[i] &gt; max ? nums[i] : max;</span><br><span class="line">		<span class="comment">//min = nums[i] &lt; min ? nums[i] : min;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个额外数组，用来计数</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(max+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp[nums[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; (max + <span class="number">1</span>); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (tmp[i]--)</span><br><span class="line">		&#123;</span><br><span class="line">			nums[j++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="但是："><a href="#但是：" class="headerlink" title="但是："></a>但是：</h4><p>虽然计数排序看上去很强大，但是它存在两大局限性：</p>
<ol>
<li>当数列最大最小值差距过大时，并不适用于计数排序</li>
</ol>
<p>​        比如给定 20 个随机整数，范围在 0 到 1 亿之间，此时如果使用计数排序的话，就需要创建长度为 1 亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。</p>
<ol start="2">
<li>当数列元素不是整数时，并不适用于计数排序</li>
</ol>
<p>​        如果数列中的元素都是小数，比如 3.1415，或是 0.00000001 这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。</p>
<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h2><p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>这里值得我们注意的是，桶的数量要取到一个适中值是比较困难的，通的数量过多或者过少都会导致桶排序退化，过多回退化成计数排序，太少回退化成比较排序。但是有没有一个特定的公式来确定桶的数量.所以我们还是只能自己确定桶的数量.但是有一个规则我们还是可以考虑进去的,那就是<code>最好让元素平均的分散到每一个桶里</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>1）算法描述</p>
<p>取得数组中的最大数，并取得位数</p>
<p>arr为原始数组，从最低位开始取每个位组成radix数组</p>
<p>对radix进行计数排序（利用计数排序适用于小范围数的特点）</p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>排序算法没有优劣，在适当的情况下使用相应的方法</em></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025225548181.png" alt="image-20221025225548181"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cllwbvs9j000wd4moej0v180k" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-生产者消费者" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.308Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><strong>生产者&#x2F;消费者问题，也被称作有限缓冲问题。可以描述为：两个或者更多的线程共享同一个缓冲 区，其中一个或多个线程作为“生产者”会不断地向缓冲区中添加数据，另一个或者多个线程作为“消费者” 从缓冲区中取走数据。生产者&#x2F;消费者模型关注的是以下几点：</strong></p>
<p>生产者和消费者必须互斥的使用缓冲区 缓冲区空时</p>
<p>消费者不能读取数据 缓冲区满时，</p>
<p>生产者不能添加数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" data-id="cllwbvsak001bd4mo7r0b67ds" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设置环境变量的几种便捷方式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BE%BF%E6%8D%B7%E6%96%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.300Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="设置环境变量的几种便捷方式"><a href="#设置环境变量的几种便捷方式" class="headerlink" title="设置环境变量的几种便捷方式"></a>设置环境变量的几种便捷方式</h2><h3 id="直接在命令行中操作"><a href="#直接在命令行中操作" class="headerlink" title="直接在命令行中操作"></a>直接在命令行中操作</h3><p>Unix&#x2F;Linux系统中：</p>
<ul>
<li><p>在 csh shell:</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</span><br></pre></td></tr></table></figure>

<p>, 按下Enter。</p>
</li>
<li><p>在 bash shell (Linux) 输入 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/usr/local/bin/python&quot; </span><br></pre></td></tr></table></figure>

<p>按下Enter</p>
</li>
<li><p>在 sh 或者 ksh shell 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=&quot;$PATH:/usr/local/bin/python&quot; </span><br></pre></td></tr></table></figure>

<p>按下 Enter。</p>
</li>
</ul>
<p>注意：**&#x2F;usr&#x2F;local&#x2F;bin&#x2F;Python是python的安装目录**</p>
<h3 id="Windows中进行设置环境变量（通过命令行）"><a href="#Windows中进行设置环境变量（通过命令行）" class="headerlink" title="Windows中进行设置环境变量（通过命令行）"></a>Windows中进行设置环境变量（通过命令行）</h3><p>环境变量中添加Python目录：</p>
<p><strong>在命令提示框中(cmd) :</strong> 输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=%path%;C:\Python </span><br></pre></td></tr></table></figure>

<p>按下”Enter”。</p>
<p><strong>注意:</strong> C:\Python 是Python的安装目录。</p>
<p>通过其他方式设置环境变量的就不赘述了，简单都会。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BE%BF%E6%8D%B7%E6%96%B9%E5%BC%8F/" data-id="cllwbvsba001nd4moa0hs7c71" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式之简单工厂模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.291Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>考虑各种问题将下面的代码进行完善：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> String&amp; operator+=(<span class="type">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pstr != <span class="literal">NULL</span> &amp; s.pstr != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果我们当前的字符串的引用大于1，我们就需要将我们要操作的字符串单掕出来，然后再进行操作 </span></span><br><span class="line">			<span class="keyword">if</span> (pstr-&gt;ref &gt; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> total = pstr-&gt;len + s.pstr-&gt;len;</span><br><span class="line">				this-&gt;pstr-&gt;ref--;</span><br><span class="line">				<span class="type">char</span>* tmp = pstr-&gt;data;</span><br><span class="line">				this-&gt;pstr = (StrNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StrNode) + <span class="number">2</span> * total + <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">strcpy</span>(this-&gt;pstr-&gt;data, tmp);</span><br><span class="line">				<span class="built_in">strcat</span>(this-&gt;pstr-&gt;data, s.pstr-&gt;data);</span><br><span class="line">				this-&gt;pstr-&gt;len = total;</span><br><span class="line">				this-&gt;pstr-&gt;ref = <span class="number">1</span>;</span><br><span class="line">				this-&gt;pstr-&gt;size = total * <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> total = pstr-&gt;len + s.pstr-&gt;len;</span><br><span class="line">				<span class="keyword">if</span> (this-&gt;pstr-&gt;size &lt; total)</span><br><span class="line">				&#123;</span><br><span class="line">					this-&gt;pstr = (StrNode*)<span class="built_in">realloc</span>(this-&gt;pstr, <span class="keyword">sizeof</span>(StrNode) + <span class="number">2</span> * total + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">strcat</span>(this-&gt;pstr-&gt;data, s.pstr-&gt;data);</span><br><span class="line">				this-&gt;pstr-&gt;len = total;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pstr == <span class="literal">NULL</span> &amp;&amp; s.pstr != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;pstr = s.pstr;</span><br><span class="line">			this-&gt;pstr-&gt;ref++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *this;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<p>写一个模板栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    T* base;</span><br><span class="line">    T* pos;</span><br><span class="line">    <span class="type">int</span> maxsize;</span><br><span class="line">public:</span><br><span class="line">    SeqStack(<span class="type">int</span> sz = SEQ_INIT_SIZE) :maxsize(sz &gt; SEQ_INIT_SIZE ? sz : SEQ_INIT_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        base = pos = (<span class="type">int</span>;)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * maxsize);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == base) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现函数有：</span></span><br><span class="line">    ~SeqStack; <span class="comment">// 析构函数</span></span><br><span class="line">    Get_Size; <span class="comment">// 返回数据的个数</span></span><br><span class="line">    Get_Capacity; <span class="comment">// 返回容量</span></span><br><span class="line">    Is_Empty; <span class="comment">// 判空</span></span><br><span class="line">    Is_Full; <span class="comment">// 判满</span></span><br><span class="line">    Push;   <span class="comment">// 入栈</span></span><br><span class="line">    Pop;   <span class="comment">// 出栈</span></span><br><span class="line">    Top;   <span class="comment">// 取栈顶数据 ，但不出栈   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="cllwbvsbe001od4mo0gq07ywk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-软件需求工程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.282Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><h3 id="一、软件需求工程的重要性"><a href="#一、软件需求工程的重要性" class="headerlink" title="一、软件需求工程的重要性"></a>一、软件需求工程的重要性</h3><h4 id="1、软件需求的分类"><a href="#1、软件需求的分类" class="headerlink" title="1、软件需求的分类"></a>1、软件需求的分类</h4><p>目标需求</p>
<p>业务需求</p>
<p>功能需求</p>
<p>性能需求</p>
<p>约束与限制</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220103111840751.png" alt="image-20220103111840751"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/" data-id="cllwbvsbg001pd4modjzi5ggf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-入侵检测和防火墙有何不同，各有什么优缺点？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.271Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>入侵检测和防火墙有何不同，各有什么优缺点？</p>
<p>答： </p>
<ol>
<li>防火墙的优点：他能增强机构内部网络的安全性，用于加强网络间的访问控制，<strong>防止外部用户非法使用内部网络资源，保护内部网络设备不被破坏，防止内部网络的敏感数据被窃取。</strong> 防火墙决定了那些内部服务可以被外界访问，外界的那些人可以访问内部的那些服务，以及那些外部服务可以被内部人员访问。</li>
<li>防火墙的缺点：对于发生在内网的攻击无能为力；对于部分攻击，可以绕过防火墙，防火墙发现不了；防火墙的策略是静态的，不能实施动态防御。</li>
<li>入侵检测的优势：入侵检测系统扫描当前网络的活动，见识和记录网络流量，根据定义好的规则来过滤从诸暨网卡到网线上的流量，提供实时报警。大多数的入侵检测系统都可以提供关于网络流量非常详尽的分析。他们可以见识任何定义好的流量。很多系统对FTP，HTTP和Telnet流量都有默认的设置，还有其他流量，如NetBus，本地和远程登陆失败，等等。也可以定制自己的策略。如果定义了策略和规则，便可以获得FTP、SMTP&#x2F;Telnet和任何去他的流量。这种规则有助于追查该链接和确定网络上发生过什么，以及现在正在发生什么、这些程序在需要确定的网络中策略实施的一致性情况时是非常有效的工具。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/" data-id="cllwbvs91000pd4mo3f5zfmsm" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>