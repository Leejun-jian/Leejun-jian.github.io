<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-简单工厂模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.135Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="cllwc4xj7001ejsmodb2eah3j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-继承和面向对象的设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.124Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>任务一：迭代器</p>
<p>任务二：类型存取</p>
<p>任务二：空间配置器</p>
<p>项目：内存池，线程池，进程池</p>
<p><strong>双端队列：</strong></p>
<p><strong>TCP&#x2F;IP详解 全部要看</strong></p>
<p>操作系统精髓与设计原理</p>
<p>C++要经常使用</p>
<p>智能指针</p>
<p>new的三种调度方式</p>
<p>1、关键字new</p>
<p>2、operator new，相当于函数new</p>
<p>3、构建new。</p>
<p>可以通过new对已经构建好的对象进行二次构建。</p>
<p>Int  a(10）；</p>
<p>new(&amp;a) Int(100);&#x2F;&#x2F;可以对a进行二次构建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Int *ip=New Int(<span class="number">10</span>);</span><br><span class="line">    Int *p=(Int*)operator new (<span class="keyword">sizeof</span>(Int));<span class="comment">//相当于malloc</span></span><br><span class="line">    new(p)Int(<span class="number">10</span>);<span class="comment">//构造new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stl_alloc.h&gt;</span>内存池</span></span><br></pre></td></tr></table></figure>





<h3 id="继承和面向对象的设计"><a href="#继承和面向对象的设计" class="headerlink" title="继承和面向对象的设计"></a>继承和面向对象的设计</h3><p><strong>子对象给父对象赋值，只会将父对象部分分付给。</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127201153925.png" alt="image-20211127201153925"></p>
<p>赋值兼容性规则</p>
<p>子对象可以赋值给父引用</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127203512653.png" alt="image-20211127203512653"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BB%A7%E6%89%BF%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1/" data-id="cllwc4xjg001jjsmog9go9l55" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-继承和多态" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.113Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><h4 id="什么叫做早期绑定？"><a href="#什么叫做早期绑定？" class="headerlink" title="什么叫做早期绑定？"></a>什么叫做早期绑定？</h4><p>无论任何继承关系，派生类对象的中的方法总能够去访问基类的除去私有成员之外的所有方法和成员。</p>
<p><strong>继承对象和具名对象之间的区别：</strong></p>
<p>​	（1）派生类可以访问继承来的基类的除私有成员之外的任何成员（不论是以什么样的方式继承）；</p>
<p>​	（2）但是只能访问具名对象的公有成员（这与其被定义为什么属性没有关系不管是私有，公有还是保护）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="type">int</span> ax;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="type">int</span> ay;</span><br><span class="line">    <span class="keyword">public</span>:<span class="type">int</span> az;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="type">int</span> bx;</span><br><span class="line">    		A aa;<span class="comment">//具名对象</span></span><br><span class="line">    <span class="keyword">protected</span>:<span class="type">int</span> by;</span><br><span class="line">    <span class="keyword">public</span>:<span class="type">int</span> bz;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B bb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>外部函数只能访问类的公有属性</strong></p>
<p>如果派生类的成员和基类的成员重名了，没有特殊情况的状态下，优先访问本类中的成员（就近原则）；如果出现派生类的成员和基类的成员重名了的情况，会进行同名隐藏，隐藏继承而来的成员或者方法。</p>
<p>类在编译时期，如果存在虚函数会自动生成一个虚指针指向他的虚表。</p>
<p>派生类继承基类之后，如果基类中存在虚函数那就在编译时就会自动产生虚表，当在派生类中进行虚函数的重写后，那么就会在派生类中替换掉重写后的函数，没有被重写的虚函数直接被继承下来了。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220212165040971.png" alt="image-20220212165040971"></p>
<h3 id="菱形继承："><a href="#菱形继承：" class="headerlink" title="菱形继承："></a>菱形继承：<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211116194443177.png" alt="image-20211116194443177"></h3><p>菱形继承引入的问题：造成公共父类在子对象中存在多个实例</p>
<p>菱形继承的解决：虚继承解决</p>
<p>虚继承的逻辑：被虚继承的类会变成虚基类，虚基类在子类对象中存放在vbtable 中，原本应该存储父类对象的位置上替换为vbptr,vbptr指向vbtable中虚基类实例的位置从而保证虚基类在子类中只会有一个实力存在</p>
<p>注意：虚基类在子类中会被当做直接父类进行构造。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211116194519231.png" alt="image-20211116194519231"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看类的构造</span></span><br><span class="line">cl(L) /dlreportSingleClassLayouD.\mian.cpp &gt; <span class="number">1.</span>txt</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> fun1</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;int fun1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚继承，A为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;int fun2()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//虚基类不管经过多少层继承，其子类在构造的时候都要将其当做直接父类进行构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>：<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;int fun3()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vbptr 虚基类指针</span></span><br></pre></td></tr></table></figure>

<p>菱形继承，最先将最基类对象构造出来，中间类中有一个虚指针分别存储他们到达父对象的偏移量</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220416115133306.png" alt="image-20220416115133306"></p>
<h3 id="抽象类：有纯虚函数的类叫做抽象类，抽象类不能够实例化对象。"><a href="#抽象类：有纯虚函数的类叫做抽象类，抽象类不能够实例化对象。" class="headerlink" title="抽象类：有纯虚函数的类叫做抽象类，抽象类不能够实例化对象。"></a>抽象类：有纯虚函数的类叫做抽象类，抽象类不能够实例化对象。</h3><h6 id="应用：要求限制子类必须覆盖某一个接口"><a href="#应用：要求限制子类必须覆盖某一个接口" class="headerlink" title="应用：要求限制子类必须覆盖某一个接口"></a>应用：要求限制子类必须覆盖某一个接口</h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" data-id="cllwc4xjf001ijsmod9pig1d3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-基操---mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%9F%BA%E6%93%8D---mysql/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.104Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="数据库是什么？数据库就是数据的集合，作用就是为了高效的管理数据，那么对于数据都有些什么操作呢？无非就是数据的增删改查呗，建库建表，删库跑路。一切的语法都是为了更加高效的完成增删改查而设计的。"><a href="#数据库是什么？数据库就是数据的集合，作用就是为了高效的管理数据，那么对于数据都有些什么操作呢？无非就是数据的增删改查呗，建库建表，删库跑路。一切的语法都是为了更加高效的完成增删改查而设计的。" class="headerlink" title="数据库是什么？数据库就是数据的集合，作用就是为了高效的管理数据，那么对于数据都有些什么操作呢？无非就是数据的增删改查呗，建库建表，删库跑路。一切的语法都是为了更加高效的完成增删改查而设计的。"></a>数据库是什么？数据库就是数据的集合，作用就是为了高效的管理数据，那么对于数据都有些什么操作呢？无非就是数据的增删改查呗，建库建表，删库跑路。一切的语法都是为了更加高效的完成增删改查而设计的。</h4><p>mysqladmin –version     ||     查看mysql版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service mysql status   #查看mysql的运行状态</span><br><span class="line">service mysql start   #运行mysql server</span><br><span class="line">service mysql stop  #停止运行</span><br><span class="line">service mysql restart  #重启</span><br></pre></td></tr></table></figure>

<h2 id="Windows下安装mysql"><a href="#Windows下安装mysql" class="headerlink" title="Windows下安装mysql"></a>Windows下安装mysql</h2><h4 id="windows下查看网络服务"><a href="#windows下查看网络服务" class="headerlink" title="windows下查看网络服务"></a>windows下查看网络服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.msc</span><br></pre></td></tr></table></figure>

<p>在orcle官网下直接下载压缩包，然后解压到当地文件夹下</p>
<p>在文件夹中添加一个my.ini的文件，文件内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line"><span class="keyword">default</span>-character-<span class="built_in">set</span>=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置<span class="number">3306</span>端口</span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=C:\\web\\mysql<span class="number">-8.0</span><span class="number">.11</span></span><br><span class="line"># 设置 mysql数据库的数据的存放目录，MySQL <span class="number">8</span>+ 不需要以下配置，系统自己生成即可，否则有可能报错</span><br><span class="line"><span class="meta"># datadir=C:\\web\\sqldata</span></span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=<span class="number">20</span></span><br><span class="line"># 服务端使用的字符集默认为<span class="number">8</span>比特编码的latin1字符集</span><br><span class="line">character-<span class="built_in">set</span>-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line"><span class="keyword">default</span>-storage-engine=INNODB</span><br></pre></td></tr></table></figure>

<p>使用管理员身份运行cmd</p>
<p>在文件的安装目录下执行如下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\mysql<span class="number">-5.7</span><span class="number">.12</span>-win32\bin&gt;mysqld --initialize --console</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">05.224423</span>Z <span class="number">0</span> [System] [MY<span class="number">-013169</span>] [Server] D:\mysql<span class="number">-5.7</span><span class="number">.12</span>-win32\bin\mysqld.exe (mysqld <span class="number">8.0</span><span class="number">.30</span>) initializing of server in progress as process <span class="number">12120</span></span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">05.268738</span>Z <span class="number">0</span> [ERROR] [MY<span class="number">-010340</span>] [Server] Error message file <span class="string">&#x27;D:\mysql-5.7.12-win32\share\english\errmsg.sys&#x27;</span> had only <span class="number">1073</span> error messages, but it should contain at least <span class="number">5683</span> error messages. Check that the above file is the right version <span class="keyword">for</span> this program!</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">05.298259</span>Z <span class="number">0</span> [Warning] [MY<span class="number">-013242</span>] [Server] --character-<span class="built_in">set</span>-server: <span class="string">&#x27;utf8&#x27;</span> is currently an alias <span class="keyword">for</span> the character <span class="built_in">set</span> UTF8MB3, but will be an alias <span class="keyword">for</span> UTF8MB4 in a <span class="built_in">future</span> release. Please consider using UTF8MB4 in order to be unambiguous.</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">05.475520</span>Z <span class="number">1</span> [System] [MY<span class="number">-013576</span>] [InnoDB] InnoDB initialization has started.</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">14.511103</span>Z <span class="number">1</span> [System] [MY<span class="number">-013577</span>] [InnoDB] InnoDB initialization has ended.</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">19.245247</span>Z <span class="number">0</span> [Warning] [MY<span class="number">-013829</span>] [Server] Missing data directory <span class="keyword">for</span> ICU regular expressions: D:\mysql<span class="number">-5.7</span><span class="number">.12</span>-win32\lib\private\.</span><br><span class="line"><span class="number">2022</span><span class="number">-09</span><span class="number">-26</span>T09:<span class="number">43</span>:<span class="number">20.615356</span>Z <span class="number">6</span> [Note] [MY<span class="number">-010454</span>] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: jwlVhd9eD7=R</span><br></pre></td></tr></table></figure>

<p><strong>jwlVhd9eD7</strong>&#x3D;就是mysql 的密码</p>
<p>执行mysqld install 安装数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\mysql-5.7.12-win32\bin&gt;mysqld install</span><br><span class="line">Service successfully installed.</span><br></pre></td></tr></table></figure>

<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><p>使用初始密码进入数据库之后执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;</span><br></pre></td></tr></table></figure>

<p>更改的新密码为“123456”</p>
<h5 id="更改密码之后还要配置环境变量"><a href="#更改密码之后还要配置环境变量" class="headerlink" title="更改密码之后还要配置环境变量"></a>更改密码之后还要配置环境变量</h5><h4 id="设置mysql的远程登陆"><a href="#设置mysql的远程登陆" class="headerlink" title="设置mysql的远程登陆"></a>设置mysql的远程登陆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#首先我们需要让任何用户都可登录root用户</span><br><span class="line">1. 更新域属性，升级root为%   #&quot;%&quot;表示任意用户</span><br><span class="line">update user set host=“%” where user = &quot;root&quot;</span><br><span class="line">#执行以上语句之后在执行</span><br><span class="line">flush privileges;</span><br><span class="line">#在执行授权语句</span><br><span class="line">grant all privilege on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>启动数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\mysql-5.7.12-win32\bin&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 ....</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure>





<h4 id="创建-删除数据库"><a href="#创建-删除数据库" class="headerlink" title="创建\删除数据库"></a>创建\删除数据库</h4><p>连接数据库成功之后就可以通过“ show databases;” 查看当前用户下 的所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database &quot;数据库名&quot;；   #创建新的数据库</span><br><span class="line">drop database &quot;数据库名&quot;;  #删除数据库</span><br></pre></td></tr></table></figure>

<p>通过以上命令创建\删除数据库。</p>
<h3 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h3><p>mysql支持多种类型的数据库，大致分为三类</p>
<ol>
<li>数值</li>
<li>日期</li>
<li>字符</li>
</ol>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>创建数据表需要以下信息：</p>
<ol>
<li>表名</li>
<li>表字段名</li>
<li>定义每个表字段</li>
</ol>
<h4 id="创建数据表的通用语法"><a href="#创建数据表的通用语法" class="headerlink" title="创建数据表的通用语法"></a>创建数据表的通用语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table table_name(column_name column_type);</span><br></pre></td></tr></table></figure>

<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table table_name;</span><br></pre></td></tr></table></figure>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into &quot;目标数据表&quot;(表属性(使用逗号隔开))value(表属性对应的值)；</span><br><span class="line">//</span><br><span class="line">insert into table_name(field1,field2,...,field3)</span><br><span class="line">			values</span><br><span class="line">					  (value1,value2,...,value3);</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的field from 目标表（可以是多个）[where ...] [limit n][offset m] </span><br></pre></td></tr></table></figure>

<p>where ：后面可以加上诸多限制条件，中间用and或者or隔开，这些条件可以使得筛选更加精确</p>
<p>limit：限制筛选返回的的记录个数</p>
<p>offset：指定select开始查询的数据偏移量</p>
<h4 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br></pre></td></tr></table></figure>



<ul>
<li>查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。</li>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
</ul>
<p><strong>binary关键字</strong>：where子句的比较是不区分字符大小的，可以使用binary来设定where子句字符串的比较是区分大小的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;runoob.com&#x27;;</span><br><span class="line"> </span><br><span class="line">mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;RUNOOB.COM&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2</span><br><span class="line">[WHERE Clause]</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>

<p>如果不指定where，表中的所有记录都将被删除。</p>
<h4 id="like子句"><a href="#like子句" class="headerlink" title="like子句"></a>like子句</h4><p>使用like子句获取符合条件的所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#x27;somevalue&#x27;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_tbl  WHERE runoob_author LIKE &#x27;%COM&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="union操作符"><a href="#union操作符" class="headerlink" title="union操作符"></a>union操作符</h4><p>用于连接两个以上的结果组合到一个结果集当中。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure>

<p>all:返回所有结果集，包含重复数据</p>
<p>distinct：删除所有重复的数据。不过union默认就是删除重复数据的，所以distinct对union 的结果没什么影响。</p>
<h4 id="排序-ORDER-BY"><a href="#排序-ORDER-BY" class="headerlink" title="排序 ORDER BY"></a>排序 ORDER BY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>

<p>可以使用任意列作为排序的条件，按照ASC（升序）或者DESC（降序）来排序。</p>
<p>空值是不能使用“&#x3D;”的等号无法判断</p>
<p>要使用<strong>ISNULL****和</strong>IS NOT NULL**来判断</p>
<h4 id="分组：GROUP-BY"><a href="#分组：GROUP-BY" class="headerlink" title="分组：GROUP BY"></a>分组：GROUP BY</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure>

<h4 id="使用-show-columns-from-table-name-查询列及列属性"><a href="#使用-show-columns-from-table-name-查询列及列属性" class="headerlink" title="使用 show columns from table_name 查询列及列属性"></a>使用 show columns from table_name 查询列及列属性</h4><h4 id="只有默认引擎为innoob的数据库才支持事务处理。"><a href="#只有默认引擎为innoob的数据库才支持事务处理。" class="headerlink" title="只有默认引擎为innoob的数据库才支持事务处理。"></a>只有默认引擎为innoob的数据库才支持事务处理。</h4><p>事务可以保证数据的原子性，隔离性和持久性，但是不能保证数据的一致性，数据的一致性要靠开发者来保证。</p>
<h4 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#删除、添加或者修改表字段：</span><br><span class="line">ALTER TABLE table_name DROP FIELD;</span><br><span class="line">ALTER TABLE table_name ADD field field_type;</span><br><span class="line">ALTER TABLE table_name MODIFY field newfield_type;</span><br><span class="line">ALTER TABLE table_name CHANGE field newfield_type;</span><br><span class="line">ALTER TABLE testalter_tbl MODIFY j BIGINT NOT NULL DEFAULT 100;</span><br><span class="line">#查看数据表类型使用：</span><br><span class="line">show table status;</span><br><span class="line">#修改表名</span><br><span class="line">ALTER TABLE table_name RENAME TO newtable_name;</span><br><span class="line">#修改默认值</span><br><span class="line">ALTER TABLE table_name ALTER field SET DEFAULT num;</span><br><span class="line">#删除默认值</span><br><span class="line">ALTER TABLE table_name ALTER field DROP DEFAULT;</span><br></pre></td></tr></table></figure>

<h3 id="索引：有助于高效的查询数据库，缺点是缩印的滥用会占用磁盘空间，提高了查询速度，但是降低了更新速度。"><a href="#索引：有助于高效的查询数据库，缺点是缩印的滥用会占用磁盘空间，提高了查询速度，但是降低了更新速度。" class="headerlink" title="索引：有助于高效的查询数据库，缺点是缩印的滥用会占用磁盘空间，提高了查询速度，但是降低了更新速度。"></a>索引：有助于高效的查询数据库，缺点是缩印的滥用会占用磁盘空间，提高了查询速度，但是降低了更新速度。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON table_name (column_name);</span><br><span class="line">#修改表结构（添加索引）</span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)；</span><br><span class="line">#创建的时候直接添加，和添加主键的当时相同</span><br><span class="line">INDEX [indexName] (username(length)) ；</span><br><span class="line">#删除索引</span><br><span class="line">DROP INDEX [indexName] ON mytable; </span><br></pre></td></tr></table></figure>

<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length)) ；</span><br></pre></td></tr></table></figure>

<h5 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h5><p>有四种方式来添加数据表的索引：</p>
<ul>
<li><p><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</strong></p>
<p>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</p>
</li>
<li><p><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p>
</li>
<li><p><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</p>
</li>
<li><p>**ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引</p>
</li>
</ul>
<h4 id="显示索引信息：show-index-from-table-name"><a href="#显示索引信息：show-index-from-table-name" class="headerlink" title="显示索引信息：show index  from table_name;"></a>显示索引信息：show index  from table_name;</h4><h4 id="使用查询的方式创建临时表"><a href="#使用查询的方式创建临时表" class="headerlink" title="使用查询的方式创建临时表"></a>使用查询的方式创建临时表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE 临时表名 AS</span><br><span class="line">(</span><br><span class="line">    SELECT *  FROM 旧的表名</span><br><span class="line">    LIMIT 0,10000</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="什么是关系模式"><a href="#什么是关系模式" class="headerlink" title="什么是关系模式"></a>什么是关系模式</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%9F%BA%E6%93%8D---mysql/" data-id="cllwc4xir0014jsmo839w872z" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-回溯算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.094Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法是一个既带有系统性又带有跳跃性的<strong>搜索算法</strong>，她在问题的空间树中，按照<strong>深度优先策略</strong></p>
<p>，从根节点出发搜索解空间树。算法搜索至解空间树的任一节点是，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树的搜索，逐层想其他祖先节点回溯；否则进入该子树，继续按照深度优先策略进行搜索。这种以深度优先策略搜索完问题解的方法成为回溯法，<strong>适用于求解组合数较大的问题</strong>。</p>
<p>​		使用回溯法求问题的解，应明确定义问题的解空间。问题的解空间至少包含问题的一个最优解。例如，对于有N种可选择物品的<strong>0-1背包问题</strong>，其解空间的长度为n的0-1向量组成。定义了问题的解空间后，还应将问题的解空间很好的组织起来，是的能用回溯法方便的搜索整个解空间，通常讲解空间组织称树或者图的形式。</p>
<h3 id="使用回溯法解题通常包含以下3个步骤："><a href="#使用回溯法解题通常包含以下3个步骤：" class="headerlink" title="使用回溯法解题通常包含以下3个步骤："></a>使用回溯法解题通常包含以下3个步骤：</h3><ol>
<li>针对所给的问题，定义问题的解空间树；</li>
<li>确定易于搜索的解空间树的解空间结构；</li>
<li>以深度优先的方式搜索解空间树。</li>
</ol>
<h5 id="纸上得来终觉浅，觉知此事须躬行！！！"><a href="#纸上得来终觉浅，觉知此事须躬行！！！" class="headerlink" title="纸上得来终觉浅，觉知此事须躬行！！！"></a>纸上得来终觉浅，觉知此事须躬行！！！</h5><h3 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h3><p>问题描述：有一批共N个集装箱要装上两艘载重量分别是C1和C2的轮船，其中集装箱 i 的重量为 Wi  ，且这n个集装箱的总重量小于两艘货轮能装的总重量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" data-id="cllwc4xik0010jsmodnoy6tex" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-函数指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.085Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a>函数指针：</h3><p>（1）、函数指针指向的是函数而非对象；和其他指针一样，函数指针指向某种特定的类型；</p>
<p>（2）、函数的类型由他的返回类型和参数类型决定，与函数名无关</p>
<h3 id="函数指针的声明方法："><a href="#函数指针的声明方法：" class="headerlink" title="函数指针的声明方法："></a>函数指针的声明方法：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （*指针变量名）（[形参列表]）</span><br></pre></td></tr></table></figure>

<p><strong>返回值类型</strong>说明的是函数的返回值类型，<strong>指针变量名</strong>中的括号不能省略，<strong>后面的形参列表</strong>表示指针变量所指向的函数所带的参数列表。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span>;<span class="comment">//声明一个函数</span></span><br><span class="line"><span class="type">int</span> (*f)(<span class="type">int</span> x);<span class="comment">//声明一个函数指针</span></span><br><span class="line">f=func;</span><br><span class="line">f=&amp;func;<span class="comment">//以上两种方法都可以将函数的地址赋给函数指针，赋值时函数func不带括号，也不带餐还是，由于func 代表函数的首地址，因此经过复制之后f 就指向函数func(x)的代码的首地址。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;<span class="keyword">return</span> (x&gt;y?x:y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*ptr)(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//声明一个函数指针</span></span><br><span class="line">    <span class="type">int</span> a,b,c ;</span><br><span class="line">    ptr=max;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    c=ptr(a,b);<span class="comment">//此处相当于c=max(a,b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ptr是指向函数的<strong>指针变量</strong>，所以可以把含糊max（）赋给ptr作为ptr 的值，实际上ptr和max都指向一个入口地址，不同的是ptr 作为一个指针变量，它可以指向任何一个同类型的函数，但是函数只能表示一种。在程序中用函数指针只想那个函数他就代表那个函数，然后就可以使用指针调用它。<strong>注意指向函数的指针没有++和–的操作，用的时候要格外注意</strong></em></p>
<p>函数指针还有另一种使用方法，根据编译器的不同使用不同的方式进行使用：</p>
<p>1.定义函数指针类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>2.声明变量并赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> (x&gt;y?x:y);&#125;</span><br><span class="line">func max_func=max;<span class="comment">//这样使用的话我们就可以定义很多同类型但是不同命的函数指针</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FileFunc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FileFunc()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EditFunc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EditFunc()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*funcp)</span><span class="params">()</span>;</span><br><span class="line">    funcp pfun=FileFunc;</span><br><span class="line">    pfun();<span class="comment">//此时应该输出FileFunc()</span></span><br><span class="line">    pFun=EditFunc;</span><br><span class="line">    pfun();<span class="comment">//此时应该输出EditFunc()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数指针和指针函数的区别："><a href="#函数指针和指针函数的区别：" class="headerlink" title="函数指针和指针函数的区别："></a><strong>函数指针和指针函数</strong>的区别：</h3><p>1、指针函数：返回值是指针的函数，本质是一个函数；函数指针：是一个指向相应类型函数的指针。</p>
<h3 id="函数指针数组：数组元素都是函数指针的数组"><a href="#函数指针数组：数组元素都是函数指针的数组" class="headerlink" title="函数指针数组：数组元素都是函数指针的数组"></a>函数指针数组：数组元素都是函数指针的数组</h3><p>弱指针 不拥有资源，只是有一种检测功能，检测我们的结构是否还存在</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" data-id="cllwc4xi7000ujsmodsgk0ll1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于人工智能的思考" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%85%B3%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.058Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于人工智能的思考"><a href="#关于人工智能的思考" class="headerlink" title="关于人工智能的思考"></a>关于人工智能的思考</h1><p><img src="C:\Users\lenovo\AppData\Roaming\marktext\images\2022-06-25-14-16-36-image.png"></p>
<p>机器只能解决问题，人类才能提出问题，所以决定人机共生的关系中，人类一直是主导，机器只是辅助。</p>
<p>机器要能够自己提出问题，然后解决问题才是人工智能进步的关键。</p>
<p>我们的项目是要实现简单的游戏开发，那么首先我们要解决的问题是，我们的机器应该怎办去思考，机器想要赢，就需要思考怎么战胜人类。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\marktext\images\2022-06-25-14-28-44-image.png"></p>
<p>我本人比较爱打游戏，在打游戏的过程中或者在观看别的主播打游戏的过程中，偶尔会遇到或者看到一些敌方选手想要在我丝血的时候过来强杀我的状况，遇到这种状况通常 ______种解决的方法：</p>
<p>1.原地等死，再次复活之后找到凶手然后报仇。</p>
<p>2.把技能一次性全部宣泄出去，看看能否遇到巧合，在地方杀死我之前完成反杀。</p>
<p>3.这一点就需要一些技术型选手才能做到了，就是当我们遇到这种情况的时候，首先我们要分析整体局势，如果我们被对手杀死之后会对这局游戏造成什么样的影响，其次我们还要观察周围的环境，分析有什么方法能逃避或者反杀。</p>
<p>在我们的项目中，显然我们要的并不是前两种结果，我们需要在项目中让我们的机器人能够像人类一样，完成第三种思考。这就需要大量的计算了，首先机器人应该了解自己的状态，然后将自己的状态与地方的状态进行对比。</p>
<p>我们的机器人应该时刻思考，当前的局势对己方是有利还是有弊的，如果是有利的，要将有利局势保持下去，如果是有弊的，那么应该如何操作才能翻盘。</p>
<p>机器人的每一步操作都需要朝着利己的方向下进行。</p>
<p>因为我们的游戏较为简单，那么就为我们自己的游戏制定一个简单的规则吧。</p>
<p>当玩家进入游戏的时候，游戏中应该有两方阵营：</p>
<p>一方是由玩家操控的红方有三名游戏人物，每一名游戏人物的总血量都是不同的，且都拥有三种攻击招式和一种防御招式，每一种攻击成功后使得敌方减少的血量也是不同的；</p>
<p>另一方是由我们游戏中的人工智能控制的三名蓝方角色，除了角色不同之外，其人物功能都相差不多。</p>
<p>如何胜利：</p>
<p>由玩家操控的人物和人工智能操控的人物进行对打，在限定的时间之内（2分钟），时间结束场上双方都有剩余就由剩余人物多的一方获胜，如果剩下的人数相同，就由系统自动判定平局。</p>
<p>玩家如何操作由不同的玩家决定，那么作为游戏开发人员我们应该思考的问题是，我们的人工智能应该如何操作才能获胜，作为一款人机对战游戏，我们的机器应该如何思考呢？</p>
<p>游戏场地：选择一块16 X 16的棋格作为游戏场地</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\marktext\images\2022-06-25-14-56-15-image.png"></p>
<p>人工智能控制思考的步骤应该为：</p>
<p>1.应优先攻击那个敌方人物</p>
<p>2.怎样快速抵达某一地点</p>
<p>3.如何逃离敌方追捕</p>
<p>4.怎样使用技能才能快速杀死敌方并使自己最安全</p>
<p>寻路算法：</p>
<p>—些不可预测的情况通常会导致编写代码的绝大部分时间花费在不断扩展的可能性上。因此，我们需要思考新的方式来创建更好的寻路系统:人物可以实时分析周围环境，选择最佳路径。有一种非常流行的实现这个效果的方式是使用A<em>算法，它允许Al角色不断搜索最佳路径，而不用手动设置需要跟踪的点。<br>A</em>搜索算法是一种被广泛使用的搜索算法，可以用来解决很多问题，寻路只是其中之一。由于这种算法具有开销一致性以及启发式特性，用这种算法来解决寻路问题是很常见的。A*搜索算法在到达目的地的途中不断检查地图，帮助角色决定是否可以使用某一个位置，同时尝试到达预期的目的地。</p>
<p>如何工作：</p>
<p>游戏中的地图和场景在使用A<em>算法前需要提前分析和准备。环境与其包含的所有资源会被当作一张图来处理。这意味着地图将会分为不同的点和位置，我们称之为节点。这些节点用来记录整个搜索的过程。在记录地图位置时，每个节点都有其自身的属性，包括? tness、goal和heuristic，通常将它们写作f、g和h。通过综合考虑这三个属性可以看出当前节点和路径的优劣程度。<br>路径上的每个节点都被赋予了不同的值。这些值通常也表示两个节点间的距离。不过两个节点间的值也不一定是距离。这些值也可以是时间，这样就可以找到最快的路径而不是最短的路径。A</em>算法使用两个列表―—开启列表和关闭列表。开启列表里包含需要检查的所有节点。还可以用标记数组来检查某个节点是否在开启列表或关闭列表中。<br>这意味着Al角色将会不断搜索最佳节点，以得到最快或最近的结果。如下图所示，地图是预先分析过的，可行走区域用小的灰色方块来表示，大块的灰色方块用来表示不可行走区域。Al角色用圆环表示，目的地用星星表示。如果中间遇到了不可行走区域，角色会迅速绕开然后再朝目的地行进。</p>
<p>正如我们看到的，寻路算法的理论与我们之前做的非常相似，角色-步-步 地跟着<br>这些路径点移动，直到抵达最终目的地。其中主要的不同之处是A*算法是由AI自动生成<br>的路径点，在开发者要处理复杂的大型场景时，这会是非常好的选择。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\marktext\images\2022-06-25-17-12-57-image.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%85%B3%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/" data-id="cllwc4xi4000sjsmo4ydk63gm" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于TCPIP 协议的几个经典问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%85%B3%E4%BA%8ETCPIP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.049Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于TCP-IP-协议的经典问题"><a href="#关于TCP-IP-协议的经典问题" class="headerlink" title="关于TCP&#x2F;IP 协议的经典问题"></a>关于TCP&#x2F;IP 协议的经典问题</h1><h2 id="1-讲一下TCP三次握手的流程"><a href="#1-讲一下TCP三次握手的流程" class="headerlink" title="1. 讲一下TCP三次握手的流程"></a>1. 讲一下TCP三次握手的流程</h2><p>一开始的时候，客户端和服务器都处于CLOSED的状态，然后服务器开始监听某个端口，进入LISTEN状态：</p>
<p>​	三次握手，首先由客户端向服务端发起连接请求，此为第一次握手；</p>
<p>​	然后服务端接收到来自客户端的请求之后，向客户端回复已经收到连接请求了，可以开始连接了，并转为等待连接模式，此为第二次握手；</p>
<p>​	当客户端收到来自服务端的确认码之后，在次向客户端发送确认消息，并开始连接，此为第三次握手；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次握手（由客户端发出SYN = 1,seq = x）,发送完毕后客户端处于SYN_SEND状态</span><br><span class="line">第二次握手（有服务器发出SYN = 1,ACK = 1,seq = y,ACKnum = x+1）发送完毕后，发送完毕后服务器端进入SYN_RCVD状态</span><br><span class="line">第三次握手（由客户端发出ACK = 1，ACKnum = y+1）发送完毕后客户端进入ESTABLISHED的状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手完成，可以开始进行数据传输。</span><br></pre></td></tr></table></figure>

<h2 id="2-TCP握手为什么是三次，不能是两次？也不能是四次？"><a href="#2-TCP握手为什么是三次，不能是两次？也不能是四次？" class="headerlink" title="2. TCP握手为什么是三次，不能是两次？也不能是四次？"></a>2. TCP握手为什么是三次，不能是两次？也不能是四次？</h2><p>三次握手是为了确保连接的成功，客户端和服务端都确认可以被连接然后第三次握手建立连接，如果是两次，那么建立的连接就不是百分百准确的，有可能连接失败；四次的话就有点多余了，既然三次握手已经能够准确的建立连接了，没必要再来一次，浪费时间和空间。</p>
<h2 id="3-讲一下TCP四次挥手的过程"><a href="#3-讲一下TCP四次挥手的过程" class="headerlink" title="3.讲一下TCP四次挥手的过程"></a>3.讲一下TCP四次挥手的过程</h2><p>初始状态为客户端和服务端处于连接状态，并且数据已经发送完毕，没有要继续发送的数据了，然后客户端要开始断开连接：</p>
<p>客户端首先要向服务端发送消息，告诉服务器端，我没有要传输的数据了，可以进行断开了，此为第一次挥手；当服务器端收到来自客户端的消息之后，回复客户端他已经知道了，准备好了挥手，此为第二次回收；当发送完消息一段时间之后，服务器端发送消息告诉客户端我已经准备好了，可以进行断开了，此为第三次挥手；当客户端收到消息之后，客户端断开与服务端的连接，此为第四次挥手，至此，客户端和服务端的连接彻底断开；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入FIN_WAIT_1 状态</span><br><span class="line">2. 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态</span><br><span class="line">3. 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入LAST_ACK 状态，等待来自客户端的最后一个ACK。</span><br><span class="line">4. 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</span><br></pre></td></tr></table></figure>

<h2 id="4-为什么TCP挥手需要四次呢？"><a href="#4-为什么TCP挥手需要四次呢？" class="headerlink" title="4.为什么TCP挥手需要四次呢？"></a>4.为什么TCP挥手需要四次呢？</h2><p>TCP的四次挥手过程就像两个人在打电话，当A对B说我没什么要说的了，B回复说我知道了；此时B可能还有话对A说，当B说完之后，B告诉A我说完了，你可以挂了，然后再有A来挂断电话。因为TCP通信是双端通信，客户端和服务端都可以向对方发送消息，所以要确定两边都没有数据可发送了之后才能彻底断开连接，因此需要四次挥手；</p>
<h2 id="5-TIME-WAIT状态为什么需要等待2MSL"><a href="#5-TIME-WAIT状态为什么需要等待2MSL" class="headerlink" title="5.TIME_WAIT状态为什么需要等待2MSL"></a>5.TIME_WAIT状态为什么需要等待2MSL</h2><p>2msl 两个报文的生命周期</p>
<ol>
<li>第一个MSL是为了能够保证四次挥手过程中的主动关闭方的ACK报文能够到达对端</li>
<li>第二个MSL是为了保证对端没收到ACK那么进行重传的FIN能够到达。</li>
</ol>
<h2 id="6-TCP和UDP的区别"><a href="#6-TCP和UDP的区别" class="headerlink" title="6.TCP和UDP的区别"></a>6.TCP和UDP的区别</h2><ol>
<li>TCP是面向链接的（如打电话之前要先拨号），UDP是无连接的，及传递数据之间不需要建立连接；</li>
<li>TCP要求安全性，提供可靠的服务，通过TCP连接传递的数据不丢失,不重复，安全可靠；但是UDP是尽最大努力交付，既不保障可靠交付；</li>
<li>TCP是点对点连接，UDP可以是一对一、一对多、多对多都可以；</li>
<li>TCP的传输效率相对UDP比较低，UDP适合对高速传输和对实时性有要求的通信。</li>
<li>TCP适合用于网页，邮件等；UDP适合用于视频，语音广播等</li>
<li>TCP面向字节流，UDP面向报文。</li>
</ol>
<h2 id="7-半连接队列和SYN-flood攻击的关系"><a href="#7-半连接队列和SYN-flood攻击的关系" class="headerlink" title="7.半连接队列和SYN flood攻击的关系"></a>7.半连接队列和SYN flood攻击的关系</h2><p>TCP进入三次握手前，服务端会从CLOSED状态变成LISTEN状态，同时在内部创建两个队列：半连接队列（SYN队列和全连接队列（ACCEPT队列）。</p>
<h4 id="什么是半连接队列："><a href="#什么是半连接队列：" class="headerlink" title="什么是半连接队列："></a>什么是半连接队列：</h4><p>TCP三次握手是，客户端发送SYN到服务端，服务端收到后，便回复SYN和ACK，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，及半连接队列。</p>
<h4 id="什么是全连接队列："><a href="#什么是全连接队列：" class="headerlink" title="什么是全连接队列："></a>什么是全连接队列：</h4><p>当客户端回复SCK，服务端接收后，三次握手就完成了。这是链接会等待被具体的应用取走，再被取走之前，它被推入ACCEPT队列，即为全连接队列。</p>
<p>SYNFlood是一种典型的DOS（Denial of Service拒绝服务）攻击，她在短时间内，伪造不存在的IP地址，向服务器大量发起SYN报文，当服务器回复SYN+ACK报文后，不会受到ACK会议康报文，导致服务器上建立了当量的半连接，半连接队列被挤占满了就无法处理正产的TCP请求了。</p>
<h2 id="8-TCP的粘包和拆包"><a href="#8-TCP的粘包和拆包" class="headerlink" title="8.TCP的粘包和拆包"></a>8.TCP的粘包和拆包</h2><p>TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包进行发送，这就是所谓的TCP粘包和拆包问题。</p>
<h4 id="为什么会产生粘包和拆包问题？"><a href="#为什么会产生粘包和拆包问题？" class="headerlink" title="为什么会产生粘包和拆包问题？"></a>为什么会产生粘包和拆包问题？</h4><ul>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会产生粘包；</li>
<li>接受数据段的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于TCP发送缓冲区剩余空间的大小，将会发生拆包；</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。及TCP报文长度-TCP头部长度 &gt;MSS。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>发送端将每个数据包封装成固定长度</li>
<li>在数据的尾部增加特殊字符进行分割</li>
<li>讲述分成两部分，一部分是头部一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%85%B3%E4%BA%8ETCPIP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/" data-id="cllwc4xi2000rjsmo43dafwe6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高效C++读后感" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E9%AB%98%E6%95%88C++%E8%AF%BB%E5%90%8E%E6%84%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.033Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>预处理不能退休但你一定要计划给他放长假！！！</p>
<p>使用const和inline可以尽量减少#define的使用</p>
<p>1.尽量使用”const”和”inline”而不使用“#define”，因为“#define”的作用是进行替换，<strong>如果程序出现错误，不容易被程序开发者发现。</strong></p>
<p>​		因为预处理通常是写在头文件当中的，而一个可执行文件通常会包含很多个不同的头文件，当预处理出现错误，程序编译人员只能看见预处理被替换后的结果，难以定位问题。</p>
<p>2.尽量使用<iostream>而不是&lt;stdio.h&gt;</p>
<p>3.为了避免混乱，最好杜绝对数组类型用typedefs。这其实很容易，因为标准c++库(见<a href="ch12e.htm">条款49</a>)包含有stirng和vector模板，使用他们将会使对数组的需求减少到几乎零。举例来说，addresslines可以定义为一个字符串(string)的向量(vector)，即addresslines可定义为vector<string>类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E9%AB%98%E6%95%88C++%E8%AF%BB%E5%90%8E%E6%84%9F/" data-id="cllwc4xjx001sjsmog0tshk2k" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-泛型算法和函数对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.024Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy:</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename SRC_IT, typename DES_IT&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">My_copy</span><span class="params">(SRC_IT first, SRC_IT last, DES_IT des)</span></span><br><span class="line">&#123;</span><br><span class="line">	SRC_IT tmp = first;</span><br><span class="line">	<span class="keyword">for</span> (; tmp != last; ++tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		*des = *tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename SRC_IT, typename DES_IT&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//加上引用之后会报错</span></span><br><span class="line"><span class="comment">//临时量的引用具有常属性</span></span><br><span class="line"><span class="comment">void My_copy(const SRC_IT&amp; first,const SRC_IT&amp; last, DES_IT des)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	SRC_IT tmp = first;</span></span><br><span class="line"><span class="comment">	for (; tmp != last; ++tmp)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		*des = *tmp;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	copy(v1.begin(), v1.end(), ostream_iterator&lt;<span class="type">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	copy(v1.begin(), v1.end(), inserter(v2, v2.begin()));</span><br><span class="line">	copy(v2.begin(), v2.end(), ostream_iterator&lt;<span class="type">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	My_copy(v2.begin(), v2.end(), ostream_iterator&lt;<span class="type">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find</span><br><span class="line">sort</span><br><span class="line">find_if</span><br></pre></td></tr></table></figure>







<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">less</span><br><span class="line">    greater</span><br><span class="line">    binderlst</span><br><span class="line">    binder2nd</span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<p>当一个类中没有函数的实现只有函数的虚声明，那么我们把这样的类叫做接口</p>
<p>将虚构函数定义为虚函数的目的：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/" data-id="cllwc4xiw0017jsmo9wlr0hzx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>