<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二叉搜索树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.016Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉搜索树：其实本质上还是二叉树，只不过其在二叉树的基础之上增加了一些新的约束，从而变成了了一颗有规律的二叉树。</p>
<p>要想弄明白二叉搜索树，我们就必须牢牢把握住这三点规则：</p>
<ol>
<li>每个节点都有一个作为搜索依据的关键码，每个关键码都不相同，树中没有关键码相同的两个节点；</li>
<li>左子树上所有的节点的关键码都小于根节点的关键码；</li>
<li>右子树上的所有节点的关键码都大于根节点的关键码。</li>
</ol>
<p><strong>二叉搜索树的左右子树也都是二叉搜索树****！！！</strong></p>
<h2 id="二叉搜索树节点的结构"><a href="#二叉搜索树节点的结构" class="headerlink" title="二叉搜索树节点的结构"></a>二叉搜索树节点的结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BstNode</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键码</span></span><br><span class="line">    BstNode* parent; <span class="comment">// 双亲指针</span></span><br><span class="line">    BstNode* leftchild; <span class="comment">//左孩子指针</span></span><br><span class="line">    BstNode* rightchild;  <span class="comment">//右孩子指针</span></span><br><span class="line">&#125;BstNode,*BSTree;</span><br></pre></td></tr></table></figure>

<p>每个节点都包含四个域，除了关键码域，其余三个域串联起了整个树，<strong>二叉搜索树按照中序遍历的方法，遍历出来的应该是一个从小到大的数组</strong></p>
<p>注意：<strong>根节点没有双亲，这一点在后面有很重要的应用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请节点</span></span><br><span class="line"><span class="function">BstNode* <span class="title">BuyNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BstNode* s = (BstNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BstNode));</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">memset</span>(s , <span class="number">0</span> , <span class="built_in">sizeof</span>(BstNode));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构建二叉搜索树"><a href="#构建二叉搜索树" class="headerlink" title="构建二叉搜索树"></a>构建二叉搜索树</h2><p>在构建二叉树搜索树的时候，要把握好左子树大于根节点大于右子树的规则。</p>
<p>在插入节点的时候，要考虑几种情况：</p>
<ol>
<li>如果根节点为空：根节点为空说明这是一个空树，插入的节点应该作为根节点；</li>
<li>如果插入的值小于根节点的关键码，依次用根节点的左子树与之比较；</li>
<li>如果插入的值大于根节点得关键码，依次用根节点的右子树与之比较；</li>
<li>如果插入的值在二叉树中找到了相同的关键码，插入失败，因为二叉树终不能有相同的关键码；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入函数</span></span><br><span class="line"><span class="comment">//使用引用是因为我们在局部函数中申请了空间，如果是单纯的指针，在局部函数结束的时候，申请的空间将释放，所以需要用引用,想要通过形参改变实参只能使用引用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(BstNode*&amp; root,KeyType val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BstNode* pa = <span class="literal">nullptr</span>;</span><br><span class="line">    BstNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;key != val)</span><br><span class="line">    &#123;</span><br><span class="line">        pa = p;</span><br><span class="line">        p = val &lt; p-&gt;key ? p-&gt;leftchild : p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;key == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    p = <span class="built_in">BuyNode</span>();</span><br><span class="line">    p-&gt;key = val;</span><br><span class="line">    p-&gt;parent = pa;</span><br><span class="line">    <span class="comment">//此时如果pa 还是空，说明上面的操作都没进行，既树是一颗空树，直接让申请的节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        root = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;key&lt;p-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            pa-&gt;rightchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;leftchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retrun <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉搜索树</span></span><br><span class="line"><span class="function">BSTree <span class="title">CreateBSTree</span><span class="params">(KeyType* ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ar == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//如果数组为空，就无法构建二叉树，返回空指针</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(ar)/<span class="built_in">sizefo</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    BstNode* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Insert</span>(ptr,ar[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关的API函数"><a href="#相关的API函数" class="headerlink" title="相关的API函数"></a>相关的API函数</h2><p>既然是二叉树那么二叉树对应的前中后序遍历等函数都能够被应用，这里就不过多赘述了，因为二叉搜索树的特殊性质，可以归纳出一下几个函数， </p>
<ol>
<li>找到中序遍历的最头的节点：BstNode* Fast();</li>
<li>找到树在中序遍历之后每个节点的后继节点：BstNode* Next();</li>
<li>找到中序遍历的最尾的节点：BstNode* Last();</li>
<li>找到树在中序遍历之后每个节点的前驱节点：BstNode* Prev();</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树 的最左侧节点肯定是最小的</span></span><br><span class="line"><span class="function">BstNode* <span class="title">Fast</span><span class="params">(BstNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> &amp;&amp; root-&gt;leftchild != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = root-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BstNode* <span class="title">Next</span><span class="params">(BstNode* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>) <span class="keyword">return</span> ptr;</span><br><span class="line">    <span class="comment">//根据二叉搜索树的特点，左孩子都比根节点大，右孩子都比根节点小，那么当右孩子不为空的时候，根节点的中序遍历的直接后继应该就是右子树中的最小的节点</span></span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;rightchild != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fast</span>(ptr-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	BstNode* pa = ptr-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(pa != <span class="literal">nullptr</span> &amp;&amp; pa-&gt;leftchild != ptr)  <span class="comment">// pa-&gt;rightchild == ptr</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = pa ;</span><br><span class="line">            pa = ptr-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BstNode* <span class="title">Last</span><span class="params">(BstNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;rightchild != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root= root-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BstNode* <span class="title">Prev</span><span class="params">(BStNode* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>) <span class="keyword">return</span> ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;leftchild != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Last</span>(ptr-&gt;leftchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BstNode* pa = ptr-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(pa != <span class="literal">nullptr</span> &amp;&amp; pa-&gt;leftchild != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = pa;</span><br><span class="line">            pa = ptr-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>通常来说，我们对二叉树继续拧中序遍历，最常用的应该是递归的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BstNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;leftchild);</span><br><span class="line">		cout&lt;&lt;root-&gt;key;</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有时要求我们使用非递归的方式进行二叉树的中序遍历，此时之前铺垫的Fast和Next函数就有作用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NiceInOrder</span><span class="params">(BstNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(BstNode* ptr = <span class="built_in">Fast</span>(root);ptr!=<span class="literal">nullptr</span>;ptr = <span class="built_in">Next</span>(ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ptr-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="删除节点-：-bool-Remove-BstNode-root-KeyType-val"><a href="#删除节点-：-bool-Remove-BstNode-root-KeyType-val" class="headerlink" title="删除节点 ： bool Remove(BstNode* root ,KeyType val)"></a>删除节点 ： bool Remove(BstNode* root ,KeyType val)</h2><p>我们要删除节点，首先要判断节点的类型：</p>
<ol>
<li>空节点：不删除，删除失败</li>
<li>没找到相应的节点：删除失败</li>
<li>要删除的是叶子节点：直接删除，释放节点，并指向空</li>
<li>要删除的节点是单分支节点：交换</li>
<li>要删除双分支节点：变成单分支</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(BstNode*&amp; root ,KeyType val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BstNode* ptr = root;</span><br><span class="line">    <span class="keyword">while</span>(ptr != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;key != val)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = val &lt; ptr-&gt;key ? ptr-&gt;leftchild : ptr-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是双分支节点，找到有分支的最小节点与要删除节点调换，释放右子树最小节点</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;leftchild != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;rightchild != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BstNode* last = <span class="built_in">Fast</span>(ptr-&gt;rightchild);</span><br><span class="line">            ptr-&gt;key = last-&gt;key;</span><br><span class="line">            <span class="built_in">free</span>(last);</span><br><span class="line">            last = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是双分支，</span></span><br><span class="line">        BstNode* pa = ptr-&gt;parent;</span><br><span class="line">        BstNode* child = pa-&gt;rightchild == <span class="literal">nullptr</span> ? pa-&gt;leftchid:pa-&gt;rightchild;</span><br><span class="line">        <span class="keyword">if</span>(pa == <span class="literal">nullptr</span>) root = child;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;leftchild == p)</span><br><span class="line">            &#123;</span><br><span class="line">                pa-&gt;leftchild = child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pa-&gt;rightchild = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" data-id="cllwc4xhw000njsmo28055dk6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.006Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>树的定义：什么是树？</p>
<p>假如给我们一棵二叉树的前序遍历和中序遍历结果，我们应该如何通过这两个遍历结果创建一棵树呢？</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220721095530021.png" alt="image-20220721095530021"></p>
<p>通过前序遍历的结果我们可以找到二叉树的根节点，那么既然有了二叉树的根节点，我们在看中序遍历，在中序遍历中找到二叉树的根节点，呢么根节点之前的所有节点就是二叉树的左子树了，根节点之后的所有节点就是二叉树的右子树了。由此就可以对遍历结果进行分割了。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220721095910621.png" alt="image-20220721095910621"></p>
<p>既然已经得到了左子树和右子树就好办了，我们知道二叉树的左子树和右子树也可以看作是一棵二叉树，此时二叉树的规模变小的了，但还是符合前序遍历和中序遍历的结果，所以可以对左右子树在分别进行创建。</p>
<p>伪代码表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">BtNode* <span class="title function_">BuyNode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BtNode* s = (BtNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtNode));</span><br><span class="line">    <span class="keyword">if</span>(s == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(BtNode));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(<span class="type">char</span>* in,<span class="type">int</span> n,<span class="type">char</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos  = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n；++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == a)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree <span class="title function_">CreateBinaryTree</span><span class="params">(<span class="type">char</span>* Pre,<span class="type">char</span>* in,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先我们需要购买一个节点，让其作为根节点，所以就需要一个购买节点函数</span></span><br><span class="line">    BtNode* root = BuyNode();<span class="comment">//购买节点</span></span><br><span class="line">    root-&gt;value = pre[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//要想构建二叉树，我们还需要在中序遍历中找到根节点的位置，从而确定左右子树，所以还需要一个查找函数，返回值是根节点的位置pos</span></span><br><span class="line">    <span class="type">int</span> pos = FindPos(in,n,pre[<span class="number">0</span>]);<span class="comment">//在中序遍历中查找pre[0]的位置,如果没有找到，说明两个遍历结果不是一棵二叉树，直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//此时我们已经有了新的左子树和右子树，分别来创建</span></span><br><span class="line">    CreateBinaryTree(左子树的前序遍历结果,左子树的中序遍历结果,左子树的大小);<span class="comment">//创建左子树</span></span><br><span class="line">    CreateBinaryTree(右子树的前序遍历结果,右子树的中序遍历结果,右子树的大小);<span class="comment">//创建右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pre 表示前序遍历数组，in表示中序遍历数组，n表示节点的个数</span></span><br><span class="line">BinaryTree <span class="title function_">CreateBtree</span><span class="params">(<span class="type">char</span>* Pre,<span class="type">char</span>* in)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(pre)/<span class="keyword">sizeof</span>(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(pre==nullptr||in==nullptr||n&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nullptr;<span class="comment">//不满足以上条件说明不存在该二叉树，直接返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    CreateBinaryTree(pre,in,n);<span class="comment">//开始创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建二叉树以及使用递归方式前中后序遍历完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*二叉树的存储方式有两种，一种是以链表的方式进行存储，一种是以数组的方式进行存储</span></span><br><span class="line"><span class="comment">* 当以数组的方式进行存储的时候，要注意节点之间的关系，假设根节点的位置为POS那么左子树的位置就是</span></span><br><span class="line"><span class="comment">* 2*POS+1，右子树的位置就是2*POS+2。正是由于这层关系，当二叉树不是满二叉树的时候，使用数组进行存储</span></span><br><span class="line"><span class="comment">* 是非常的浪费空间的，空间的利用率较低。</span></span><br><span class="line"><span class="comment">* 当以链表的方式存储二叉树的时候，每一个二叉树节点都含有一个左孩子指针和一个右孩子指针，两个指针分别</span></span><br><span class="line"><span class="comment">* 指向相应的节点，节省空间，并且更容易使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType value;</span><br><span class="line">	BtNode* leftchild;</span><br><span class="line">	BtNode* rightchild;</span><br><span class="line">&#125;BtNode,*BinaryTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BtNode* <span class="title function_">BuyNode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BtNode* s = (BtNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtNode));</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="keyword">return</span> nullptr;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(BtNode));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(ElemType* In, <span class="type">int</span> n, ElemType val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == val)</span><br><span class="line">		&#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree <span class="title function_">CreateBinTree</span><span class="params">(ElemType* Pr, ElemType* In, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	BtNode* s = nullptr;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = BuyNode();</span><br><span class="line">		s-&gt;value = Pr[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> pos = FindPos(In, n, Pr[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		s-&gt;leftchild = CreateBinTree(Pr + <span class="number">1</span>, In, pos);</span><br><span class="line">		s-&gt;rightchild = CreateBinTree(Pr + pos + <span class="number">1</span>, In + pos + <span class="number">1</span>, n - pos - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过前中序数组创建二叉树</span></span><br><span class="line">BinaryTree <span class="title function_">CreateBinaryTree</span><span class="params">(ElemType* Pr, ElemType* In)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(Pr);</span><br><span class="line">	<span class="keyword">if</span> (Pr == nullptr || In == nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> CreateBinTree(Pr, In, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree <span class="title function_">CreateLI</span><span class="params">(ElemType* Li, ElemType* In, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	BtNode* s = nullptr;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = BuyNode();</span><br><span class="line">		s-&gt;value = Li[n - <span class="number">1</span>];<span class="comment">//后序遍历的最后一位数据是根节点</span></span><br><span class="line">		<span class="type">int</span> pos = FindPos(In, n, Li[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		s-&gt;leftchild = CreateLI(Li, In, pos);</span><br><span class="line">		s-&gt;rightchild = CreateLI(Li + pos, In + pos + <span class="number">1</span>, n - pos - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过后中序数组建立二叉树</span></span><br><span class="line">BinaryTree <span class="title function_">CreateLITree</span><span class="params">(ElemType* Li, ElemType* In)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(Li);</span><br><span class="line">	<span class="keyword">if</span> (Li == nullptr || In == nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> CreateLI(Li, In, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的前序遍历（递归方式）根节点-左子树-右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BtNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		PreOrder(root-&gt;leftchild);</span><br><span class="line">		PreOrder(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历（递归方式）左子树-根节点-右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BtNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrder(root-&gt;leftchild);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		InOrder(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历（递归方式）左子树-右子树-根节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PastOrder</span><span class="params">(BtNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrder(root-&gt;leftchild);</span><br><span class="line">		InOrder(root-&gt;rightchild);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ar[] = &#123; <span class="string">&quot;ABCDEFGH&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> br[] = &#123; <span class="string">&quot;CBEDFAGH&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> cr[] = &#123; <span class="string">&quot;CBEDFGHA&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//BinaryTree root = CreateBinaryTree(ar, br);</span></span><br><span class="line">	BinaryTree root = CreateLITree(cr, br);</span><br><span class="line">	PreOrder(root);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	InOrder(root);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	PastOrder(root);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归的中序遍历的实现：</p>
<p>这里我们需要借助一个栈来实现，利用栈的特性，后进先出，当我们到达端节点时，打印端节点。按照中序的顺序，既左中右打印二叉树。具体怎么操作呢？</p>
<p>申请一个站用来存储节点，当根节点不为空，或者栈不为空的时候判断栈中节点的左孩子是否为空，如果左孩子不为空就继续将左孩子入栈，如果左孩子为空，就打印该节点，然后在访问右孩子，继续之前的判断。</p>
<p>要点在于我们访问每一个节点的时候，都要将其当做根节点来判断，将其当做一个小的二叉树，完成中序遍历，那么总的实现下来就是整个二叉树的中序遍历啦。</p>
<p>代码实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NiceInOrder</span><span class="params">(BtNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果根节点为空的话，直接返回就不用排序</span></span><br><span class="line">	<span class="keyword">if</span>(root == nullptr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BtNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(root!=nullptr || !st.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不断将左子树入栈，当左子树为空时，说明到达端节点</span></span><br><span class="line">        <span class="keyword">while</span>(root!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        root = st.top(); st.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; root-&gt;value;</span><br><span class="line">        root = root-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树的非递归后序遍历：</p>
<p>后序遍历的顺序是左右中，优先访问左子树当左子树访问完毕之后，在访问右子树，最后访问根节点。那么非递归的后序遍历的难点在于，我们访问到端节点之后如何判断是否打印该节点呢，该节点是否还有右子树没有访问。</p>
<p>假设二叉树只有三个节点，如图所示：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220721154523132.png" alt="image-20220721154523132"></p>
<p>如果根节点不为空就将根节点入栈，因为是后序遍历，所以要再访问根节点的左子树，可以看到左子树也不为空，继续向左子树访问，当左子树为空时返回到根节点继续判断右子树是否为空，当左右子树都为空的时候，才能打印根节点。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NicePastOrder</span><span class="params">(BtrNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == nullptr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BtNode*&gt; st;</span><br><span class="line">    BtNode* tag = nullptr;<span class="comment">//标志位，总是指向最近打印的那个节点</span></span><br><span class="line">    <span class="keyword">while</span>(root != nullptr || !st.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当上面的循环执行完毕，说明当前的*root已经指向了nullptr，那么他的双亲节点就是没有左子树的，然后可以进行出战操作了</span></span><br><span class="line">        <span class="comment">//当执行完出栈操作之后，我们就已经知道了root节点的左孩子是空的，或者左孩子已经打印过了。</span></span><br><span class="line">        root= st.top(); st.pop();</span><br><span class="line">        <span class="comment">//因为执行的是后序遍历、出栈之后我们还需要判断，该节点是否有右子树，如果有并且还没有遍历，那么要将右子树遍历完毕才能打印根节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;rightchild == nullptr || root-&gt;rightchild == tag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">            tag = ptr;</span><br><span class="line">            ptr =nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果右子树不为空，就要再将右子树入栈，继续判断</span></span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;rightchild；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树的非递归的前序遍历的实现：</p>
<p>要实现前序遍历就需要先打印根节点，然后打印左子树再打印右子树，还是要使用分治的策略。使用一个栈，先将根节点入栈，只要root不为空或者栈不为空就一直循环，每次循环都出栈顶元素，并判断并将栈顶元素的左右孩子入栈。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NicePreOrder</span><span class="params">(BtNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BtNode*&gt; s;</span><br><span class="line">	s.push(root);<span class="comment">//先将根节点放进去</span></span><br><span class="line">	<span class="keyword">while</span> (root != nullptr || !s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		root = s.top(); s.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;value;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;rightchild != nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(root-&gt;rightchild);</span><br><span class="line">			root = root-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;leftchild != nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			s.push(root-&gt;leftchild);</span><br><span class="line">			root = root-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树的创建以及前中后序遍历的代码总结：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*二叉树的存储方式有两种，一种是以链表的方式进行存储，一种是以数组的方式进行存储</span></span><br><span class="line"><span class="comment">* 当以数组的方式进行存储的时候，要注意节点之间的关系，假设根节点的位置为POS那么左子树的位置就是</span></span><br><span class="line"><span class="comment">* 2*POS+1，右子树的位置就是2*POS+2。正是由于这层关系，当二叉树不是满二叉树的时候，使用数组进行存储</span></span><br><span class="line"><span class="comment">* 是非常的浪费空间的，空间的利用率较低。</span></span><br><span class="line"><span class="comment">* 当以链表的方式存储二叉树的时候，每一个二叉树节点都含有一个左孩子指针和一个右孩子指针，两个指针分别</span></span><br><span class="line"><span class="comment">* 指向相应的节点，节省空间，并且更容易使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BtNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType value;</span><br><span class="line">	BtNode* leftchild;</span><br><span class="line">	BtNode* rightchild;</span><br><span class="line">&#125;BtNode,*BinaryTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BtNode* <span class="title">BuyNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BtNode* s = (BtNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BtNode));</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(BtNode));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPos</span><span class="params">(ElemType* In, <span class="type">int</span> n, ElemType val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == val)</span><br><span class="line">		&#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTree <span class="title">CreateBinTree</span><span class="params">(ElemType* Pr, ElemType* In, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BtNode* s = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = <span class="built_in">BuyNode</span>();</span><br><span class="line">		s-&gt;value = Pr[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">FindPos</span>(In, n, Pr[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		s-&gt;leftchild = <span class="built_in">CreateBinTree</span>(Pr + <span class="number">1</span>, In, pos);</span><br><span class="line">		s-&gt;rightchild = <span class="built_in">CreateBinTree</span>(Pr + pos + <span class="number">1</span>, In + pos + <span class="number">1</span>, n - pos - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过前中序数组创建二叉树</span></span><br><span class="line"><span class="function">BinaryTree <span class="title">CreateBinaryTree</span><span class="params">(ElemType* Pr, ElemType* In)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(Pr);</span><br><span class="line">	<span class="keyword">if</span> (Pr == <span class="literal">nullptr</span> || In == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">CreateBinTree</span>(Pr, In, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTree <span class="title">CreateLI</span><span class="params">(ElemType* In, ElemType* Li, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BtNode* s = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = <span class="built_in">BuyNode</span>();</span><br><span class="line">		s-&gt;value = Li[n - <span class="number">1</span>];<span class="comment">//后序遍历的最后一位数据是根节点</span></span><br><span class="line">		<span class="type">int</span> pos = <span class="built_in">FindPos</span>(In, n, Li[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		s-&gt;leftchild = <span class="built_in">CreateLI</span>( In,Li, pos);</span><br><span class="line">		s-&gt;rightchild = <span class="built_in">CreateLI</span>( In + pos + <span class="number">1</span>,Li + pos, n - pos - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过后中序数组建立二叉树</span></span><br><span class="line"><span class="function">BinaryTree <span class="title">CreateLITree</span><span class="params">(ElemType* In , ElemType* Li)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(In );</span><br><span class="line">	<span class="keyword">if</span> (Li == <span class="literal">nullptr</span> || In == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">CreateLI</span>(In,Li , n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的前序遍历（递归方式）根节点-左子树-右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">PreOrder</span>(root-&gt;leftchild);</span><br><span class="line">		<span class="built_in">PreOrder</span>(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历（递归方式）左子树-根节点-右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;leftchild);</span><br><span class="line">		cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;rightchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历（递归方式）左子树-右子树-根节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PastOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;leftchild);</span><br><span class="line">		<span class="built_in">InOrder</span>(root-&gt;rightchild);</span><br><span class="line">		cout &lt;&lt; root-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////二叉树的中序遍历（非递归方式）</span></span><br><span class="line"><span class="comment">//使用循环的方式一般是面试时考察的重点，原理是使用栈去存储相应的子树，当到达终端节点时，再将栈中的节点一一出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NiceInOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BtNode*&gt; s;</span><br><span class="line">	<span class="keyword">while</span> (root !=<span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将整个左子树入栈</span></span><br><span class="line">		<span class="keyword">while</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s.<span class="built_in">push</span>(root);</span><br><span class="line">			root = root-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//到达端节点时开始出栈</span></span><br><span class="line">		root = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; root-&gt;value;</span><br><span class="line">		root = root-&gt;rightchild;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的前序遍历（非递归方式）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NicePreOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BtNode*&gt; s;</span><br><span class="line">	BtNode* node = <span class="literal">nullptr</span>;</span><br><span class="line">	s.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		node = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; node-&gt;value;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;rightchild)</span><br><span class="line">			s.<span class="built_in">push</span>(node-&gt;rightchild);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;leftchild)</span><br><span class="line">			s.<span class="built_in">push</span>(node-&gt;leftchild);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历（非递归方式）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NicePastOrder</span><span class="params">(BtNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;BtNode*&gt; st;</span><br><span class="line">	BtNode* tag = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(root);</span><br><span class="line">			root = root-&gt;leftchild;</span><br><span class="line">		&#125;</span><br><span class="line">		root = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;rightchild == <span class="literal">nullptr</span> || root-&gt;rightchild == tag)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; root-&gt;value;</span><br><span class="line">			tag = root;</span><br><span class="line">			root = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(root);</span><br><span class="line">			root = root-&gt;rightchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ar[] = &#123; <span class="string">&quot;ABCDEFGH&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> br[] = &#123; <span class="string">&quot;CBEDFAGH&quot;</span> &#125;;</span><br><span class="line">	<span class="type">char</span> cr[] = &#123; <span class="string">&quot;CEFDBHGA&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//BinaryTree root = CreateBinaryTree(ar, br);</span></span><br><span class="line">	BinaryTree root = <span class="built_in">CreateLITree</span>(br,cr );</span><br><span class="line">	<span class="built_in">NiceInOrder</span>(root);</span><br><span class="line">	<span class="built_in">NicePreOrder</span>(root);</span><br><span class="line">	<span class="built_in">PreOrder</span>(root);</span><br><span class="line">	<span class="comment">/*PreOrder(root);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	InOrder(root);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	PastOrder(root);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cllwc4xhv000mjsmo69bi13s8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-单例模式超强讲解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%B6%85%E5%BC%BA%E8%AE%B2%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.998Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。</p>
<ol>
<li><h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4></li>
</ol>
<p>  面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。</p>
<p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130312524.png" alt="image-20220728130312524"></p>
<ol start="2">
<li><h4 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h4></li>
</ol>
<h5 id="单例模式有两种类型："><a href="#单例模式有两种类型：" class="headerlink" title="单例模式有两种类型："></a>单例模式有两种类型：</h5><p>懒汉式：在真正需要使用对象时才去创建该单例类对象<br>饿汉式：在类加载时已经创建好该单例对象，等待被程序使用</p>
<h4 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h4><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。，否则则先执行实例化操作。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130333134.png" alt="image-20220728130333134"></p>
<p>根据上面的流程图，就可以写出下面的这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。</p>
<p>以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。</p>
<h4 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h4><p>饿汉式在类加载时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130413359.png" alt="image-20220728130413359"></p>
<p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static final Singleton singleton = new Singleton();</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在</p>
<p>类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p>
<ol start="3">
<li>懒汉式如何保证只创建一个对象<br>我们再来回顾懒汉式的核心方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断singleton为空，那么它们都会去实例化一个Singleton对象，这就变成双例了。所以，我们要解决的是线程安全问题。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130437103.png" alt="image-20220728130437103"></p>
<p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    synchronized(Singleton.class) &#123;   </span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</p>
<p>接下来要做的就是优化性能，目标是：如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p>
<p>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">        synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">            if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                singleton = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码已经完美地解决了并发安全+性能低效问题：</p>
<p>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；<br>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化<br>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可<br>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</p>
<p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：Double Check（双重校验） + Lock（加锁）</p>
<p>完整的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">            synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">                if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p>
<ol start="4">
<li>使用volatile防止指令重排<br>创建一个对象，在JVM中会经过三步：</li>
</ol>
<p>（1）为singleton分配内存空间</p>
<p>（2）初始化singleton对象</p>
<p>（3）将singleton指向分配好的内存空间</p>
<p>指令重排序是指：JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</p>
<p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130511456.png" alt="image-20220728130511456"></p>
<p>使用volatile关键字可以防止指令重排序，其原理较为复杂，这篇博客不打算展开，可以这样理解：使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换，这样在多线程环境下就不会发生NPE异常了。</p>
<p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</p>
<p>最终的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">            synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">                if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>破坏懒汉式单例与饿汉式单例<br>无论是完美的懒汉式还是饿汉式，终究敌不过反射和序列化，它们俩都可以把单例对象破坏掉（产生多个对象）。</li>
</ol>
<p>1：演示利用反射破坏单例模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 获取类的显式构造器</span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    // 可访问私有构造器</span><br><span class="line">    construct.setAccessible(true); </span><br><span class="line">    // 利用反射构造新对象</span><br><span class="line">    Singleton obj1 = construct.newInstance(); </span><br><span class="line">    // 通过正常方式获取单例对象</span><br><span class="line">    Singleton obj2 = Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p>
<h5 id="2：利用序列化与反序列化破坏单例模式"><a href="#2：利用序列化与反序列化破坏单例模式" class="headerlink" title="2：利用序列化与反序列化破坏单例模式"></a>2：利用序列化与反序列化破坏单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建输出流</span><br><span class="line">    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;Singleton.file&quot;));</span><br><span class="line">    // 将单例对象写到文件中</span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    // 从文件中读取单例对象</span><br><span class="line">    File file = new File(&quot;Singleton.file&quot;);</span><br><span class="line">    ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">    Singleton newInstance = (Singleton) ois.readObject();</span><br><span class="line">    // 判断是否是同一个对象</span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>两个对象地址不相等的原因是：readObject() 方法读入对象时，它必定会返回一个新的对象实例，必然指向新的内存地址。</p>
<ol start="6">
<li>能让面试官鼓掌的枚举实现<br>我们已经掌握了懒汉式与饿汉式的常见写法了，在《大话设计模式》中的单例模式章节也止步于此。但是，追求极致的我们，怎么能够止步于此，在《Effective Java》书中，给出了终极解决方法，话不多说，学完下面，真的不虚面试官考你了。</li>
</ol>
<p>在 JDK1.5 后，使用 Java 语言实现单例模式的方式又多了一种：枚举</p>
<p>我们先来看看枚举如何实现单例模式的，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    System.out.println(&quot;这是枚举类型的单例模式！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要思考：使用枚举实现单例模式的优势在哪里？</p>
<p>我们从最直观的地方入手，第一眼看到这几行代码，就会感觉到“少”，没错，就是少，虽然这优势有些牵强，但写的代码越少，越不容易出错。</p>
<p>优势1：代码对比饿汉式与懒汉式来说，更加地简洁</p>
<p>其次，既然是实现单例模式，那这种写法必定满足单例模式的要求，而且使用枚举实现时，没有做任何额外的处理。</p>
<p>优势2：它不需要做任何额外的操作去保证对象单一性与线程安全性</p>
<p>我写了一段测试代码放在下面，这一段代码可以证明程序启动时仅会创建一个 Singleton 对象，且是线程安全的。</p>
<p>我们可以简单地理解枚举实现单例的过程：在程序启动时，会调用Singleton的空参构造器，实例化好一个Singleton对象赋给INSTANCE，之后再也不会实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    Singleton() &#123; System.out.println(&quot;枚举创建对象了&quot;); &#125;</span><br><span class="line">    public static void main(String[] args) &#123; /* test(); */ &#125;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Singleton t1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton t2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.print(&quot;t1和t2的地址是否相同：&quot; + t1 == t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&#x2F;&#x2F; 枚举创建对象了<br>&#x2F;&#x2F; t1和t2的地址是否相同：true<br>除了优势1和优势2，还有最后一个优势让枚举实现单例模式在目前看来已经是“无懈可击”了。</p>
<p>优势3：使用枚举可以防止调用者使用反射、序列化与反序列化机制强制生成多个单例对象，破坏单例模式。</p>
<h4 id="防破坏的原理如下："><a href="#防破坏的原理如下：" class="headerlink" title="防破坏的原理如下："></a>防破坏的原理如下：</h4><h5 id="（1）防反射"><a href="#（1）防反射" class="headerlink" title="（1）防反射"></a>（1）防反射</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130543333.png" alt="image-20220728130543333"></p>
<p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p>
<h5 id="（2）防止反序列化创建多个枚举对象"><a href="#（2）防止反序列化创建多个枚举对象" class="headerlink" title="（2）防止反序列化创建多个枚举对象"></a>（2）防止反序列化创建多个枚举对象</h5><p>在读入Singleton对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的类型和变量名输出到文件中，在读入文件反序列化成对象时，利用 Enum 类的 valueOf(String name) 方法根据变量的名字查找对应的枚举对象。</p>
<p>所以，在序列化和反序列化的过程中，只是写出和读入了枚举类型和名字，没有任何关于对象的操作。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130558303.png" alt="image-20220728130558303"></p>
<h5 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h5><p>（1）Enum 类内部使用Enum 类型判定防止通过反射创建多个对象</p>
<p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），通过 valueOf() 方法匹配枚举名找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p>
<p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与饿汉式单例有异曲同工之妙。</p>
<ol start="7">
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>  （1）单例模式常见的写法有两种：懒汉式、饿汉式</p>
<p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</p>
<p>（3）饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p>
<p>（4）在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</p>
<p>（5）如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</p>
<p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</p>
<p>（7）最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%B6%85%E5%BC%BA%E8%AE%B2%E8%A7%A3/" data-id="cllwc4xig000yjsmo01g1hnmd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-测试原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.988Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数组，字符串，基础数据结构，排序算法，动态规划</p>
<p>算法：</p>
<p>剑指offer</p>
<p>牛客网：简单-》中等-》难</p>
<p>项目的三个问题：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720130223637.png" alt="image-20220720130223637"></p>
<p>面试考点：</p>
<p>软件测试理论知识</p>
<p>语言基础</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>测试的目的：发现软件的缺陷。bug是测试的产品而非目标。多给功能和少给功能都属于软件缺陷</p>
<p>软件测试的术语：</p>
<p>SRS：需求分析文档</p>
<p>HLD：概要设计文档</p>
<p>LLD：详细设计文档</p>
<p>BD：基本设计</p>
<p>DD：详细设计</p>
<p>FD：结构设计</p>
<p>软件开发过程：立项、需求分析、概要设计、详细设计、编码、测试、运行及维护；</p>
<p><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">单元测试</a> 参照 详细设计说明说（LLD）<br><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">集成测试</a> 参照 <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">概要设计说明书</a>（HLD）<br><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">系统测试</a> 参照 需求规格说明说（SRS）</p>
<p>需求规格说明书 是为使用用户和软件开发者双方对该软件的初始规定有一个共同的理解， 使之成为整个开发工作的基础。<br>概要设计 就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。<br>详细设计 就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。</p>
<h3 id="软件测试的V模型"><a href="#软件测试的V模型" class="headerlink" title="软件测试的V模型"></a>软件测试的V模型</h3><p><strong>需求分析</strong>：在这个阶段，我们主要做的事情是明确客户需要什么，软件需要做成什么样子。以及软件的功能。<code>需求分析师和客户的沟通来决定</code>，需求分析师需要写出需求规格说明书</p>
<p><strong>概要设计</strong>：主要是架构师来完成，<code>搭建框架，把每一个模块的功能点，以及多个模块之间的联系</code>（涉及到数据的传递）</p>
<p><strong>详细设计</strong>：具体是如何实现功能的，使用伪代码实现相应的功能，每一个模块都要进行深入分析，分析之后要实现模块的伪代码。</p>
<p><strong>软件编码</strong>：将伪代码实现称能够运行的代码</p>
<p><em>上部分是后台程序开发人员进行操作的，下面的内容是由测试人员实现的</em></p>
<p><strong>单元测试</strong>：对程序中具有独立功能的代码块进行一个单元一个单元的测试，独立功能的代码块就是单元。</p>
<p><strong>集成测试</strong>:是在单元测试的基础上，通过单元模块组装成可以进行测试的小系统，检查模块之间的接口是否能够对的上，是否正确。</p>
<p><strong>系统测试</strong>：对整个产品直接进行测试，验证我们所开发出来的系统是否满足需求文档上的定义，还要验证系统的功能是否都实现了，系统的性能测试，性能功能一定要满足需求文档。</p>
<p><strong>验收测试</strong>：部署软件前的最后一个测试，保证我们的软件能够正常原型</p>
<pre><code>1. α测试：用户和测试人员，对测试不同的人员，开发人员等共同参与的内部测试，内侧通过才会上市（公测）。
2. β测试：
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720132730103.png" alt="image-20220720132730103"></p>
<h3 id="如何理解bug"><a href="#如何理解bug" class="headerlink" title="如何理解bug"></a>如何理解bug</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720133227239.png" alt="image-20220720133227239"></p>
<p>空间性能：软件运行耗费的系统资源，硬件资源，CPU，内存……</p>
<p>时间性能：软件的响应时间</p>
<p>功能测试：PostMan</p>
<p>性能测试：JMeter</p>
<p>手工测试：由测试人员一个一个测试用例的执行，看执行结果是否符合要求</p>
<p>自动化测试：可以模拟成大量的人员进行测试，测试高并发的性能</p>
<p><strong>单元测试、集成测试、黑盒、白盒、灰盒</strong></p>
<h4 id="重要的点"><a href="#重要的点" class="headerlink" title="重要的点"></a>重要的点</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720134557143.png" alt="image-20220720134557143"></p>
<p>只要软件项目已启动，软件测试也就是开始了。</p>
<h4 id="测试用例的设计："><a href="#测试用例的设计：" class="headerlink" title="测试用例的设计："></a>测试用例的设计：</h4><p> 测试用例包含的内容：标识符、测试项、输入说明、输出说明、环境要求、特殊要求、用例之间的依赖性。</p>
<h4 id="黑盒测试用例设计方法"><a href="#黑盒测试用例设计方法" class="headerlink" title="黑盒测试用例设计方法"></a>黑盒测试用例设计方法</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220720150954629.png" alt="image-20220720150954629"></p>
<p>黑盒测试的方法：</p>
<p>等价类划分法、边界值、因果法、判定法、场景法</p>
<p>白盒测试的方法：</p>
<p>语句覆盖、条件覆盖、分支覆盖、条件组合覆盖</p>
<p>● 对淘宝搜索框进行测试<br>参考回答：<br>一, 功能测试<br>\1. 输入关键字，查看: 返回结果是否准确，返回的文本长度需限制<br>1.1输入可查到结果的正常关键字、词、语句，检索到的内容、链接正确性；<br>1.2输入不可查到结果的关键字、词、语句；<br>1.3输入一些特殊的内容，如空、特殊符、标点符、极限值等，可引入等价类划分的方法等；<br>\2. 结果显示：标题，卖家，销售量，单行&#x2F;多行，是否有图片<br>\3. 结果排序：价格 销量 评价 综合<br>4.返回结果庞大时，限制第一页的现实量，需支持翻页<br>\5. 多选项搜索：关键字 品牌 产地 价格区间 是否天猫 是否全国购<br>\6. 是否支持模糊搜索，支持通配符的查询<br>7, 网速慢的情况下的搜索<br>\8. 搜索结果为空的情况<br>\9. 未登录情况和登录情况下的搜索（登录情况下 存储用户搜索的关键字&#x2F;搜索习惯）<br>二.性能测试：<br>1压力测试：在不同发用户数压力下的表现（评价指标如响应时间等）<br>2负载测试：看极限能承载多大的用户量同时正常使用<br>3稳定性测试：常规压力下能保持多久持续稳定运行<br>4内存测试：有无内存泄漏现象<br>5大数据量测试：如模拟从庞大的海量数据中搜索结果、或搜索出海量的结果后列示出来，看表现如何等等。<br>三. 易用性：交互界面的设计是否便于、易于使用<br>1依据不同的查询结果会有相关的人性化提示，查不到时告知？查到时统计条数并告知？有疑似输入条件错误时提示可能正确的输入项等等处理；<br>2查询出的结果罗列有序，如按点击率或其他排序规则，确保每次查询出的结果位置按规则列示方便定位，显示字体、字号、色彩便于识别等等；<br>3标题查询、全文检索、模糊查询、容错查询、多关键字组织查询（空格间格开）等实用的检索方式是否正常？<br>4输入搜索条件的控件风格设计、位置摆放是否醒目便于使用者注意到，有否快照等快捷查看方式等人性化设计？<br>四. 兼容性<br>1WINDOWS&#x2F;LINUX&#x2F;UNIX等各类操作系统下及各版本条件下的应用<br>2IE&#x2F;FIREFOX&#x2F;GOOGLE&#x2F;360&#x2F;QQ等各类浏览器下及各版本条件下、各种显示分辨率条件下的应用<br>3SQL&#x2F;ORACLE&#x2F;DB2&#x2F;MYSQL等各类数据库存储情况下的兼容性测试<br>4简体中文、繁体中文、英文等各类语种软件平台下的兼容性测试<br>5IPHONE&#x2F;IPAD、安卓等各类移动应用平台下的兼容性测试<br>6与各相关的监控程序的兼容性测试，如输入法、杀毒、监控、防火墙等工具同时使用<br>五. 安全性<br>1被删除、加密、授权的数据，不允许被SQL注入等攻击方式查出来的，是否有安全控制设计；<br>2录入一些数据库查询的保留字符，如单引号、%等等，造成查询SQL拼接出的语句产生漏洞，如可以查出所有数据等等，这方面要有一些黑客攻击的思想并引入一些工具和技术，如爬网等。<br>3通过白盒测试技术，检查一下在程序设计上是否存在安全方面的隐患；<br>4对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制；</p>
<h1 id="2022-7-21"><a href="#2022-7-21" class="headerlink" title="2022.7.21"></a>2022.7.21</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86/" data-id="cllwc4xix0018jsmof0gy52x9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-编译链接过程：" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.966Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++学习"></a>C++学习</h1><h2 id="C语言的两大重点：-和-const"><a href="#C语言的两大重点：-和-const" class="headerlink" title="C语言的两大重点：&amp; 和 const"></a><strong>C语言的两大重点：&amp; 和 const</strong></h2><p><strong>引用的作用就是给一个空间取上多个名字，对这些名字进行操作，都可以改变该空间的内容</strong></p>
<p><strong>1.引用没有空引用</strong></p>
<p><strong>2.引用必须初始化</strong></p>
<p><strong>3.没有引用的引用</strong>，<strong>引用不分级</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c=a;<span class="comment">//不能通过c改变a的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常引用：不能通过常引用改变所引用的空间"><a href="#常引用：不能通过常引用改变所引用的空间" class="headerlink" title="常引用：不能通过常引用改变所引用的空间"></a>常引用：不能通过常引用改变所引用的空间</h3><p><strong>引用也不能引用一个常变量，更不能引用一个常量</strong></p>
<p>在编译器编译时总是在向能力收缩的方向编译的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">10</span>,y=<span class="number">20</span>;</span><br><span class="line">    Swap(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inline函数（内联函数）：解决的是一些小的函数被反复调用而占用了大量的堆栈空间的问题。"><a href="#inline函数（内联函数）：解决的是一些小的函数被反复调用而占用了大量的堆栈空间的问题。" class="headerlink" title="inline函数（内联函数）：解决的是一些小的函数被反复调用而占用了大量的堆栈空间的问题。"></a>inline函数（内联函数）：解决的是一些小的函数被反复调用而占用了大量的堆栈空间的问题。</h2><p><strong>内联的处理方法是再函数的调用点处直接展开函数</strong>。在计算机系统中，频繁的调用会增加时间开销，内联函数的引入减少了函数调用过程中开栈和清栈的开销。</p>
<h2 id="默认值：在函数定义的时候直接给参数进行赋值"><a href="#默认值：在函数定义的时候直接给参数进行赋值" class="headerlink" title="默认值：在函数定义的时候直接给参数进行赋值"></a>默认值：在函数定义的时候直接给参数进行赋值</h2><p><strong>默认值只能从右往左进行赋值</strong></p>
<p><strong>默认值是在编译的时候被定义的，当发现函数没有给予实参时，编译器就会将默认值入栈</strong></p>
<p><strong>调用函数的时候，参数是从右向左结合的</strong></p>
<h2 id="函数的重载："><a href="#函数的重载：" class="headerlink" title="函数的重载："></a>函数的重载：</h2><p>C语言区分函数依靠函数名，C++区分函数通过函数原型（包括函数名，参数列表，函数的返回类型）</p>
<p>extern：外部关键字</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105143831696.png" alt="image-20220105143831696"></p>
<p><strong>为什么C++可以进行重载</strong>：因为C++编译的时候会进行重命名。使用了函数名称的粉碎技术，将返回类型，参数类型作为函数名的一部分。</p>
<p><strong>调用约定：</strong></p>
<p><strong>模板函数：   (在   <em>编译</em>   的时候直接识别参数类型，并在编译的时候进行重命名)<strong>模板是产生代码的代码，是在</strong>编译</strong>的时候生成代码。根据名字粉碎技术，进行不同类型的函数生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//tmmplate&lt;typename Type&gt;</span><br><span class="line">template&lt;class Type&gt;</span><br><span class="line">void Swap(Type&amp; a,Type&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    Type tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105172552756.png" alt="image-20220105172552756"></p>
<p>由上图可知，在程序编译的的时候会进行程序的推演。注意：<strong>模板不是宏的替换</strong>，而是名的重定义。</p>
<h2 id="new和malloc的区别："><a href="#new和malloc的区别：" class="headerlink" title="new和malloc的区别："></a>new和malloc的区别：</h2><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105173012394.png" alt="image-20220105173012394"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105173047648.png" alt="image-20220105173047648"></p>
<p>两者的区别是最基本的是，当malloc申请失败的时候，会给申请的对象置为空，但是new只会抛出异常，没有机会进行赋值为空。</p>
<p><strong>注意:new一个对象，就要delete一个对象，new ip&#x3D;new int[]; 就要delete[] ip</strong></p>
<h6 id="命名空间：解决全局变量名污染的问题，既重复命名的问题"><a href="#命名空间：解决全局变量名污染的问题，既重复命名的问题" class="headerlink" title="命名空间：解决全局变量名污染的问题，既重复命名的问题"></a>命名空间：解决全局变量名污染的问题，既重复命名的问题</h6><h2 id="面向对象（从现实世界向计算机世界的映射）"><a href="#面向对象（从现实世界向计算机世界的映射）" class="headerlink" title="面向对象（从现实世界向计算机世界的映射）"></a>面向对象（从现实世界向计算机世界的映射）</h2><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105174458553.png" alt="image-20220105174458553"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105174904632.png" alt="image-20220105174904632"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105175140644.png" alt="image-20220105175140644"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105183145090.png" alt="image-20220105183145090"></p>
<h3 id="对象的构成：每一个对象都有属性，但是方法是共享的。"><a href="#对象的构成：每一个对象都有属性，但是方法是共享的。" class="headerlink" title="对象的构成：每一个对象都有属性，但是方法是共享的。"></a>对象的构成：每一个对象都有属性，但是方法是共享的。</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106194025717.png" alt="image-20220106194025717"></p>
<p>​    在方案一的实现下，为每一个对象都分配了所有的属性和方法，非常的占用空间，但是不同的对象之间除了属性不同之外，其方法都是相同的，所以这样会浪费大量的空间去存储相同的内容。所以方案一相对来说实不可取的。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106194047039.png" alt="image-20220106194047039"></p>
<p>​    方案二，为每个对象都分配储存空间，但是只存储对象的属性，对象的方法放在公共代码区。但是这样就会出现一个问题，方法如何知道自己处理的是哪个对象？这就要在编译的时候下功夫了，在编译的时候，编译器会对类型进行改写分为以下三步：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106205310128.png" alt="image-20220106205310128"></p>
<p>编译器会为每个对象第一个参数，即为*this指向要处理的对象。</p>
<h3 id="编译器对类型的编译"><a href="#编译器对类型的编译" class="headerlink" title="编译器对类型的编译"></a>编译器对类型的编译</h3><p>step1、识别并找到属性成员，然后放到描述表里面</p>
<p>step2、开始对类里面的<strong>函数声明（函数原型）</strong>进行识别</p>
<p>step3、改写：函数的形参</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106194551101.png" alt="image-20220106194551101"></p>
<h3 id="什么是常方法：float-GetTotal-value（）-const；"><a href="#什么是常方法：float-GetTotal-value（）-const；" class="headerlink" title="什么是常方法：float GetTotal_value（） const；"></a>什么是常方法：float GetTotal_value（） const；</h3><p>改写之后：<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106201315875.png" alt="image-20220106201315875"></p>
<p>常方法只能对对象的属性进行读取，但是不能够进行改写。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106201504199.png" alt="image-20220106201504199"></p>
<h3 id="常对象只能调用常方法：编译器编译的时候是朝着能力收缩的方向进行的"><a href="#常对象只能调用常方法：编译器编译的时候是朝着能力收缩的方向进行的" class="headerlink" title="常对象只能调用常方法：编译器编译的时候是朝着能力收缩的方向进行的"></a>常对象只能调用常方法：编译器编译的时候是朝着能力收缩的方向进行的</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220107104247189.png" alt="image-20220107104247189"></p>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106205818465.png" alt="image-20220106205818465"></p>
<p><strong>有空间不一定有对象</strong></p>
<p><em><strong>生可带来而死不带去</strong>的对象：对象在被创建的时候会自动申请一个空间，但是在释放之后却不能带走空间。</em></p>
<h5 id="为什么空类的大小是1，不是0？：C语言有空间即可操作，但是有空间不一定有对象，所以有对象一定要有空间，"><a href="#为什么空类的大小是1，不是0？：C语言有空间即可操作，但是有空间不一定有对象，所以有对象一定要有空间，" class="headerlink" title="为什么空类的大小是1，不是0？：C语言有空间即可操作，但是有空间不一定有对象，所以有对象一定要有空间，"></a>为什么空类的大小是1，不是0？：C语言有空间即可操作，但是<strong>有空间不一定有对象</strong>，所以有对象一定要有空间，</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106213248907.png" alt="image-20220106213248907"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106214928095.png" alt="image-20220106214928095"></p>
<p><strong>C++中将常变量当做常量来看，在编译的时候会直接进行替换。</strong></p>
<p>不允许对局部变量以引用的形式进行返回。</p>
<p>当变量的生存期不受函数影响的时候可以通过引用进行返回。</p>
<p>为什么在等号运算符重载的时候不能使用列表赋值，因为使用列表赋值会再次构建一个对象，存在重复构建的现象，因此不可使用列表赋值。</p>
<p>当我们不想要其他的函数使用拷贝构造函数的时候，我们可以将拷贝构造函数值为private的，并删除掉函数体，或者将函数声明变成如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqLsit(<span class="type">const</span> SeqlISt* Seq)=delete</span><br></pre></td></tr></table></figure>

<p><strong>如果将构造函数置为私有，我们应该如何构造对象？</strong></p>
<p>一般情况下不要将析构函数设置为私有函数。</p>
<h4 id="输出运算符的重载："><a href="#输出运算符的重载：" class="headerlink" title="输出运算符的重载："></a>输出运算符的重载：</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121131558840.png" alt="image-20220121131558840"></p>
<p> 如果不希望实参来修改形参，我们可以将拷贝构造函数设置为私有，或者将拷贝构造函数删掉。如果使用引用来声明形参，就不要拷贝构造对象，那么拷贝构造函数是公有还是私有的都没有关系了。</p>
<p>全局函数不能声明为常方法，因为全局函数没有this指针。</p>
<p>静态成员变量不能在列表中初始化，只能在类外初始化。</p>
<p>类内声明的静态成员，是所有的类共享的成员。静态成员不占用类内空间，计算对象大小时，不计算静态成员的大小。                                                                                                                     </p>
<p>对静态成员的访问没有this指针</p>
<p>静态成员函数没有this指针，只能访问静态成员，不能访问非静态成员</p>
<h3 id="左值、右值、将亡值"><a href="#左值、右值、将亡值" class="headerlink" title="左值、右值、将亡值"></a>左值、右值、将亡值</h3><h5 id="以值的形式返回，会在栈中创建一个-临时对象来接受函数的返回值"><a href="#以值的形式返回，会在栈中创建一个-临时对象来接受函数的返回值" class="headerlink" title="以值的形式返回，会在栈中创建一个 临时对象来接受函数的返回值"></a>以值的形式返回，会在栈中创建一个 临时对象来接受函数的返回值</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304164455700.png" alt="image-20220304164455700"></p>
<h5 id="以引用的形式返回，底层是返回对象的地址，但是我们不能反回一个临时对象的地址，临时对象是一个不具名对象，也就是一个右值"><a href="#以引用的形式返回，底层是返回对象的地址，但是我们不能反回一个临时对象的地址，临时对象是一个不具名对象，也就是一个右值" class="headerlink" title="以引用的形式返回，底层是返回对象的地址，但是我们不能反回一个临时对象的地址，临时对象是一个不具名对象，也就是一个右值"></a>以引用的形式返回，底层是返回对象的地址，但是我们不能反回一个临时对象的地址，临时对象是一个不具名对象，也就是一个右值</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304164723124.png" alt="image-20220304164723124"></p>
<h6 id="左值引用只能引用具有名字的对象，右值引用只能引用无名的对象。"><a href="#左值引用只能引用具有名字的对象，右值引用只能引用无名的对象。" class="headerlink" title="左值引用只能引用具有名字的对象，右值引用只能引用无名的对象。"></a>左值引用只能引用具有名字的对象，右值引用只能引用无名的对象。</h6><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304164850510.png" alt="image-20220304164850510"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304164930972.png" alt="image-20220304164930972"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304165055611.png" alt="image-20220304165055611"></p>
<p>左值有地址，右值不能够取地址。</p>
<h5 id="什么时候右值变成了左值？"><a href="#什么时候右值变成了左值？" class="headerlink" title="什么时候右值变成了左值？"></a>什么时候右值变成了左值？</h5><p>当右值对象有名字的时候，右值就变成了左值，因为此时右值对象有地址</p>
<h3 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h3><h6 id="在表达式的运行过程中产生的不具有名字的对象（可能是自定义类型，也可能是内置类型），这样的对象叫做将亡值；将亡值的生存周期仅限于表达式的运行过程中，表达式执行完毕，将亡值的生存期结束。"><a href="#在表达式的运行过程中产生的不具有名字的对象（可能是自定义类型，也可能是内置类型），这样的对象叫做将亡值；将亡值的生存周期仅限于表达式的运行过程中，表达式执行完毕，将亡值的生存期结束。" class="headerlink" title="在表达式的运行过程中产生的不具有名字的对象（可能是自定义类型，也可能是内置类型），这样的对象叫做将亡值；将亡值的生存周期仅限于表达式的运行过程中，表达式执行完毕，将亡值的生存期结束。"></a>在表达式的运行过程中产生的<strong>不具有名字</strong>的对象（可能是自定义类型，也可能是内置类型），这样的对象叫做将亡值；将亡值的生存周期仅限于表达式的运行过程中，表达式执行完毕，将亡值的生存期结束。</h6><p>在程序的运行过程中不能以引用的形式返回一个局部对象，因为</p>
<h3 id="移动构造和移动赋值"><a href="#移动构造和移动赋值" class="headerlink" title="移动构造和移动赋值"></a>移动构造和移动赋值</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304170040553.png" alt="image-20220304170040553"></p>
<p><strong>使用移动构造和移动赋值，我们可减少对于堆区内存构造释放的次数</strong>。如果我们没有写移动构造，会优先调用普通构造，如果写了移动构造，就会优先调用 移动构造。当我们使用函数返回对象的时候，会构造临时对象，然后将临时对象返回进行赋值，使用移动构造会方便很多。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220304171106896.png" alt="image-20220304171106896"></p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><h3 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h3><h4 id="使用柔性数组构建String类型"><a href="#使用柔性数组构建String类型" class="headerlink" title="使用柔性数组构建String类型"></a>使用柔性数组构建String类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StrNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> ref;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">char</span> data[];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    StrNode* Pstr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    String(<span class="type">const</span> <span class="type">char</span>* p = <span class="literal">NULL</span>) :Pstr(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(p);</span><br><span class="line">            Pstr = (StrNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StrNode) + len * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            Pstr-&gt;ref = <span class="number">1</span>;</span><br><span class="line">            Pstr-&gt;len = len;</span><br><span class="line">            Pstr-&gt;size = len * <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(Pstr-&gt;data, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="type">const</span> String&amp; s) :Pstr(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.Pstr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Pstr = s.Pstr;</span><br><span class="line">            Pstr-&gt;ref += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Pstr-&gt;ref == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] Pstr-&gt;data;</span><br><span class="line">            Pstr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Pstr-&gt;ref--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用柔性数组构建String （当然可能还可以构建其他类型，还未探索，使用字符串的应该都可以），</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220308210417709.png" alt="image-20220308210417709"></p>
<h3 id="友元函数（友元函数破坏了函数的封装性）"><a href="#友元函数（友元函数破坏了函数的封装性）" class="headerlink" title="友元函数（友元函数破坏了函数的封装性）"></a>友元函数（友元函数破坏了函数的封装性）</h3><p>1.不具有自反性（A是B的友元，B不一定是A的友元）</p>
<p>2.不具有传递性（A是B的友源，B是C的友源，A和C没有关系）</p>
<p>3.不具有继承性（）</p>
<h4 id="将外部函数声明为类的友元函数，就可以通过友元函数访问类的私有成员"><a href="#将外部函数声明为类的友元函数，就可以通过友元函数访问类的私有成员" class="headerlink" title="将外部函数声明为类的友元函数，就可以通过友元函数访问类的私有成员"></a>将外部函数声明为类的友元函数，就可以通过友元函数访问类的私有成员</h4><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>类的静态成员只能在类外进行初始化，所有对象共用同一个静态成员</p>
<p>一般将静态成员设置为私有</p>
<p>因为静态成员不依赖于对象，所以不能在类中访问静态成员变量</p>
<p>静态成员变量不属于任何一个对象，所有的对象共用同一个静态成员变量</p>
<h4 id="当局部函数包含静态成员时，编译器在编译的时候就会将静态成员变量的定义提出来，直接在数据区给其赋值。"><a href="#当局部函数包含静态成员时，编译器在编译的时候就会将静态成员变量的定义提出来，直接在数据区给其赋值。" class="headerlink" title="当局部函数包含静态成员时，编译器在编译的时候就会将静态成员变量的定义提出来，直接在数据区给其赋值。"></a>当局部函数包含静态成员时，编译器在编译的时候就会将静态成员变量的定义提出来，直接在数据区给其赋值。</h4><p>拿常量初始化静态变量和拿变量初始化静态变量，在底层的实现上是不同的，那常量初始化时，在编译期就会将静态成员进行初始化；拿变量对静态变量初始化 时，在编译期编译器会为静态成员在数据区开辟一块空间并设有一个标志位，当标志位为0时可以进行初始化并将标志位置为1，当标志位为1时就不可以进行初始化了。<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307203539603.png" alt="image-20220307203539603"><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307203613672.png" alt="image-20220307203613672"></p>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><h4 id="静态函数能否访问静态成员？"><a href="#静态函数能否访问静态成员？" class="headerlink" title="静态函数能否访问静态成员？"></a>静态函数能否访问静态成员？</h4><p>静态成员函数由于没有this指针，<strong>所以他只能访问静态成员，不能访问非静态成员</strong></p>
<h4 id="如果非要用静态成员函数访问非静态成员怎么办？"><a href="#如果非要用静态成员函数访问非静态成员怎么办？" class="headerlink" title="如果非要用静态成员函数访问非静态成员怎么办？"></a>如果非要用静态成员函数访问非静态成员怎么办？</h4><p>将非静态成员变量当做参数传入静态成员函数，就可以通过静态成员函数访问非静态成员变量了‘</p>
<h5 id="静态函数可以通过类名直接访问，也可以通过对象名进行访问"><a href="#静态函数可以通过类名直接访问，也可以通过对象名进行访问" class="headerlink" title="静态函数可以通过类名直接访问，也可以通过对象名进行访问"></a>静态函数可以通过类名直接访问，也可以通过对象名进行访问</h5><h5 id="不具有this指针的方法，都不能定义为常方法。"><a href="#不具有this指针的方法，都不能定义为常方法。" class="headerlink" title="不具有this指针的方法，都不能定义为常方法。"></a>不具有this指针的方法，都不能定义为常方法。</h5><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private：</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> Object instance;</span><br><span class="line">public:</span><br><span class="line">    Object(<span class="type">int</span> num = <span class="number">0</span>):value(num);</span><br><span class="line">    Object(<span class="type">const</span> Object&amp; obj) = delete;</span><br><span class="line">    Object&amp; operator=(<span class="type">const</span> Object&amp; obj) = delete;</span><br><span class="line"></span><br><span class="line">    Object&amp; <span class="title function_">GteInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> insttance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object <span class="title function_">Object::instance</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funa</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Object&amp; obja = Object::Getinstance();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;obja&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funb</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Object&amp; obja = Object::GetInstance();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;objb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    thread <span class="title function_">thra</span><span class="params">(funa)</span>;</span><br><span class="line">    thread <span class="title function_">thrb</span><span class="params">(funb)</span>;</span><br><span class="line">    thra.join();</span><br><span class="line">    thrb.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在什么时候要用到这个单例模式：当我们的系统只允许建立一个对象的的时候就需要用到单例模式；"><a href="#在什么时候要用到这个单例模式：当我们的系统只允许建立一个对象的的时候就需要用到单例模式；" class="headerlink" title="在什么时候要用到这个单例模式：当我们的系统只允许建立一个对象的的时候就需要用到单例模式；"></a>在什么时候要用到这个单例模式：当我们的系统只允许建立一个对象的的时候就需要用到单例模式；</h4><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p><strong>模板实参推演在编译时期</strong></p>
<p><strong>类模板中的函数都是模板函数，这些模板函数被调用的时候才会被实例化</strong></p>
<p>类型萃取的时候，我们的函数必须是public的</p>
<h3 id="常方法和普通方法"><a href="#常方法和普通方法" class="headerlink" title="常方法和普通方法"></a>常方法和普通方法</h3><p>当普通方法中，有对函数成员的改动，那么我们的常方法就不能调用普通方法。因为我们的常方法中，this指针是不可改的，但是当我们要调用普通方法的时候，要对this指针进行改变，这是不被允许的，所以，<strong>是不可以用常方法调用普通方法的</strong>。</p>
<p><strong>常思考：每一个函数存在的意义在哪儿？</strong></p>
<h3 id="继承和面向对象"><a href="#继承和面向对象" class="headerlink" title="继承和面向对象"></a>继承和面向对象</h3><p>继承机制是面向对象是代码可以复用的重要手段。体现了由简单到复杂的认识过程。</p>
<p>多态性是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。<strong>函数的重载，运算符的重载，属于编译时的多态性。</strong>以虚函数为基础的运行时的多态性是面向对象的程序设计的标志性特征。体现了类推和比喻的思想方法。</p>
<h5 id="早期绑定（函数的重载，运算符的重载）：在编译时期就确定了调用关系，就是早期绑定。"><a href="#早期绑定（函数的重载，运算符的重载）：在编译时期就确定了调用关系，就是早期绑定。" class="headerlink" title="早期绑定（函数的重载，运算符的重载）：在编译时期就确定了调用关系，就是早期绑定。"></a>早期绑定（函数的重载，运算符的重载）：在编译时期就确定了调用关系，就是早期绑定。</h5><h5 id="晚绑定（以虚函数为基础的运行时多态）：在程序运行时期才能确定函数的调用关系。"><a href="#晚绑定（以虚函数为基础的运行时多态）：在程序运行时期才能确定函数的调用关系。" class="headerlink" title="晚绑定（以虚函数为基础的运行时多态）：在程序运行时期才能确定函数的调用关系。"></a>晚绑定（以虚函数为基础的运行时多态）：在程序运行时期才能确定函数的调用关系。</h5><p>struct是一个数据的集合，class是一个对象的抽象；struct默认为公有，class默认为私有。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A&#123;&#125;;<span class="comment">//此时为公有继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span>A&#123;&#125;;<span class="comment">//此时是公有继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;&#125;:<span class="comment">//此时默认为私有</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>：<span class="title">A</span>&#123;</span>&#125;;<span class="comment">//此时默认为私有</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：当我们的派生类为class声明时，无论基类是struct声明还是class声明，都缺省为私有继承；当我们的派生类为struct声明时，无论基类是struct声明还是class声明，都缺省为公有继承</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在继承关系中，当使用派生类构建对象时，应该先构建基类对象；当析构派生生类对象是，也是先析构派生类对象再析构基类对象。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318142814716.png" alt="image-20220318142814716"></p>
<p>上图base对象其实有三个成员，除了它本身的sum和fib之外还有一个隐藏的父对象。这种关系是在运行的时候才被确定的，所以属于运行时多态。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318143135084.png" alt="image-20220318143135084"></p>
<p>在继承关系中，保护属性被看做公有，派生类<strong>不可以</strong>访问基类的<strong>私有成员</strong>，可以访问保护和共有成员。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318160528489.png" alt="image-20220318160528489"></p>
<p>在看待继承这个问题的上，<strong>我们可以在编译时期假设在派生类中的继承就是给派生类设置一个隐藏基类对象****（实际上这个过程是发生在程序的运行期间，但是为了便于理解我们先这么理解），</strong>私有继承的情况下，赋予派生类的就是一个私有的隐藏父对象，我们的派生类依旧可以访问基类对象的成员（除了私有成员），这与公有、私有还是保护继承是没有关系的。**</p>
<p><strong>总结：无论任何继承关系，我们子类对象中的方法可以访问隐藏父对象中的保护和公有属性。</strong></p>
<p>当我们在派生类当中，声明了一个基类的有名对象之后，此<strong>有名对象</strong>和继承来的<strong>隐藏父对象</strong>（无名对象）两者是有一定区别的，在编译过程中，我们的派生类的成员函数可以访问无名对象的除私有成员外的所有成员，但是派生类的成员函数却只能访问<strong>有名基类对象</strong>的公有成员。<strong>二者的差别主要处在protected上</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318174334373.png" alt="image-20220318174334373"></p>
<p>在上面的代码中，aa是一个公有地基类对象，此时我们的派生类的成员方法是可以访问aa的保护和公有成员，但是main是一个外部函数，所以在main函数中，我们不可以通过b对象来访问b.aa.ay(其是一个基类的保护成员）</p>
<p><strong>这里我们要弄清楚的一点是，外部函数只能访问对象的公有成员，不能访问<em>保护和私有成员</em>。</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220318180040018.png" alt="image-20220318180040018"></p>
<p>当我们的派生类的成员变量和基类的成员变量同名时，会发生同名隐藏，采取就近原则，那个离得近就适用男一个。——-&gt;<strong>同名隐藏</strong></p>
<p>当我们的派生类的成员函数和基类的成员函数同名时，我们通过派生类对象直接访问的函数是派生类自己的，要想访问基类同名的方法，就需要加上积累的作用域。<strong>也是同名隐藏的一种</strong></p>
<p>公有继承意味着“是一个”；</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125163515762.png" alt="image-20220125163515762"></p>
<p> 只能把子给父，不能父给给子</p>
<h5 id="切片现象："><a href="#切片现象：" class="headerlink" title="切片现象："></a>切片现象：</h5><p>当我们将派生类对象赋值给基类对象的时候，就会发生切片现象，也就是派生对象只会将自己的隐藏父对象的部分赋值给基类对象。这就是切片现象</p>
<p>构造和析构具有继承性，拷贝构造不具有继承性。</p>
<h3 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220320203758279.png" alt="image-20220320203758279"></p>
<h5 id="实现运行时多态要满足三个条件："><a href="#实现运行时多态要满足三个条件：" class="headerlink" title="实现运行时多态要满足三个条件："></a>实现运行时多态要满足三个条件：</h5><ol>
<li><p>类的继承关系为公有继承public，因为公有继承代表是一个的意思</p>
</li>
<li><p>使用虚函数，virutal</p>
</li>
<li><p>在派生类中，使用指针或者引用调用虚函数才能完成运行时多态</p>
</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220320204105125.png" alt="image-20220320204105125"></p>
<p>不允许在类的声明中不加虚函数关键字，在类的定义中声明虚函数关键字。</p>
<p><strong>当某个类的成员函数被定义为虚函数时，在这个类的派生类当中都保持虚函数的特征</strong></p>
<h4 id="设置虚函数的注意事项"><a href="#设置虚函数的注意事项" class="headerlink" title="设置虚函数的注意事项"></a>设置虚函数的注意事项</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220320210658640.png" alt="image-20220320210658640"></p>
<p>当一个类当中有虚函数时，就会产生一个虚函数表，有虚表指针指向他。虚函数表的大小为：</p>
<p>在一个继承关系当中只有一个虚表指针和一个虚表，在每个不同类型中虚表中的内容不同。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220320221524821.png" alt="image-20220320221524821"></p>
<h4 id="同名隐藏：发生在编译和链接的过程中"><a href="#同名隐藏：发生在编译和链接的过程中" class="headerlink" title="同名隐藏：发生在编译和链接的过程中"></a>同名隐藏：发生在编译和链接的过程中</h4><p>当我们的派生类在些方法的时候，新的方法和基类方法同名同返回值，但是不同参数列表的时候，我们在编译的时候将基类的同名方法进行隐藏，如果要进行调动，需要在运行的时候进行明确的声名，才能进行准确的调动。</p>
<p><strong>上述问题告诉我们再写虚函数的时候，一定要保持三同</strong></p>
<p>刘伟—设计模式</p>
<p>何为裸指针：直接用类型名声明的指针就是裸指针。裸指针无法判断是指针指向的是单个对象还是一组对象。</p>
<h3 id="C-中的智能指针"><a href="#C-中的智能指针" class="headerlink" title="C++中的智能指针"></a><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220325090259378.png" alt="image-20220325090259378">C++中的智能指针</h3><h4 id="什么是RAII："><a href="#什么是RAII：" class="headerlink" title="什么是RAII："></a>什么是RAII：</h4><p>使用局部对象来管理资源的技术成为资源获取及初始化；我们有一些资源是操作系统中优先的资源，如内存，套接字，信号量等等，因为我们在使用这些资源的时候往往会为了忘记使用完毕之后进行释放而造成未知的错误。解决这个问题的方法就是：RAII</p>
<p>利用局部对象调用时产生，调用完毕被销毁的特性去完成RAII。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    Student(<span class="type">const</span> <span class="built_in">string</span> name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>) :s_name(name), s_age(age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Init a Studetn!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destory a Studetn!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="type">const</span> <span class="built_in">string</span>&amp; <span class="title function_">get_name</span><span class="params">()</span><span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> <span class="title function_">getage</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> s_age; &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">const</span> <span class="built_in">string</span> s_name;</span><br><span class="line">    <span class="type">int</span> s_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Student <span class="title function_">s</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fun();<span class="comment">//要强调的是局部对象的RAII，调用时会产生一个对象，函数调用完毕就会自动销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220325121230688.png" alt="image-20220325121230688"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">namespace qwq</span><br><span class="line">&#123;</span><br><span class="line">    template&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> _Ty element_type;<span class="comment">//说实话我不知道这句有什么用</span></span><br><span class="line">        <span class="comment">//explicit有效阻止裸指针隐式转换为auto_ptr指针</span></span><br><span class="line">        explicit <span class="title function_">auto_ptr</span><span class="params">(_Ty* _P = <span class="literal">NULL</span>)</span> :_<span class="title function_">Own</span><span class="params">(_P != <span class="literal">NULL</span>)</span>, <span class="title function_">Ptr</span><span class="params">(_P)</span> &#123;&#125;</span><br><span class="line">        <span class="built_in">auto_ptr</span>(<span class="type">const</span> <span class="built_in">auto_ptr</span>&lt;_Ty&gt;&amp; _Y) :_Owns(_Y._Owns), _Ptr(_Y.release()) &#123;&#125;</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;_Ty&gt;&amp; operator=(<span class="type">const</span> <span class="built_in">auto_ptr</span>&lt;_Ty&gt;&amp; _Y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (this != &amp;_Y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_Ptr != _Y.get())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_Owns)</span><br><span class="line">                    &#123;</span><br><span class="line">                        delete _Ptr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">auto_ptr</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_Owns)</span><br><span class="line">            &#123;</span><br><span class="line">                delete _Ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _Ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Ty&amp; operator*()<span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (*get());</span><br><span class="line">        &#125;</span><br><span class="line">        _Ty* operator-&gt;()<span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Ty* <span class="title function_">get</span><span class="params">()</span><span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (_Ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        _Ty* <span class="title function_">release</span><span class="params">()</span><span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            ((uto_ptr &lt; _Ty) * this)-&gt;_Owns = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> _Ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        <span class="type">bool</span> _Owns;</span><br><span class="line">        _Ty* _Ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个auto_ptr不能同时拥有两个对象，所以在进行拷贝构造和复制操作的时候要注意对象的所有权问题。</p>
<p><strong>因为一个auto_ptr被拷贝或者赋值后，已经失去了对象的所有权这个时候，在对auto_ptr的操作就是不安全的，这种操作隐蔽的情形出现在将auto_ptr作为参数按值传递，因为这种情况太隐蔽了，容易出错，所以要避免auto_ptr作为函数参数 按值传递</strong></p>
<h3 id="编译链接过程："><a href="#编译链接过程：" class="headerlink" title="编译链接过程："></a>编译链接过程：</h3><h4 id="磁盘：永久化储存，I-o慢"><a href="#磁盘：永久化储存，I-o慢" class="headerlink" title="磁盘：永久化储存，I&#x2F;o慢"></a>磁盘：永久化储存，I&#x2F;o慢</h4><h4 id="内存：支持程序运行的真实空间（分为物理内存和虚拟内存）"><a href="#内存：支持程序运行的真实空间（分为物理内存和虚拟内存）" class="headerlink" title="内存：支持程序运行的真实空间（分为物理内存和虚拟内存）"></a>内存：支持程序运行的真实空间（分为物理内存和虚拟内存）</h4><h5 id="物理内存：内存条，I-O快"><a href="#物理内存：内存条，I-O快" class="headerlink" title="物理内存：内存条，I&#x2F;O快"></a>物理内存：内存条，I&#x2F;O快</h5><h5 id="虚拟内存：不是内存—-是磁盘—-交换空间-当物理内存不够用的饿时候，将数据暂且置换到虚拟内存当中"><a href="#虚拟内存：不是内存—-是磁盘—-交换空间-当物理内存不够用的饿时候，将数据暂且置换到虚拟内存当中" class="headerlink" title="虚拟内存：不是内存—-是磁盘—-交换空间-&gt;当物理内存不够用的饿时候，将数据暂且置换到虚拟内存当中"></a>虚拟内存：不是内存—-是磁盘—-交换空间-&gt;当物理内存不够用的饿时候，将数据暂且置换到虚拟内存当中</h5><h4 id="虚拟地址空间：系统逻辑上给到每个进程的执行空间"><a href="#虚拟地址空间：系统逻辑上给到每个进程的执行空间" class="headerlink" title="虚拟地址空间：系统逻辑上给到每个进程的执行空间"></a>虚拟地址空间：系统逻辑上给到每个进程的执行空间</h4><p>​            程序执行的时候，系统会为每一个进程划分一个执行空间（4G）。</p>
<h4 id="程序执行过程："><a href="#程序执行过程：" class="headerlink" title="程序执行过程："></a>程序执行过程：</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118170746439.png" alt="image-20211118170746439"></p>
<p>虚拟地址空间的划分：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118172255332.png" alt="image-20211118172255332"></p>
<p>.bss 段存储没有初始化或者初始化为0的段</p>
<p>.data 段存储有初始化或者初始化不为0的段</p>
<p><strong>虚拟地址空间只是将二进制可执行文件当中相应的段读取到虚拟地址空间当中来，并非是在程序执行的时候才进行划分的</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211118173741604.png" alt="image-20211118173741604"></p>
<p>二进制可重定位文件中，bss段只用做到向下传递信息。</p>
<p>​    1.bss 段不进行真实存储，那么如何标记这些数据的存在？</p>
<p><em><strong>使用符号表进行标记</strong></em></p>
<p>​    2.bss段的大小为20个字节，但是理论上bss段存储了6个int型数据应该是24个字节，那么还有4个字节去哪儿了？</p>
<hr>
<p>符号表会存储符号：</p>
<p>数据和函数名都会生成符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data；<span class="comment">//没有放在bss段，只是做了COM标记</span></span><br><span class="line">    <span class="comment">//弱符号：没有初始化的非静态数据，弱符号会在链接的过程中被同名的强符号替代</span></span><br></pre></td></tr></table></figure>

<p>指令一旦生成就不会变</p>
<p>链接之后就没有弱符号了</p>
<p>虚拟地址空间只是进行逻辑限定，真实储存在内存当中</p>
<p>虚拟地址空间映射到真实内存上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9A/" data-id="cllwc4xji001kjsmof93tf0fr" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-笔试题汇总；" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%AC%94%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%9B/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.956Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>枚举类型：可以进行显示的赋值，也可以对其中某一变量进行单独赋值；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下情况，没有被初始化的枚举成员，第一个成员将被初始化为0，然后后面的成员依次比前面的成员大1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">num</span>=</span>&#123;</span><br><span class="line">first,</span><br><span class="line">second = <span class="number">0</span>,</span><br><span class="line">third, </span><br><span class="line">forth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *p1; </span><br><span class="line">unsigned long *p2; </span><br><span class="line">p1 = (unsigned char *)0x801000; </span><br><span class="line">p2 = (unsigned long *)0x810000; </span><br><span class="line"></span><br><span class="line">那么p1+5=？p2+5 =?</span><br></pre></td></tr></table></figure>

<p>上述表示中，1代表一个单位量，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 + 5 = 0x801000 + 5* sizeof(unsigned char) = 0x801000+5;</span><br><span class="line">p2 + 5 =0x801000+5*sizeof(unsigned long) = 0x801000+5*4=0x801000+20=0x801014</span><br></pre></td></tr></table></figure>


<p>其中全局变量和静态局部变量是从静态存储区中划分的空间，</p>
<p>二者的区别在于作用域的不同，全局变量作用域大于静态局部变量（只用于声明它的函数中）</p>
<p>基础四大件：</p>
<p>操作系统、数据库、数据结构、计算机网络。</p>
<p>把计算机数当做字典来看，哪里不会看哪里</p>
<p>lamda函数，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%AC%94%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%9B/" data-id="cllwc4xj5001djsmof3mw2o92" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-八股文之C++语言1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%85%AB%E8%82%A1%E6%96%87%E4%B9%8BC++%E8%AF%AD%E8%A8%801/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.942Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="被free回收的内存是立即返还给操作系统吗？"><a href="#被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="被free回收的内存是立即返还给操作系统吗？"></a>被free回收的内存是立即返还给操作系统吗？</h3><p>不是的，被free回收的内存会首先被<strong>ptmalloc</strong>使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用，占用过多的系统资源</strong>。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h3 id="宏定义和函数有何区别"><a href="#宏定义和函数有何区别" class="headerlink" title="宏定义和函数有何区别"></a>宏定义和函数有何区别</h3><ul>
<li>宏定义在预处理阶段就完成了替换，在之后被替换的文本参加编译，相当于直接插入了代码，不存在函数调用，执行起来更快；函数调用，需要开辟栈帧，在运行需要时跳转到具体的调用函数。</li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型；</li>
<li>宏定义不需要在最后加分号</li>
</ul>
<h3 id="在传递函数参数时，什么时候该用指针，什么时候改用引用呢？"><a href="#在传递函数参数时，什么时候该用指针，什么时候改用引用呢？" class="headerlink" title="在传递函数参数时，什么时候该用指针，什么时候改用引用呢？"></a>在传递函数参数时，什么时候该用指针，什么时候改用引用呢？</h3><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。</li>
<li>对栈空间大小比较敏感（比如递归）的时候用引用。使用引用传递不需要创建临时变量，开销更小。</li>
<li>类对象作为参数传递的时候要使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h3 id="常量指针和指针常量的区别"><a href="#常量指针和指针常量的区别" class="headerlink" title="常量指针和指针常量的区别"></a>常量指针和指针常量的区别</h3><ul>
<li><strong>指针常量是一个指针，读成常量的指针，指向一个只读变量</strong>，也就是后面所指明的int const 和const int，都是一个常量，可以写作int const* p 或者 const int *p;</li>
<li><strong>常量指针是一个不能改变指向的指针</strong>。指针是个常量，必须初始化，一旦完成初始化，他的值（也就是存放在指针中的地址）就不能改变，既不能中途改变指向，如int* const p；</li>
</ul>
<h3 id="C-和C语言的区别"><a href="#C-和C语言的区别" class="headerlink" title="C++和C语言的区别"></a>C++和C语言的区别</h3><ul>
<li>动态分配内存的函数不同</li>
<li>C++有string类取代了C函数库头文件中的字符数组处理函数</li>
<li>C++使用iostrean替换了C语言中的stdio.h头文件</li>
<li>C++可以重载，C语言不行</li>
<li>C++中有引用，C语言没有</li>
<li>二者都不能重复定义变量，C++可以随时随地定义变量，C语言只能在函数开头定义变量。</li>
<li>C++增加了以下关键字：如using，dynamic_cast，namespace等等。</li>
</ul>
<h2 id="C-与Java的区别"><a href="#C-与Java的区别" class="headerlink" title="C++与Java的区别"></a>C++与Java的区别</h2><p><strong>语言特性</strong></p>
<ul>
<li>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</li>
<li>Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</li>
<li>C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果</li>
<li>Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性</li>
</ul>
<p><strong>垃圾回收</strong></p>
<ul>
<li>C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放</li>
<li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）</li>
<li>Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架</li>
<li>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</li>
</ul>
<h3 id="C-中的struct和class的区别"><a href="#C-中的struct和class的区别" class="headerlink" title="C++中的struct和class的区别"></a>C++中的struct和class的区别</h3><p><strong>相同点</strong></p>
<ul>
<li>两者都拥有成员函数、公有和私有部分</li>
<li>任何可以使用class完成的工作都可以使用struct完成。</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>两者如果都不对成员指定公私有，struct默认是公有的，class默认是私有的</li>
<li>class默认是private继承，struct默认是public继承</li>
</ul>
<h3 id="C-中const和static的作用"><a href="#C-中const和static的作用" class="headerlink" title="C++中const和static的作用"></a>C++中const和static的作用</h3><p><strong>static</strong></p>
<ul>
<li>不考虑类的情况<ul>
<li>隐藏：所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li>
<li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但是不能使用</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>static成员变量：只与类关联不与类的对象关联。定义是需要分配空间，不能在类的声明中初始化，必须在类的定义体外部初始化，初始化是不需要表示为static；可以被非static成员函数任意访问。</li>
<li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<em><strong><em>不能被声明为const、虚函数和volatile</em>；可以被非static成员函数任意访问。</strong></em></li>
</ul>
</li>
</ul>
<p><strong>const</strong></p>
<ul>
<li>不考虑类的情况<ul>
<li>const常量在定义时必须初始化，之后无法更改</li>
<li>const形参可以接收const和非const类型的实参，例如&#x2F;&#x2F; i 可以是 int 型或者 const int 型void fun(const int&amp; i){	&#x2F;&#x2F;…}</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li>
</ul>
</li>
</ul>
<p>补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</p>
<h2 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h2><p><strong>override</strong></p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写；重写虚函数的时候加上override，如果在基类中找不到要重写的类就会错</p>
<p><strong>final</strong></p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。给某个函数或者某个类加上final关键字后该函数或者类就不可以再被继承，再被继承就会报错。</p>
<h2 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h2><ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>;<span class="comment">//语句1 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span></span><br><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>;<span class="comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line">string str4 = str1;<span class="comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了</p>
<p>（语句1和语句3等价），但是需要辨别两种情况。</p>
<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<h2 id="volatile、mutable和explicit关键字的用法"><a href="#volatile、mutable和explicit关键字的用法" class="headerlink" title="volatile、mutable和explicit关键字的用法"></a>volatile、mutable和explicit关键字的用法</h2><p>(1)<strong>volatile</strong></p>
<p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p>
<p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p>
<p><strong>volatile 指针</strong></p>
<p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p>
<p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpch;<span class="keyword">volatile</span> <span class="type">char</span>* vpch;</span><br></pre></td></tr></table></figure>

<p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> pchc;<span class="type">char</span>* <span class="keyword">volatile</span> pchv; </span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li>
<li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li>
<li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li>
</ul>
<p><strong>多线程下的volatile</strong></p>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p>
<p>（2）<strong>mutable</strong></p>
<p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> <span class="type">const</span><span class="comment">//在函数里不可修改this指针指向的值 常量指针</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        m_A=<span class="number">10</span>;<span class="comment">//错误  不可修改值，this已经被修饰为常量指针</span></span><br><span class="line">        m_B=<span class="number">20</span>;<span class="comment">//正确</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> person p;<span class="comment">//修饰常对象 不可修改类成员的值</span></span><br><span class="line">p.m_A=<span class="number">10</span>;<span class="comment">//错误，被修饰了指针常量</span></span><br><span class="line">p.m_B=<span class="number">200</span>;<span class="comment">//正确，特殊变量，修饰了mutable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>explicit</strong></p>
<p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上</li>
<li>explicit 关键字作用于单个参数的构造函数</li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%85%AB%E8%82%A1%E6%96%87%E4%B9%8BC++%E8%AF%AD%E8%A8%801/" data-id="cllwc4xi1000qjsmocing0aye" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-WebServer编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/WebServer%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.932Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是网络服务器（web-server）？"><a href="#什么是网络服务器（web-server）？" class="headerlink" title="什么是网络服务器（web server）？"></a>什么是网络服务器（web server）？</h2><p>网络服务器就是指一个服务器程序或者一台运行服务器程序的计算机。主要功能是通过http协议和客户端（通常是浏览器（browser））进行通信，来接受存储，处理来自客户端的http请求，并对其做出http响应，返回给客户端请求的内容或者返回错误信息。</p>
<h2 id="用户如何与你的web服务器进行通信"><a href="#用户如何与你的web服务器进行通信" class="headerlink" title="用户如何与你的web服务器进行通信"></a>用户如何与你的web服务器进行通信</h2><p>通常用户使用web浏览器与相应的服务器进行通信。在浏览器中输入<strong>域名</strong>或者相应的<strong>IP地址：端口号</strong>，浏览器就会将你输入的域名解析为相应的 IP地址 或者直接根据你的IP地址向请求对应的服务器发送一个</p>
<p>http请求。这一过程首先需要通过TCP协议的三次握手建立与目标服务器的连接，然后http协议对目标web服务器的http请求报文，通过tcp&#x2F;ip协议发送到目标Web服务器上。</p>
<h2 id="Web服务器如何接受客户端发来的http请求？"><a href="#Web服务器如何接受客户端发来的http请求？" class="headerlink" title="Web服务器如何接受客户端发来的http请求？"></a>Web服务器如何接受客户端发来的http请求？</h2><p>通过socket监听来自用户的请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建监听socket文件描述符</span></span><br><span class="line"><span class="type">int</span> lisetenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建监听socket的TCP/IP的IPV4地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;address,<span class="built_in">sizeof</span>(address));</span><br><span class="line"></span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">/*将套接字绑定到所有可用的接口*/</span></span><br><span class="line">address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//SO_REUSEADDR,允许端口被重复使用</span></span><br><span class="line"> <span class="built_in">setsockopt</span>(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;flag，<span class="built_in">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定socket和他的监听地址</span></span><br><span class="line">ret = <span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;address,<span class="built_in">sizeof</span>(address));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建监听队列以存放客户端的连接请求，在这些客户端被accept之前</span></span><br><span class="line"> ret = <span class="built_in">listen</span>(listenfd,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h5 id="注意：每当有新的连接请求进入监听队列，我们都需要告诉我们的Web服务器有链接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。我们在处理请求的同时还要兼顾到监听其他的客户端的请求并分配其他的逻辑单元（线程）来处理（并发问题，同时处理多个事件）。"><a href="#注意：每当有新的连接请求进入监听队列，我们都需要告诉我们的Web服务器有链接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。我们在处理请求的同时还要兼顾到监听其他的客户端的请求并分配其他的逻辑单元（线程）来处理（并发问题，同时处理多个事件）。" class="headerlink" title="注意：每当有新的连接请求进入监听队列，我们都需要告诉我们的Web服务器有链接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。我们在处理请求的同时还要兼顾到监听其他的客户端的请求并分配其他的逻辑单元（线程）来处理（并发问题，同时处理多个事件）。"></a>注意：每当有新的连接请求进入监听队列，我们都需要告诉我们的Web服务器有链接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。我们在处理请求的同时还要兼顾到监听其他的客户端的请求并分配其他的逻辑单元（线程）来处理（并发问题，同时处理多个事件）。</h5><h5 id="我们使用epoll这种I-O复用技术来实现对socket（listenfd-和链接socket-客户请求-的同时监听。注意I-O复用虽然可以监听多个文件描述符，但是I-O复用本身是阻塞的；并且当有多个文件描述符同时就绪时，如果不采取额外的措施，程序只能顺序处理每一个文件描述符，所以为了提高效率，可以使用线程池来实现并发，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理？"><a href="#我们使用epoll这种I-O复用技术来实现对socket（listenfd-和链接socket-客户请求-的同时监听。注意I-O复用虽然可以监听多个文件描述符，但是I-O复用本身是阻塞的；并且当有多个文件描述符同时就绪时，如果不采取额外的措施，程序只能顺序处理每一个文件描述符，所以为了提高效率，可以使用线程池来实现并发，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理？" class="headerlink" title="我们使用epoll这种I&#x2F;O复用技术来实现对socket（listenfd)和链接socket(客户请求)的同时监听。注意I&#x2F;O复用虽然可以监听多个文件描述符，但是I&#x2F;O复用本身是阻塞的；并且当有多个文件描述符同时就绪时，如果不采取额外的措施，程序只能顺序处理每一个文件描述符，所以为了提高效率，可以使用线程池来实现并发，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理？"></a>我们使用epoll这种I&#x2F;O复用技术来实现对socket（listenfd)和链接socket(客户请求)的同时监听。注意I&#x2F;O复用虽然可以监听多个文件描述符，但是I&#x2F;O复用本身是阻塞的；并且当有多个文件描述符同时就绪时，如果不采取额外的措施，程序只能顺序处理每一个文件描述符，所以为了提高效率，可以使用线程池来实现并发，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理？</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/WebServer%E7%BC%96%E7%A8%8B/" data-id="cllwc4xh9000cjsmogv979ae3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-tuple与list的区别在于，tuple初始化之后就不可修改" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/tuple%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%EF%BC%8Ctuple%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.921Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>tuple与list的区别在于，tuple初始化之后就不可修改</p>
<p>注意：tuple中只有一个元素的话，后面要加逗号：X&#x3D;(3,)</p>
<p>tuple中的元素也不是一定不可变得，如果tuple中包含list元素，那么list元素是可以变得。</p>
<p>map：映射</p>
<p>dict：字典，查找速度很高，如果用dict实现一个“名字”-“成绩”的对照表，可以直接根据名字进行查找成绩，不管表有多大，查找的速度都是很快的。</p>
<p>dict内部存放的顺序和key放入的顺序是没有关系的。</p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个别名</p>
<p>设置默认参数的时候有几点要注意：</p>
<ol>
<li>必选参数前。默认参数在后，</li>
<li>如何设置默认参数：当有多个参数时，把变化大的参数放在前面，变化小的放后面。变化小的参数就可以作为默认参数。</li>
</ol>
<p>使用功能默认参数最大的好处就是能降低调用函数的难度。</p>
<p>默认参数必须指向不变对象！不便对象包括int，string，float，tuple，None</p>
<p>（x,y ）&#x3D;(y,x);</p>
<p>tmp &#x3D; x;</p>
<p>x &#x3D;y;</p>
<p>y &#x3D; tmp ;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/tuple%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%EF%BC%8Ctuple%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9/" data-id="cllwc4xhq000jjsmo2ot1dztu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-String类型的加等" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/String%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8A%A0%E7%AD%89/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.914Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/String%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8A%A0%E7%AD%89/" data-id="cllwc4xh3000bjsmo8uijc4o6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>