<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-容器：" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%AE%B9%E5%99%A8%EF%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.263Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h2><h3 id="顺序容器：vector，list，deque"><a href="#顺序容器：vector，list，deque" class="headerlink" title="顺序容器：vector，list，deque"></a>顺序容器：vector，list，deque</h3><p>vector:底层是一个一维数组，扩容方式以1.5倍进行扩容</p>
<p>list：链表</p>
<p>deque:底层是一个二维数组（使用的时候将其当做一个队列）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push(i);</span><br><span class="line">&#125;</span><br><span class="line">    v.pop_back();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    v.swap(v1);<span class="comment">//交换两个容器内的数据</span></span><br><span class="line">    v.clear();</span><br><span class="line">    v.empty();</span><br><span class="line">    v.resize(<span class="number">10</span>);</span><br><span class="line">    v.reserve(<span class="number">10</span>);</span><br><span class="line">    v.size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v1.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v1[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">vector</span>::iterator it=v1.begin();</span><br><span class="line">    <span class="keyword">for</span>(;it!=v1.end();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">&quot;    &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增删改查</p>
<h3 id="迭代器-指向容器内部的一个指针"><a href="#迭代器-指向容器内部的一个指针" class="headerlink" title="迭代器:指向容器内部的一个指针"></a>迭代器:指向容器内部的一个指针</h3><p>正向迭代：iterator；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;:: iterator it=v1.begin();    end()</span><br></pre></td></tr></table></figure>

<p>反向迭代器：reverse_iterator;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::reverse_iterator it=v1.rbegin();    rend()</span><br></pre></td></tr></table></figure>

<p>常量迭代器：const_iterator;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::const_iterator it=v1.cbegin();  cend()</span><br></pre></td></tr></table></figure>

<p>插入型迭代器：insert_iterator;&#x2F;&#x2F;内部调用的是insert（）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert_iterator&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; it(v1,v1.begin());</span><br><span class="line"><span class="keyword">for</span>(;it!=v1.end()；++it)</span><br><span class="line">&#123;</span><br><span class="line">    *it=i+<span class="number">100</span>;<span class="comment">//在指定位置插入一个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%AE%B9%E5%99%A8%EF%BC%9A/" data-id="cllwbvs9z0013d4modd018crt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-爬虫" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%88%AC%E8%99%AB/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.255Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>robots.txt协议</strong>：</p>
<p>    君子协议。规定了那些网站的数据可以备爬取，那些数据不能被爬取。</p>
<p>    可以遵守也可以不遵守。</p>
<p><strong>http协议和HTTPS协议</strong></p>
<p><strong>http协议;</strong></p>
<p>       概念：服务器与客户端交互的一种形式。</p>
<p>常用的请求头信息：</p>
<ul>
<li><p>User-agent:请求载体的身份标识</p>
</li>
<li><p>Connection：表示请求完毕后是否保持连接</p>
</li>
</ul>
<p>             </p>
<p>常用的响应头信息：</p>
<ul>
<li>      Content-type：服务器响应客户端的数据类型</li>
</ul>
<p>HTTPS协议：安全的超文本传输协议</p>
<p>数据加密的方式：</p>
<p>    对称的秘钥加密</p>
<p>    非对称的秘钥加密</p>
<p>    证书的秘钥加密</p>
<h3 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h3><p>    基于网络请求等两个模块</p>
<p>       urllib 模块（古老麻烦，繁琐复杂）</p>
<p>        request模块：python中原生的网络请求模块，功能非常强大，简单便捷，效率很高。</p>
<p>    作用：用来模拟浏览器发请求。</p>
<p>    如何使用（request模块的编码流程）：</p>
<p>            -1.指定URL</p>
<p>            -2.对指定的URL发起请求（GET&#x2F;POST）</p>
<p>            -3.获取响应数据</p>
<p>            -4.持久化存储</p>
<p>    环境安装：</p>
<p>            winget install requests</p>
<p>    代码编写：</p>
<p>            需求：想要爬取搜狗首页的页面数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;目标url 网址&#x27;</span><br><span class="line"></span><br><span class="line">#get方法会返回一个响应对象</span><br><span class="line">response = requests.get(url=url)</span><br><span class="line"></span><br><span class="line">#response.text返回的就是字符串形式的响应数据</span><br><span class="line">page_text = response.text              </span><br><span class="line">print(page_text)</span><br><span class="line"></span><br><span class="line">with open(&#x27;./sougou.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp</span><br><span class="line">    fp.write(page_text)</span><br><span class="line">print(&#x27;爬取数据结束！！！&#x27;)      </span><br></pre></td></tr></table></figure>

<p>巩固编写：</p>
<p>    1. 实现一个简易的数据采集器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;https://www.sogou.com/web&#x27;</span><br><span class="line"></span><br><span class="line">#处理URL携带的参数：将URL携带的参数封装到字典中</span><br><span class="line">kw = input(&#x27;enter a word&#x27;)</span><br><span class="line">param=&#123;</span><br><span class="line">   ’query‘:kw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get方法会返回一个响应对象,将参数加到请求当中</span><br><span class="line">response = requests.get(url=url,params=param)</span><br><span class="line"></span><br><span class="line">#response.text返回的就是字符串形式的响应数据</span><br><span class="line">page_text = response.text              </span><br><span class="line"></span><br><span class="line">fileName = kw+&#x27;.html&#x27;</span><br><span class="line">with open(fileName,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp</span><br><span class="line">    fp.write(page_text)</span><br><span class="line">print(&#x27;爬取数据结束！！！&#x27;)  </span><br></pre></td></tr></table></figure>

<p>        反爬机制：</p>
<p>                UA检测：User-Agent（请求载体的身份标识），门户网站会检测对应请求的身份       标识，如果请求载体身份标识某一款浏览器就说明该请求是一个正常的请求。如果检测到载体身份标识不是基于某一款浏览器的，则表示不正常请求。</p>
<p>        反反扒策略：UA为伪装——让爬虫对应的请求载体身份伪装成某一款浏览器            </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%88%AC%E8%99%AB/" data-id="cllwbvsae0019d4mo15kx94ep" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-内存池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%86%85%E5%AD%98%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.245Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>内存池</p>
<p>操作系统</p>
<p>TCP&#x2F;IP计算机网络</p>
<p>数据结构</p>
<p>将虚拟地址转成物理地址</p>
<p>高效C++ </p>
<p>深度探索C++模型</p>
<p>线程池：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%86%85%E5%AD%98%E6%B1%A0/" data-id="cllwbvs9c000td4mogucm854t" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面向对象与面向过程的区别？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.237Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-面向对象与面向过程的区别？"><a href="#1-面向对象与面向过程的区别？" class="headerlink" title="1. 面向对象与面向过程的区别？"></a>1. 面向对象与面向过程的区别？</h3><p>​		首先我们知道面向对象和面向过程是两种不同的编程模式，那么二者的区别在于，在编程的时候所围绕的中心不同。</p>
<p>​		面向过程是围绕<strong>功能</strong>和<strong>逻辑</strong>来编程，而面向对象是围绕<strong>数据</strong>和<strong>对象</strong>来编程。</p>
<p>​		要讨论二者的区别，可以从以下四方面来来进行讨论：</p>
<ol>
<li><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>面向对象的编程更加安全，因为它将程序数据的访问都隐藏在了对象的方法当中，外部无法直接访问数据；而面向过程没有合适的方式来隐藏程序数据。</p>
</li>
<li><h5 id="程序设计上"><a href="#程序设计上" class="headerlink" title="程序设计上"></a>程序设计上</h5><p>在程序设计上，面向过程将解决一件事情分为一个个函数，通过不同的函数完成不同的功能，在通过一定的逻辑运行，已完成一件事；面向对象是创造一个个的对象，每个对象都有自己独特的属性和方法，通过对象与对象之间的关系来解决问题。</p>
</li>
<li><h5 id="编程过程"><a href="#编程过程" class="headerlink" title="编程过程"></a>编程过程</h5><p>面向过程是自上而下的编程，面向对象是自下而上的编程；</p>
</li>
<li><h5 id="程序修改"><a href="#程序修改" class="headerlink" title="程序修改"></a>程序修改</h5><p>面向对象更容易进行修改，更好添加功能。</p>
</li>
</ol>
<p><u><em>再向面试官回答这个问题的时候，可以通过举例子来进行回答。例如我们要完成将大象装进冰箱这件事，如果是以面向过程的方法，那么这件事就可分为以下几步：1. 打开冰箱门 2. 将大象装进去 3. 关上冰箱门 。只需要写出对应功能的函数即可，然后按照一定的逻辑运行即可完成这件事。  但是如果我们使用面向对象的方法，那么此事就变成了两个对象之间的关系，我们将大象抽象成一个大象类，将冰箱抽象成一个冰箱类，关门开门，装东西等都是冰箱类的一个方法，再用冰箱类实例化一个冰箱对象，调用装东西的方法，就可以将大象装进冰箱了</em></u></p>
<ul>
<li><h4 id="如果面试官问：什么是面向对象呢？"><a href="#如果面试官问：什么是面向对象呢？" class="headerlink" title="如果面试官问：什么是面向对象呢？"></a>如果面试官问：什么是面向对象呢？</h4><p>面向对象是一种编程方式，使用抽象的方式将现实世界的某一类东西抽象成一个类，在用这个类去实例化对象，该对象就是电脑对于现实世界的映射。世界万物都可以抽象成类，我们在现实世界当中的每一件事也都可以看成是对象与对象之间的关系，通过调用对象的方法来完成某事情，就是面向对象的编程方法。</p>
<p>面向对象具有四大特性：抽象，封装，继承和多态；</p>
</li>
</ul>
<h3 id="2-Linux的内存管理机制，进程管理机制？"><a href="#2-Linux的内存管理机制，进程管理机制？" class="headerlink" title="2.Linux的内存管理机制，进程管理机制？"></a>2.Linux的内存管理机制，进程管理机制？</h3><ul>
<li><h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><p>使用虚拟内存管理机制，用户程序看到的所有内存都是虚拟的，Linux系统将所有的内存都以页为单位进行划分，每页大小为4k，每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换。当程序所访问的内存在物理内存上不存在时就会产生一个页面错误，并将控制权交给内核。</p>
<p>Linux内核对于程序访问的内存地址会进行检查，如果这个地址对于程序来说是可用的，内核就会确定需要向程序提供哪一个物理内存页面。然后，如果该页面之前从未被写入过，内核就直接分配他，如果他已经被保存在硬盘的交换空间上，内核就读取包含数据的内存页面到物理内存上（可能需要把一个已有的页面置换出硬盘）接着完成虚拟地址向物理地址的转换之后，内核允许用户程序继续运行。</p>
<p>每个在linux系统上运行的程序都有自己的内存映像，不停地程序看到的内存映像是不同的。只有操作系统知道物理内存是如何安排的，操作系统不仅为应用程序提供内存管理，也为用户程序提供彼此之间的隔离保护。</p>
</li>
<li><h4 id="进程管理机制"><a href="#进程管理机制" class="headerlink" title="进程管理机制"></a>进程管理机制</h4><ul>
<li><p>进程定义</p>
<p>进程的基本定义是，在操作系统的虚拟地址空间运行的一个程序，从操作系统角度看，在操作系统上运行的一切程序都属于进程。</p>
<p>程序和进程的区别在于，进程虽然有程序产生，但他本身并不是进程，程序是由一系列进程指令的集合，一个程序可以运行一个或者多个进程，同时程序之占用磁盘空间，并不占用系统运行资源，进程只占用内存空间，是动态的可变的，关闭进程，所占用的内存空间随之被释放。</p>
</li>
<li><p>进程分类</p>
<p>进程可以分为两个大类</p>
<p>系统进程：可以执行的内存分配和系统资源管理等工作；而且系统进程不受用户干预，即使是root用户也不能干预系统进程的运行</p>
<p>用户进程：在自身的虚拟地址空间运行的一个独立的程序，从操作系统的角度来看，所有在系统上运行的东西，都可以称为一个进程。</p>
<p>用户进程又可以分为三小类</p>
<ul>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>交互进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>守护进程：守护进程是一直运行的一种进程，经常在linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的crond进程，这个进程类似与windows的计划任务，可以周期性的执行用户设定的某些任务。</li>
</ul>
</li>
<li><p>进程实体</p>
<p>进程 &#x3D; PCB＋程序 + 数据</p>
<ul>
<li><p>PCB：进程控制</p>
<p>进程控制块是进程存在的唯一标识；描述进程的基本情况和运行状态；操作系统对进程的管理信息都保存在PCB中。</p>
<ul>
<li><p>组成</p>
<p>进程描述信息：进程PID和进程归属UID</p>
<p>进程控制和管理信息：进程优先级和进程当前状态</p>
<p>处理机信息：CPU中各个寄存器的值</p>
<p>资源分配信息：内存地址信息，IO设备信息。</p>
</li>
</ul>
<p>PCB在进程创建时创建，由OS进行管理并常驻内存， 最后由OS回收</p>
</li>
<li><p>程序段</p>
<p>指令集，多个进程可以运行于同一个程序</p>
</li>
<li><p>数据段</p>
<p>进程运行所需要的数据。</p>
<p>数据包括</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始数据</span><br><span class="line">中间数据</span><br><span class="line">结果数据</span><br><span class="line">局部变量</span><br><span class="line">全局变量：全局变量对于同一个进程是一个相同变量，对于不同进程时不同变量</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>进程的特性</p>
<ul>
<li>并发性：一段时间多个进程可以并发执行</li>
<li>独立性：每一个进程都是独立的运行单元，能独立地运行&#x2F;接受资源&#x2F;接受调度</li>
<li>异步性：进程按不同的速度各自超不可预知的方向运行，进程不可复现</li>
</ul>
</li>
<li><p>进程的组织方式</p>
<p>进程的组织方式就是PCB的组织方式，有两种，分别是队列方式和索引方式</p>
<ul>
<li><p>队列方式</p>
<p>按照进程状态不同分为多个不同的队列，有OS持有各队列的指针</p>
</li>
<li><p>索引方式</p>
<p>按照进程状态的不同分为多个不同的索引，由OS持有各索引的指针</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-路由器工作原理？"><a href="#3-路由器工作原理？" class="headerlink" title="3.路由器工作原理？"></a>3.路由器工作原理？</h3><p>每台路由器都有两种功能：转发和路由选择</p>
<h3 id="4-如何实现多客户端连接时，同时下载的问题？"><a href="#4-如何实现多客户端连接时，同时下载的问题？" class="headerlink" title="4.如何实现多客户端连接时，同时下载的问题？"></a>4.如何实现多客户端连接时，同时下载的问题？</h3><p>多个客户端连接到服务器，都要进行下载操作，那么服务端对于多个客户端的请求就要进行多线程处理，每个线程负责不同的客户端。因为是多个客户端访问服务器，下载文件，所以服务器内部要开启多线程，便于接受客户端信息后，向客户端发送文件的操作。</p>
<h3 id="5-有下载的同时，还有人要删除，怎么解决？"><a href="#5-有下载的同时，还有人要删除，怎么解决？" class="headerlink" title="5.有下载的同时，还有人要删除，怎么解决？"></a>5.有下载的同时，还有人要删除，怎么解决？</h3><p>添加一个缓存目录，在有客户端需要下载的时候，服务器将需要下载的文件移入缓存队列，然后就不影响其他的客户端进行其他操作。</p>
<h3 id="6-STL常见容器的底层数据结构"><a href="#6-STL常见容器的底层数据结构" class="headerlink" title="6.STL常见容器的底层数据结构"></a>6.STL常见容器的底层数据结构</h3><ul>
<li><p>vector:向量</p>
<p>底层是一个数组</p>
<ul>
<li><p>头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; a; <span class="comment">//最常用， 定义一个不定长的数组</span></span><br><span class="line">vector &lt;string&gt; <span class="built_in">a</span>(<span class="number">4</span>); <span class="comment">//定义一个长度为4的string数组</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">10</span>,<span class="number">3</span>);<span class="comment">// 定义一个长度为十的数组，并且每个元素初始化为3</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; a[<span class="number">10</span>]; <span class="comment">//定义了十个vector数组，相当于二维数组（一维变长）</span></span><br><span class="line">vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; a ;<span class="comment">//定义一个二维数组（二维变长）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">size</span>();<span class="comment">//返回数组的大小</span></span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//返回a是否为空，空返回true</span></span><br><span class="line">a.<span class="built_in">clear</span>() ;<span class="comment">//清空数组，队列没有这个函数</span></span><br><span class="line">a.<span class="built_in">front</span>(); <span class="comment">//返回数组的第一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回数组的最后一个元素</span></span><br><span class="line">a.<span class="built_in">push_back</span>() ;<span class="comment">//在数组的最后插入一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//将数组的最后一个元素弹出</span></span><br><span class="line">a.<span class="built_in">begin</span>() / a.<span class="built_in">end</span>() ;<span class="comment">//支持迭代器，首尾元素的迭代器</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">666</span>)  ;<span class="comment">//在a[2]的位置插入666这个数，原来位置上的数以及后面的数向右顺移，时间复杂度为0(n)</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">2</span>， a.<span class="built_in">begin</span>() + <span class="number">4</span>);  <span class="comment">// erase(first,last)即删除 [ first , last) 内的所有元素，时间复杂度为0(n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) cout &lt;&lt; a[i];  <span class="comment">//利用数组下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) cout &lt;&lt; x; <span class="comment">// 范围遍历</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i ++) cout &lt;&lt; *i;<span class="comment">//迭代器遍历，i相当于一个指针，输出时解引用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i ++) cout &lt;&lt; *i;<span class="comment">//迭代器遍历，上一种的简化写法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">s.<span class="built_in">erase</span>(end_unique, s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p><strong>注：所有的容器都可以使用size（）和empty（）函数，并且时间复杂度为O(1)</strong></p>
<p><strong>注：所有的容器都可使用auto进行遍历</strong></p>
</li>
</ul>
</li>
<li><p>list ：链表</p>
<p>底层为链表</p>
<ul>
<li><p>头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; l;<span class="comment">//构造一个不定长的链表</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">L</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 初始化20个空间，初始值全为0</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">L</span><span class="params">(n,elem)</span></span>; <span class="comment">//初始化20个空间，初始值为1</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">L</span><span class="params">(a.begin(),b,end())</span></span>; <span class="comment">// 将a的起始迭代器和中止迭代器之间的内容当v的初始值（包含起始迭代器，不包含终止迭代器）</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">L</span><span class="params">(a)</span></span>; <span class="comment">//拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">assign</span>(n,elem);<span class="comment">//将n个elem值赋值</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());<span class="comment">//将begin到end之间的值赋值</span></span><br><span class="line">a.<span class="built_in">front</span>();<span class="comment">//返回第一个值</span></span><br><span class="line">a.<span class="built_in">end</span>();<span class="comment">//返回最后一个值</span></span><br><span class="line">a.<span class="built_in">size</span>();<span class="comment">//返回容量</span></span><br><span class="line">a.<span class="built_in">empty</span>();<span class="comment">//判空</span></span><br><span class="line">a.<span class="built_in">resize</span>(num , elem);<span class="comment">//重置容量大小为num，多余的空间社初值为elem</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="type">int</span> num); <span class="comment">// 设置容量为num</span></span><br><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//	尾加</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//	头加</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//	尾删</span></span><br><span class="line"><span class="built_in">pop_front</span>()	;<span class="comment">//头删</span></span><br><span class="line"><span class="built_in">insert</span>(pos,a)	;<span class="comment">//向pos迭代器指向的位置插入a</span></span><br><span class="line"><span class="built_in">insert</span>(pos,a,elem)	;<span class="comment">//向pos迭代器指向的位置插入a个elem</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end)	;<span class="comment">//在pos指向的地方插入[beg,end)区间内的内容</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//	删除pos指向的元素</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//	清除[beg,end)的内容</span></span><br><span class="line"><span class="built_in">clear</span>()	;<span class="comment">//清空元素</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//	删除所有与elem值匹配的内容</span></span><br><span class="line"><span class="built_in">unique</span>();<span class="comment">//	删除容器中相邻的重复元素，只留下一个</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//	反转链表</span></span><br><span class="line"><span class="built_in">sort</span>(fun);<span class="comment">//	排序，默认升序，成员函数（所有不支持随机访问迭代器的容器都不能用标准算法），可用fun指明排序规则</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>queue：队列</p>
</li>
<li><p>stack：栈</p>
</li>
<li><p>string：字符串</p>
</li>
<li><p>deque：双端数组</p>
</li>
<li><p>unordered_set：集合</p>
</li>
<li><p>unordered_map：字典</p>
</li>
<li><p>pair：对组</p>
</li>
</ul>
<h3 id="7-编译链接的过程"><a href="#7-编译链接的过程" class="headerlink" title="7.编译链接的过程"></a>7.编译链接的过程</h3><p>预编译</p>
<p>编译</p>
<p>链接</p>
<p>运行</p>
<h3 id="8-常见的数据结构及算法-的时间复杂度"><a href="#8-常见的数据结构及算法-的时间复杂度" class="headerlink" title="8.常见的数据结构及算法 的时间复杂度"></a>8.常见的数据结构及算法 的时间复杂度</h3><h3 id="9-Linux操作系统的内存和进程管理机制"><a href="#9-Linux操作系统的内存和进程管理机制" class="headerlink" title="9.Linux操作系统的内存和进程管理机制"></a>9.Linux操作系统的内存和进程管理机制</h3><h3 id="10-fork的内核源码实现"><a href="#10-fork的内核源码实现" class="headerlink" title="10.fork的内核源码实现"></a>10.fork的内核源码实现</h3><h3 id="11-epoll的内核源码实现"><a href="#11-epoll的内核源码实现" class="headerlink" title="11.epoll的内核源码实现"></a>11.epoll的内核源码实现</h3><h3 id="12-Linux多进程和多线程编程"><a href="#12-Linux多进程和多线程编程" class="headerlink" title="12.Linux多进程和多线程编程"></a>12.Linux多进程和多线程编程</h3><h3 id="13-OSI七层网络模型，"><a href="#13-OSI七层网络模型，" class="headerlink" title="13.OSI七层网络模型，"></a>13.OSI七层网络模型，</h3><h3 id="14-Http协议"><a href="#14-Http协议" class="headerlink" title="14.Http协议"></a>14.Http协议</h3><h3 id="15-路由器的工作原理，交换机的工作原理"><a href="#15-路由器的工作原理，交换机的工作原理" class="headerlink" title="15.路由器的工作原理，交换机的工作原理"></a>15.路由器的工作原理，交换机的工作原理</h3><h3 id="16-TCP-IP协议"><a href="#16-TCP-IP协议" class="headerlink" title="16.TCP&#x2F;IP协议"></a>16.TCP&#x2F;IP协议</h3><h3 id="17-UDP协议"><a href="#17-UDP协议" class="headerlink" title="17.UDP协议"></a>17.UDP协议</h3><h3 id="18-数据库事务处理及优化"><a href="#18-数据库事务处理及优化" class="headerlink" title="18.数据库事务处理及优化"></a>18.数据库事务处理及优化</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" data-id="cllwbvsbz001td4mo9i6l11u4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-两数相除" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.218Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p><strong>题目描述：</strong></p>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，<em>要求不使用乘法、除法和 mod 运算符。</em></p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2</p>
<p><strong>思路：</strong></p>
<p>我们要计算两个数相除的商，但是又不能使用乘除法和取模运算，那么就只能使用加法、减法或者位运算了。</p>
<p>我们知道，可以使用加法模拟乘法，使用减法模拟除法，位运算可以模拟乘2或者除2的运算；</p>
<p>在模拟之前我们还需要考虑几点特殊的问题：</p>
<ul>
<li><p>整数限定的范围是32位，那么其取值范围就是 -2^31 — 2^31-1;</p>
</li>
<li><p>因为负数的范围比较大，当商为2^31时，会发生越界，所以我们可以通过同号为正，异号为负的方法确定结果的正负，然后将所有的正数转化为负数来求解。</p>
</li>
<li><p>正值运算还好说，遇到负值运算，如果被除数是-2^31 ，除数是-1，直接相除的话会产生越界的结果；所以要注意几个特殊值：</p>
<ul>
<li>当divisor &#x3D;&#x3D; INT_MIN时 ：<ul>
<li>如果INT_MIN &#x3D;&#x3D; dividend ，直接返回 1;</li>
<li>如果是其他值，直接返回0；</li>
</ul>
</li>
<li>当dividend &#x3D;&#x3D; 0时，不管divisor是多少，都直接返回0；</li>
<li>当dividend &#x3D;&#x3D;  INT_MIN时：<ul>
<li>如果divisor &#x3D;&#x3D; -1，直接返回INT_MAX;</li>
<li>divisor &#x3D;&#x3D; 1 ，我们可以直接返回INT_MIN;</li>
</ul>
</li>
</ul>
</li>
<li><p>除此之外，如果我们每次循环都只减一次divisor那么遇到特殊情况，时间复杂度将会非常高，例如dividend &#x3D; 214836748，divisor &#x3D; 3的情况，就需要减很多次。那么就需要采用一种方法去降低时间复杂度，我这里用的是倍增法：</p>
<ul>
<li><p>每次增加一倍的方法去减，时间复杂度就变成了log dividend；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的A和B都是负数，比较方法和正数正好相反</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当被除数不够除时的操作</span></span><br><span class="line">    <span class="keyword">if</span>(a &gt;= b) <span class="keyword">return</span> a &gt; b ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;<span class="comment">//经过上面的判断，dividend至少可以减一次divisor</span></span><br><span class="line">    <span class="type">int</span> tb = b;<span class="comment">//当做减数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 用来存储结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(a &lt; tb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//被除数每减一次除数，就要计数一次</span></span><br><span class="line">        a -= tb;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//使用倍增法降低时间复杂度</span></span><br><span class="line">        tb += tb;</span><br><span class="line">        count += count;</span><br><span class="line">    &#125;</span><br><span class="line">    res = count;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="built_in">helper</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法是写完了，但是上面的算法在我验证的时候出了点儿错误，那就是当除数大于-2^31&#x2F;2的时候，无疑出现这种情况，我们的结果就是1，但是算法没法直接得出判断，他还是会执行tb+&#x3D;tb这一步，如果此时我们使用倍增法，那么就会产生overflow的错误。</p>
<p>如何解决呢？再写一个特例？不不不，我们的特例已经足够多了，我们只需要在执行tb +&#x3D; tb之前再来一次判断即可，因为要执行tb +&#x3D; tb 的目的是，为了降低时间复杂度，那么只需要判断a还能否再减tb,如果可以，在执行下面的条件，如果不行就跳出，如此即可完美解决问题；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend,<span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(divisor == <span class="number">1</span>)<span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(divisor == INT_MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dividend == INT_MIN) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((dividend  &gt;<span class="number">0</span> &amp;&amp;divisor &gt; <span class="number">0</span>) || (dividend &lt;<span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dividend = dividend &gt; <span class="number">0</span> ? -dividend : dividend;</span><br><span class="line">        divisor = divisor &gt; <span class="number">0</span> ? -divisor : divisor;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">helper</span>(dividend,divisor);</span><br><span class="line">        <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? ans : -ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= b) <span class="keyword">return</span> a &gt; b ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tb = b;</span><br><span class="line">        <span class="keyword">while</span>(a &lt; tb)</span><br><span class="line">        &#123;</span><br><span class="line">            a -= tb;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a &lt; tb)</span><br><span class="line">            &#123;</span><br><span class="line">                tb += tb;</span><br><span class="line">                count += count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res = count;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="built_in">helper</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>下面是官方给出的解法：</p>
<p>使用二分查找法：</p>
<p>思路：由于我们只能使用 3232 位整数，因此二分查找中会有很多细节。</p>
<p>首先，二分查找的下界为 11，上界为 2^31−1。唯一可能出现的答案为 2^31的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 2^31−1。如果二分查找失败，那么答案一定为 0。</p>
<p>在实现「快速乘」时，我们需要使用加法运算，然而较大的 ZZ 也会导致加法运算溢出。例如我们要判断 A+B 是否小于 C 时（其中 A,B,C 均为负数），A+B 可能会产生溢出，因此我们必须将判断改为 A&lt;C−B 是否成立。由于任意两个负数的差一定在 [−2^31,2^31−1][−2^31+1,2^31−1] 范围内，这样就不会产生溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="type">int</span> y, <span class="type">int</span> z, <span class="type">int</span> x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> check = <span class="built_in">quickAdd</span>(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/" data-id="cllwbvs8q000kd4mobykp5oj9" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-理想汽车面试笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%90%86%E6%83%B3%E6%B1%BD%E8%BD%A6%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.204Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="给定四个点，求这四个点所围成的图形面积？"><a href="#给定四个点，求这四个点所围成的图形面积？" class="headerlink" title="给定四个点，求这四个点所围成的图形面积？"></a>给定四个点，求这四个点所围成的图形面积？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeekArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先想到的是特殊情况，这四个点只是一个点 | 这四个点在同一条直线上</p>
</li>
<li><p>这四个点构成一个三角形</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用海伦公式求解</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>这四个点都成一个四边形</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将四边形拆成两个三角形，在利用海伦公式求解</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="那么解题思路就来了，首先我们需要判断这四个点可以构成一个什么样的图形，其次在进行求解；"><a href="#那么解题思路就来了，首先我们需要判断这四个点可以构成一个什么样的图形，其次在进行求解；" class="headerlink" title="那么解题思路就来了，首先我们需要判断这四个点可以构成一个什么样的图形，其次在进行求解；"></a>那么解题思路就来了，首先我们需要判断这四个点可以构成一个什么样的图形，其次在进行求解；</h5><h6 id="那么我们如何进行区分呢？"><a href="#那么我们如何进行区分呢？" class="headerlink" title="那么我们如何进行区分呢？"></a>那么我们如何进行区分呢？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断四个点在一条直线上,没有围成图形，面积为0，返回-1</span></span><br><span class="line"><span class="keyword">if</span>((point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">0</span>][<span class="number">2</span>] &amp;&amp; point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">0</span>][<span class="number">3</span>])||(point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; point[<span class="number">0</span>][<span class="number">0</span>] == point[<span class="number">3</span>][<span class="number">0</span>]))&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"><span class="comment">//当四个点构成三角形时，利用海伦公式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下的只能是四边形了，拆成两个三角形来做</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太麻烦了，这里只理清思路，代码不写了。</p>
<p><em>海伦公式：</em>s&#x3D;sqrt(p*(p-a)(p-b)(p-c))**</p>
<p>已知两点（x1,y1）,(x2,y2)如何求边长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">double dis_calculate(vec2d_t *point, vec2d_t *line_point_1, vec2d_t *line_point_2)&#123;</span><br><span class="line">    /*处理斜率不存在的情况*/</span><br><span class="line">    if (line_point_1-&gt;x_ == line_point_2-&gt;x_) &#123;</span><br><span class="line">        return fabs(point-&gt;x_ - line_point_1-&gt;x_);</span><br><span class="line">    &#125;</span><br><span class="line">    double k, b;/*y=kx+b*/</span><br><span class="line">    k = (line_point_2-&gt;y_ - line_point_1-&gt;y_) / (line_point_2-&gt;x_ - line_point_1-&gt;x_);</span><br><span class="line">    b = line_point_2-&gt;y_ - line_point_2-&gt;x_ * k;</span><br><span class="line">    </span><br><span class="line">    double res = fabs(k*point-&gt;x_-point-&gt;y_ + b) / sqrt(k*k+1);</span><br><span class="line"> </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针是不能相加的，因为相加得出的数字毫无意义，但是可以相减，如果两个指针指向一个数组，则相减的结果是两个指针之间元素的数目。</strong></p>
<h4 id="给定两个string类型的数字，输出它们之和？"><a href="#给定两个string类型的数字，输出它们之和？" class="headerlink" title="给定两个string类型的数字，输出它们之和？"></a>给定两个string类型的数字，输出它们之和？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">NumToSum</span><span class="params">(string Num1,string Num2)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始考虑不周全，以为这道题就一般简单，但其实要考虑的比较多，</p>
<ul>
<li>首先字符串不是int数据，且没有直接将字符串转换为int数据的API函数，故不能使用直接相加法；</li>
<li>第二，要考虑字符串的位数不同，在计算的时候要注意</li>
<li>第三，不能简单地使用str[i]+str[j],因为str[i]是char类型的数据，当进行相加时实际上是ascall码的加法，最后的结果肯定不是想要的结果</li>
<li>第四，也是非常重要的，要注意进位。</li>
</ul>
<h4 id="那么我们的问题来了，应该如何将string的数据转为int型的数据呢？"><a href="#那么我们的问题来了，应该如何将string的数据转为int型的数据呢？" class="headerlink" title="那么我们的问题来了，应该如何将string的数据转为int型的数据呢？"></a>那么我们的问题来了，应该如何将string的数据转为int型的数据呢？</h4><ol>
<li><h5 id="最简单的方法：使用stoi-函数和to-string-函数进行两次转换！"><a href="#最简单的方法：使用stoi-函数和to-string-函数进行两次转换！" class="headerlink" title="最简单的方法：使用stoi()函数和to_string()函数进行两次转换！"></a>最简单的方法：使用stoi()函数和to_string()函数进行两次转换！</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num =<span class="built_in">stoi</span>(str);</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到的输出结果将会是int型的“123”</span></span><br><span class="line"><span class="comment">//可以通过typeid(stoi(str)).name()查看，转换后的类型名为int</span></span><br><span class="line"><span class="function">string <span class="title">NumToSum</span><span class="params">(string Num1, string Num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> number1 = <span class="built_in">stoi</span>(Num1);</span><br><span class="line">	<span class="type">int</span> number2 = <span class="built_in">stoi</span>(Num2);</span><br><span class="line">	<span class="type">int</span> sum = number1 + number2;</span><br><span class="line">	string ret = <span class="built_in">to_string</span>(sum);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="那么我们在不使用stoi-函数的前提下如何进行两个字符串的相加呢？-自己造一个轮子"><a href="#那么我们在不使用stoi-函数的前提下如何进行两个字符串的相加呢？-自己造一个轮子" class="headerlink" title="那么我们在不使用stoi()函数的前提下如何进行两个字符串的相加呢？ 自己造一个轮子"></a>那么我们在不使用stoi()函数的前提下如何进行两个字符串的相加呢？ 自己造一个轮子</h5><p>当我们使用下标访问string数据的时候，得到的结果是char类型的数据，char 类型的数据转换为int型的数据要么使用atoi()函数，要么利用ascall表进行减str[i]-48得到相应的数字，然后进行相加，<strong>值得注意的是加法有进位</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">NumToSum</span><span class="params">(string Num1, string Num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size1 = Num1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> size2 = Num2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="comment">//声明一个char类型的数组用来存储相加后的结果</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vec;</span><br><span class="line">    <span class="type">int</span> i = size1 - <span class="number">1</span>, j = size2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>, j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = (Num1[i] - <span class="number">48</span>) + (Num2[j] - <span class="number">48</span>) + carry;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>((sum % <span class="number">10</span>)+<span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = (Num1[i--] - <span class="number">48</span>) + carry;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">push_back</span>((sum % <span class="number">10</span>) + <span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = (Num1[j--] - <span class="number">48</span>) + carry;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">push_back</span>((sum % <span class="number">10</span>) + <span class="number">48</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string ret;</span><br><span class="line">    <span class="type">int</span> k = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(vec[k--]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序如上，也能得出正确的结果，但是没有进行测试，不知道在极端条件下的情况如何。但是自我感觉这个代码写的真的丑，又丑又长，可读性不强还是使用API接口来的方便。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%90%86%E6%83%B3%E6%B1%BD%E8%BD%A6%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" data-id="cllwbvsah001ad4mohobc8boa" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-乐建军-219-第一阶段复习考试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E4%B9%90%E5%BB%BA%E5%86%9B-219-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E8%80%83%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.181Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>班级：219</p>
<p>姓名：乐建军</p>
<p>成绩：</p>
<h4 id="第一阶段复习考试题（问答题）每题3分"><a href="#第一阶段复习考试题（问答题）每题3分" class="headerlink" title="第一阶段复习考试题（问答题）每题3分"></a>第一阶段复习考试题（问答题）每题3分</h4><p>1、简述如下目录的功能</p>
<p>&#x2F;boot ：存放系统内核及启动有关文件</p>
<p>&#x2F;etc：存放系统配置文件</p>
<p>&#x2F;lib：存放库文件</p>
<p>&#x2F;bin：存放常用命令</p>
<p>&#x2F;home：普通用户家目录文件</p>
<p>&#x2F;root：管理员用户家目录文件</p>
<p>2 写出15个熟悉的linux 命令，并说明其功能</p>
<p>答： 1.cd 跳转到该路径下<br>        2.ls 查看目录中的文件<br>        3.pwd 显示当前绝对路径<br>        4.ps 查看当前进程<br>        5.mkdir 新建一个目录文件<br>        6.touch 新建一个普通文件<br>        7.cat 查看文件内容，合并文件，向文件中写入内容<br>        8.more 查看文件内容，当文件内容一页显示不完时，分页显示文件内容<br>        9.gcc  -o,-c,-e文件的编译命令<br>        10.man 查看命令内容<br>        11.cp 拷贝文件，拷贝目录文件时需要加 -r<br>        12.mv 移动文件位置，修改文件名<br>        13.vi 文件编辑命令<br>        14.grep 按关键词筛选文件中的内容<br>        15.| 管道，将上一个 命令的输出当做下一个命令的输入</p>
<p>kill结束一个进程，heap查看头几行，tail查看后几行，pstree查看进程树，top查看系统资源使用情况以及系统信息</p>
<p>tar打包文件，gzip压缩文件</p>
<p>3  linux 系统都有哪些类型的文件？每种类型用什么符号标识？</p>
<p>答：<br>普通文件    _<br>目录文件    d<br>管道文件    p<br>链接文件    l</p>
<p>设备文件  c(字符设备)   d（块设备）</p>
<p>套接字文件 s</p>
<p>mkdir 创建目录文件</p>
<p>mkfifo创建管道文件</p>
<p>4 文件有哪些基本权限，分别对用的数值是多少？ </p>
<p>答:<br>读          4<br>写          2<br>执行       1<br>无          0</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211115192022681.png" alt="image-20211115192022681"></p>
<p>5  将一个名为file 的文件权限改成属主具有读写执行，同组人具有读写权限，其他人没有任何权限，写出命令：</p>
<p>答：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211115192049377.png" alt="image-20211115192049377"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod  <span class="number">760</span> file</span><br></pre></td></tr></table></figure>
<p>6  将main.c 生成对应的可执行程序main, 中间一共经过几个步骤，分别是什么？并给出对应的gcc 编译命令。</p>
<p>答：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预编译:处理预编译指令，删除注释，对所有包含“#”的命令进行展开和替换</span><br><span class="line">gcc -E main.c -o mian.i</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译:进行语法、语义的分析，代码优化汇总符号</span><br><span class="line">gcc -s main.i -o mian.s</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">汇编:翻译成二进制，生成各个段，生成符号表</span><br><span class="line">gcc -c mian.s -o main.o<span class="comment">//main.o是一个ELF格式的二进制文件</span></span><br><span class="line"></span><br><span class="line">链接:合并各个段，符号解析，符号重定位</span><br><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure>


<p>7  有三个文件 main.c ,add.c  max.c  部分内容如下，请给出编译命令：</p>
<p>main.c如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,add(a+b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>,max(a,b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add.c 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>max.c 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：一步完成编译的命令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c add.c max.c </span><br></pre></td></tr></table></figure>

<p>8 请写出makefile完成对第7题的自动编译。</p>
<p>答:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">all main</span><br><span class="line"></span><br><span class="line">main: add.o amx.o main.o</span><br><span class="line">      gcc -o main add.o max.o main.o</span><br><span class="line"></span><br><span class="line">add.o:add.c</span><br><span class="line">      gcc -o add.c</span><br><span class="line"></span><br><span class="line">max.o:max.c</span><br><span class="line">      gcc -o max.c</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line">      gcc -o main.c</span><br><span class="line">clean:</span><br><span class="line">      rm -rf  *.o main</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>9 调试使用什么工具？常用的调试命令有哪些？</p>
<p>答:<br>调试使用<strong>gdb</strong><br><strong>常用的调试命令</strong><br>l 将文件输出,一次默认显示10行<br>b 给指定行或函数添加断点<br>info break 显示断点信息<br>r 运行程序<br>n 单步执行<br>c 继续执行</p>
<p>p 打印</p>
<p>q 退出调试</p>
<p>10  什么是库？请简述共享库和静态库的区别.（程序设计第四版）</p>
<p>答：<br>（1）库是预先编译好的一组方法的集合。分为静态库和共享库。<br>（2）静态库和共享库的命名规则不同，静态库是libxxx.a,动态库是libxxx.so;静态库在链接时就将方法包含到可执行文件当中去，而动态库是只做标记，在程序加载运行到对应的步骤时才将方法写入其中。</p>
<p>11 如第7题代码，请将add.c 和max.c 中的方法生成到静态库libfoo.a中，写出生成库的命令：</p>
<p>答:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c<span class="comment">//现将add.c和max.c编译成.o文件</span></span><br><span class="line">gcc -c max.c</span><br><span class="line"> ar crv libfoo.a add.o max.o</span><br></pre></td></tr></table></figure>
<p>12 如第7题代码，请将add.c 和max.c 中的方法生成到共享库libfoo.so中，写出生成库的命令</p>
<p>答：共享库可以不先编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c<span class="comment">//现将add.c和max.c编译成.o文件</span></span><br><span class="line">gcc -c max.c</span><br><span class="line"> gcc shread -fPIC libfoo.so add.o max.o</span><br></pre></td></tr></table></figure>

<p>13 查看可执行程序用到哪些共享库使用那个命令？</p>
<p>答：ldd main</p>
<p>14 什么是进程？进程有那些基本状态？</p>
<p>答：程序的一次运行就是一个进程；进程有就绪、执行、和阻塞三种状态。</p>
<p>15 程序与进程有什么区别？</p>
<p>答：程序是静态的，进程是动态的，进程就是程序的一次动态执行，进程需要调动系统资源，但是程序不需要</p>
<p>16 linux系统中主函数有哪些参数，，写出主函数的完整形式，并说明各个形参的意义分别是什么？</p>
<p>答 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[],<span class="type">char</span>* envp[])</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">argc 表示参数个数</span></span><br><span class="line"><span class="comment">argv 参数名称</span></span><br><span class="line"><span class="comment">envp 环境变量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>17 库函数和系统调用有什么区别？</p>
<p>答：库函数当中包含了系统调用，库函数是在用户区，而系统调用在内核区，当用户使用库函数时，其底层实现还是系统调用</p>
<p>18 ipc机制有哪些?</p>
<p>答:进程间通讯机制有哪些：管道、<strong>信号量、共享内存、消息队列</strong>、套接字</p>
<p>19 有名管道和无名管道的区别？</p>
<p>答：有名管道可以在任意两个进程间通信，而无名管道主要应用于父子进程间的通信</p>
<p>20 什么是僵死进程？如何处理僵死进程🌹</p>
<p>答：<br>僵死进程：子进程先于父进程进程结束，父进程却没有调用wait获取子进程的退出码，子进程就变成了一个僵死进程</p>
<p>处理方法：父进程通过调用wait()处理</p>
<p>​					SIGCHLD设置成忽略</p>
<p>21 如下代码一共产生多少个进程？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	fork()||fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：一共会产生3个进程</p>
<p>22 如下程序分别输出多少个’a’?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：6 </p>
<p>23 如下程序分别输出多少个’a’?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：8个</p>
<p>24  什么是临界资源，什么是临界区？</p>
<p>答:<br>临界资源：一段时间只能被一个进程访问的或使用的资源<br>临界区：使用临界资源的那段代码</p>
<p>25 请说明信号量的pv操作分别代表什么意思？那个操作可能阻塞为什么？</p>
<p>答：<br>p代表临界资源被使用 资源数量减一<br>v代表临界资源使用完毕被回收 资源数量加一</p>
<p>p操作可能会造成阻塞，因为当资源数目为0的时候没有临界资源可以调动，p操作就会被阻塞</p>
<h4 id="第一阶段复习考试题（编程题）"><a href="#第一阶段复习考试题（编程题）" class="headerlink" title="第一阶段复习考试题（编程题）"></a>第一阶段复习考试题（编程题）</h4><p>26 写程序，父进程复制产生子进程，在父子进程中循环打印7次字符串“parent”,</p>
<p>在子进程中循环打印3次字符串”child”，补全代码：（8分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="string">&quot;child&quot;</span>;</span><br><span class="line">        n=<span class="number">3</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=parent;</span><br><span class="line">        n=<span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>27  写程序使用open,read,write,close等系统调用，对文件a.txt进行复制生成b.txt （8分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;a.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;b.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(fdr==<span class="number">-1</span>||fdw==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n=(read(fdr,buff,<span class="number">256</span>))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fdw,buff,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28  写程序改变SIGINT信号的响应方式，使得程序在第一次收到信号时，打印信号的代号值，第二次收到信号时按默认方式结束程序。修改补全代码：（9分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig=%d\n&quot;</span>,sig);</span><br><span class="line">    signal(SIGINT,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGINT,sig_fun);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E4%B9%90%E5%BB%BA%E5%86%9B-219-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E8%80%83%E8%AF%95%E9%A2%98/" data-id="cllwbvs8s000ld4moa5y27gxv" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-空间数据又称几何数据，用来表示物体的位置，形态，大小分布等各方面的信息，是对现实世界中存在的具有定位意义的事物和现象的定量描述。" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8F%88%E7%A7%B0%E5%87%A0%E4%BD%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E7%89%A9%E4%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%BD%A2%E6%80%81%EF%BC%8C%E5%A4%A7%E5%B0%8F%E5%88%86%E5%B8%83%E7%AD%89%E5%90%84%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%98%AF%E5%AF%B9%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B7%E6%9C%89%E5%AE%9A%E4%BD%8D%E6%84%8F%E4%B9%89%E7%9A%84%E4%BA%8B%E7%89%A9%E5%92%8C%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%AE%9A%E9%87%8F%E6%8F%8F%E8%BF%B0%E3%80%82/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.172Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>空间数据又称几何数据，用来表示物体的位置，形态，大小分布等各方面的信息，是对现实世界中存在的具有定位意义的事物和现象的定量描述。</p>
<p>多租户是SaaS领域特有的产物。</p>
<p>SaaS服务是部署在云上的，客户可以按需购买，并通过网络请求就能获取到的服务；也就是说在这样的场景下，会有N个客户同时使用同一套SaaS服务。</p>
<p>那么对于SaaS服务供应商来说，构建SaaS体系需要完成两部分工作：上层服务+底层多租户系统。</p>
<p>上层服务是供应商对外售卖的软件服务，其可以为客户创造价值、为公司带来营收；而底层多租户系统则是SaaS模式实现的具体方式，公司在对外售卖SaaS服务时，需要考虑如何实现客户之间的数据隔离、服务的权限控制、计费管理等；因此需要引入多租户概念来解决上述问题。</p>
<h5 id="什么是租户？"><a href="#什么是租户？" class="headerlink" title="什么是租户？"></a>什么是租户？</h5><p>租户是指被赋予SaaS服务使用权的企业组织，及客户。</p>
<p>SaaS服务供应商根据客户购买需求在多租户系统中配置对应的软件服务版本，生成租户账号，客户拿到租户账号之后就可以使用SaaS服务，那么该客户就是该SaaS服务的一个租户。</p>
<p>一般来说，租户和客户两者的是一对一的关系 ，客户买了a软件服务，开通了一个租户账号，后来又买了b软件服务；此时只需要在给之前的租户账号上配置b软件服务的使用权就可以了，不需要在建立新的租户账号。</p>
<p>多租户是多个客户使用同一个实例，数据存储在相同的位置，通过数据库、数据表和tenantID（租户ID）字段三种方式进行数据隔离，适合标准化程度较高的场景；单租户是指多个客户使用多个实例，各个客户使用的实例和数据存储单独运行，更适合定制化需求场景。</p>
<h5 id="多租户系统与开放平台、apaas之间的区别："><a href="#多租户系统与开放平台、apaas之间的区别：" class="headerlink" title="多租户系统与开放平台、apaas之间的区别："></a>多租户系统与开放平台、apaas之间的区别：</h5><p>1）aPaaS指的是应用程序平台及服务，有PaaS衍生而来，PaaS面向开发者，提供软件开发所需的平台环境（各类中间件等）或者以API、SDK的形式被客户应用调用；但哟偶遇应用开发成本和门槛较高，aPaaS出现，其帮助客户实现低代码甚至0代码开发应用内。</p>
<p>2）开放平台实际上是PaaS的一种表现形式，我们先来看一下开放平台的定义：软件系统通过开放API或函数使得外部程序可以增加该软件系统的功能或者使用该软件系统的资源；常见的开放平台如微信开放平台、支付宝开放平台，钉钉开放平台等。举例来说，第三方可以调用微信对外开放的微信登录和微信支付接口来实现自己的服务，或者ISV在微信开放平台上开发自己的小程序等。</p>
<p>三者的区别是，aPaaS、PaaS、开放平台是软件服务供应商为第三方提供帮助&#x2F;服务的工具，多租户系统则是软件服务商为自己的软件服务提供帮助的工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8F%88%E7%A7%B0%E5%87%A0%E4%BD%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E7%89%A9%E4%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%BD%A2%E6%80%81%EF%BC%8C%E5%A4%A7%E5%B0%8F%E5%88%86%E5%B8%83%E7%AD%89%E5%90%84%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%98%AF%E5%AF%B9%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B7%E6%9C%89%E5%AE%9A%E4%BD%8D%E6%84%8F%E4%B9%89%E7%9A%84%E4%BA%8B%E7%89%A9%E5%92%8C%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%AE%9A%E9%87%8F%E6%8F%8F%E8%BF%B0%E3%80%82/" data-id="cllwbvsam001cd4mohawcga9e" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-进程间的通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.153Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><h4 id="一、管道："><a href="#一、管道：" class="headerlink" title="一、管道："></a>一、管道：</h4><p>​	管道分为有名管道和无名管道，</p>
<h5 id="有名管道：可用于任意两个进程间的通信；"><a href="#有名管道：可用于任意两个进程间的通信；" class="headerlink" title="有名管道：可用于任意两个进程间的通信；"></a>有名管道：可用于任意两个进程间的通信；</h5><p>可以通过<strong>mkfifo</strong>命令创建，</p>
<p>也可以通过系统调用创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*filename,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="无名管道：用父子进程间的通信"><a href="#无名管道：用父子进程间的通信" class="headerlink" title="无名管道：用父子进程间的通信"></a>无名管道：用父子进程间的通信</h5><p>无名管道只能通过系统调用创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe()成功返回0，失败返回-1；</span></span><br><span class="line"><span class="comment">fds[0]是管道读端的描述符</span></span><br><span class="line"><span class="comment">fds[1]是管道写端的描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><p>无论是有名还是无名管道，写入的数据都在内存上</p>
<p>管道是一种半双工通信方式</p>
<p>有名和无名的区别是，有名可以在任意两个进程间通信，而无名管道只能在父子进程之间进行通信。</p>
<h4 id="二、信号量："><a href="#二、信号量：" class="headerlink" title="二、信号量："></a>二、信号量：</h4><p>​	<strong>信号量主要是用来同步进程的</strong>。信号量是一个特殊的变量一般只取正值，其代表允许访问资源数目。</p>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类</strong>：</h5><p>二值信号量：其取值只有0和1；</p>
<p>计数信号量：信号量的值大于1；</p>
<p>当信号量的值为0时，表示没有资源可以使用，P操作会被阻塞。</p>
<h5 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h5><p>P操作：获取资源时，需要对信号量的值减1.</p>
<p>V操作：释放资源时，需要对信号量的值加1.</p>
<p>**相关知识 **：</p>
<p>临界资源：同一时间只能有一个进程进行访问的资源</p>
<p>临界区：访问临界资源的那段代码</p>
<p>信号量由内核提供的接口帮我们进行创建，传建完后也有内核帮我们维护，与使用它的进程的生存周期无关。信号量的销毁需要我们主动手动进行销毁，不然其会一直存在。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220102175353166.png" alt="image-20220102175353166"></p>
<p>信号量函数的定义：头文件“#include&lt;sys&#x2F;sem.h&gt;”</p>
<p><strong>semget:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semget()创建或者获取已存在的信号量,成功返回信号量id，失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="comment">//key：两个进程使用相同的 key 值，就可以使用同一个信号量 </span></span><br><span class="line"><span class="comment">//nsems：内核维护的是一个信号量集，在新建信号量时，其指定信号量集中信号量的个数</span></span><br><span class="line"><span class="comment">//semflg 可选： IPC_CREAT（创建信号量） IPC_EXCL（判断信号量是否已存在）</span></span><br></pre></td></tr></table></figure>

<p><strong>semctl:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semop()对信号量进行改变，做 P 操作或者 V 操作,semop()成功返回 0，失败返回-1</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">//指定信号量集中的信号量下标</span></span><br><span class="line">  <span class="type">short</span> sem_op; <span class="comment">//其值为-1，代表 P 操作，其值为 1，代表 V 操作</span></span><br><span class="line">  <span class="type">short</span> sem_flg; <span class="comment">//SEM_UNDO</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>semctl</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semctl()控制信号量 semctl()成功返回 0，失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cmd 选项： SETVAL IPC_RMID</span></span><br><span class="line"><span class="comment">union semun</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"> int val;</span></span><br><span class="line"><span class="comment"> struct semid_ds *buf;</span></span><br><span class="line"><span class="comment"> unsigned short *array;</span></span><br><span class="line"><span class="comment"> struct seminfo *_buf;</span></span><br><span class="line"><span class="comment"> &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>创建一个信号量实例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> semid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span><span class="comment">//创建/或者已存在的信号量</span></span><br><span class="line"> &#123;</span><br><span class="line">	 semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">1</span>,IPC_CREAT|IPC_EXCL|<span class="number">0600</span>);</span><br><span class="line">	 <span class="keyword">if</span> ( semid == <span class="number">-1</span> )<span class="comment">//已存在</span></span><br><span class="line"> 	&#123;</span><br><span class="line">	 semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">1</span>,<span class="number">0600</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">else</span><span class="comment">//初始化信号量</span></span><br><span class="line">	 &#123;</span><br><span class="line"> 		<span class="keyword">union</span> semun a;</span><br><span class="line"> 		a.val = <span class="number">1</span>;<span class="comment">//信号量的初始值</span></span><br><span class="line">		<span class="keyword">if</span> ( semctl(semid,<span class="number">0</span>,SETVAL,a) == <span class="number">-1</span> )</span><br><span class="line">		 &#123;</span><br><span class="line">			 perror(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line"> 		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">()</span><span class="comment">//p 减一</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_op = <span class="number">-1</span>;<span class="comment">//p</span></span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line"> 	&#123;</span><br><span class="line">		 perror(<span class="string">&quot;semop p error&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">()</span><span class="comment">//v 加一</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_op = <span class="number">1</span>;<span class="comment">//v</span></span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		perror(<span class="string">&quot;semop v error&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_destroy</span><span class="params">()</span><span class="comment">//销毁</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( semctl(semid,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">	 perror(<span class="string">&quot;semctl del error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>经典习题：三个进程a,b,c分别输入A,B,C，要求输出ABCABCABC…</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sem.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> semid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    semid=semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">3</span>,IPC_CRATE|IPC_EXECl|<span class="number">0600</span>);</span><br><span class="line">    <span class="comment">//如果创建失败看能否直接获取</span></span><br><span class="line">    <span class="keyword">if</span>(semid==<span class="number">-1</span>)&#123;</span><br><span class="line">        semid=semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">3</span>,<span class="number">0600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">             <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">a</span>;</span></span><br><span class="line">             a.val=arr[i];</span><br><span class="line">             <span class="keyword">if</span>(semctl(semid,i,SETVAL,a) == <span class="number">-1</span>)&#123;</span><br><span class="line">                 perror(<span class="string">&quot;semctl SEtval error\n&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(index&gt;<span class="number">0</span>&amp;&amp;index&lt;<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>[3];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        buf[i].sem_num=index;</span><br><span class="line">        buf[i].sem_op = <span class="number">-1</span>;</span><br><span class="line">        buf[i].sem_flg = SEM_UNDO;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(semop(semid,&amp;buf[i],<span class="number">1</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;semop p error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(index&gt;<span class="number">0</span>&amp;&amp;index&lt;<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>[3];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        buf[i].sem_num=index;</span><br><span class="line">        buf[i].sem_op = <span class="number">1</span>;</span><br><span class="line">        buf[i].sem_flg = SEM_UNDO;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(semop(semid,&amp;buf[i],<span class="number">1</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;semop v error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_des</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl destory error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem_p(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>):</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_v(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem_p(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>):</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_v(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem_p(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>):</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_v(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、共享内存"><a href="#三、共享内存" class="headerlink" title="三、共享内存"></a>三、共享内存</h4><p>共享内存就是，多个进程都可以访问的内存空间。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220107115955530.png" alt="image-20220107115955530"></p>
<p>既然共享内存空间多个进程都可访问，那么我们需要一些方法去控制这些访问内存的进程，是的访问的过程变得有序，不至于出现错误。</p>
<p><strong>共享内存的定义和使用</strong>：头文件#include&lt;sys&#x2F;shm.h&gt;</p>
<p><strong>shmget:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">shmget();用于创建或者获取共享内存</span><br><span class="line">shmget();成功返回共享内存的 ID， 失败返回<span class="number">-1</span></span><br><span class="line">key： 不同的进程使用相同的 key 值可以获取到同一个共享内存</span><br><span class="line">size： 创建共享内存时，指定要申请的共享内存空间大小</span><br><span class="line">shmflg: IPC_CREAT IPC_EXCL</span><br></pre></td></tr></table></figure>

<p><strong>shmat:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span>* <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line">shmat()将申请的共享内存的物理内存映射到当前进程的虚拟地址空间上</span><br><span class="line">shmat()成功返回返回共享内存的首地址，失败返回 <span class="literal">NULL</span></span><br><span class="line">shmaddr：一般给 <span class="literal">NULL</span>，由系统自动选择映射的虚拟地址空间</span><br><span class="line">shmflg： 一般给 <span class="number">0</span>， 可以给 SHM_RDONLY 为只读模式，其他的为读写</span><br></pre></td></tr></table></figure>

<p><strong>shmdt</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"> shmdt()断开当前进程的 shmaddr 指向的共享内存映射</span><br><span class="line"> shmdt()成功返回 <span class="number">0</span>， 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>shmctl</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"> shmctl()控制共享内存</span><br><span class="line"> shmctl()成功返回 <span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line"> cmd： IPC_RMID  <span class="comment">//删除共享内存</span></span><br></pre></td></tr></table></figure>



<h4 id="四、消息队列"><a href="#四、消息队列" class="headerlink" title="四、消息队列"></a>四、消息队列</h4><p>消息队列的原理：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220110134238310.png" alt="image-20220110134238310"></p>
<p>消息队列的定义和使用的：头文件#include&lt;sys&#x2F;msg.h&gt;</p>
<p><strong>msgget:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">((<span class="type">key_t</span>) key, <span class="type">int</span> msqflg)</span>; </span><br><span class="line"></span><br><span class="line">msgget()创建或者获取一个消息队列</span><br><span class="line">msgget()成功返回消息队列 ID，失败返回<span class="number">-1</span></span><br><span class="line">msqflg： IPC_CREAT</span><br></pre></td></tr></table></figure>

<p><strong>msgsnd:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msqp, <span class="type">size_t</span> msqsz, <span class="type">int</span> msqflg)</span>; </span><br><span class="line">msgsnd()发送一条消息，消息结构为：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">long</span> mtype; <span class="comment">// 消息类型， 必须大于 0</span></span><br><span class="line"> <span class="type">char</span> mtext[<span class="number">1</span>]; <span class="comment">// 消息数据</span></span><br><span class="line"> &#125;;</span><br><span class="line"> msgsnd()成功返回 <span class="number">0</span>， 失败返回<span class="number">-1</span></span><br><span class="line"> msqsz： 指定 mtext 中有效数据的长度</span><br><span class="line"> msqflg：一般设置为 <span class="number">0</span> 可以设置 IPC_NOWAIT</span><br></pre></td></tr></table></figure>

<p><strong>msgrcv:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msqsz, <span class="type">long</span> msqtyp, <span class="type">int</span> msqflg)</span>; </span><br><span class="line"></span><br><span class="line">msgrcv()接收一条消息</span><br><span class="line">msgrcv()成功返回 mtext 中接收到的数据长度， 失败返回<span class="number">-1</span></span><br><span class="line">msqtyp： 指定接收的消息类型，类型可以为 <span class="number">0</span></span><br><span class="line">msqflg： 一般设置为 <span class="number">0</span> 可以设置 IPC_NOWAIT</span><br></pre></td></tr></table></figure>

<p><strong>msgctl:</strong></p>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> msgctl(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *<span class="keyword">buf</span>); </span><br><span class="line">msgctl()控制消息队列</span><br><span class="line">msgctl()成功返回 <span class="number">0</span>，失败返回-<span class="number">1</span></span><br><span class="line">cmd： IPC_RMID</span><br></pre></td></tr></table></figure>

<p>a.c:</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220110134358093.png" alt="image-20220110134358093"></p>
<p>b.c:</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220110134501265.png" alt="image-20220110134501265"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>四种进程间通信的方法其实实现的原理都很像，都是申请一个空间将所要传递的信息暂时保存，然后等待另一个进程将信息取出来，实现进程间的通信。</p>
<p>不论是管道，信号量，共享内存，消息队列都是有限的资源，所以用完之后要回收，否则当资源用完就无法再申请了。</p>
<h4 id="进程间通信的六种方式："><a href="#进程间通信的六种方式：" class="headerlink" title="进程间通信的六种方式："></a>进程间通信的六种方式：</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220729080743880.png" alt="image-20220729080743880"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" data-id="cllwbvsbl001rd4moe2njbt78" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-进程的复制：" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.143Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>库文件：预先编译好的方法的集合  </p>
<h3 id="进程的复制："><a href="#进程的复制：" class="headerlink" title="进程的复制："></a>进程的复制：</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%9A/" data-id="cllwbvsbj001qd4mocu0wa9v8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>