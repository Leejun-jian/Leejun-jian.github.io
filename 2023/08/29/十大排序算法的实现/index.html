<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="@TOC 下面的算法可能要用到的简单函数1234567891011121314151617181920212223242526#define Type int&#x2F;&#x2F;交换函数void Swap(int&amp;a,int&amp;b)&amp;#123;	int tmp&#x3D;a;	a&#x3D;b;	b&#x3D;tmp;&amp;#125;&#x2F;&#x2F;输入函数void Input(int n, int *a) &amp;#123;    for(int">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/08/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="@TOC 下面的算法可能要用到的简单函数1234567891011121314151617181920212223242526#define Type int&#x2F;&#x2F;交换函数void Swap(int&amp;a,int&amp;b)&amp;#123;	int tmp&#x3D;a;	a&#x3D;b;	b&#x3D;tmp;&amp;#125;&#x2F;&#x2F;输入函数void Input(int n, int *a) &amp;#123;    for(int">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/df4ae0a06f654941abebee7a67fa2037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X5rex6KeB6bm_X3lq,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?O(k)%3EO(nlogn)">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?O(nlogn)">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025225548181.png">
<meta property="article:published_time" content="2023-08-29T13:11:37.318Z">
<meta property="article:modified_time" content="2022-10-25T15:00:00.562Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/df4ae0a06f654941abebee7a67fa2037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X5rex6KeB6bm_X3lq,size_20,color_FFFFFF,t_70,g_se,x_16">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-十大排序算法的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:37.318Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@<a href="%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">TOC</a></p>
<h2 id="下面的算法可能要用到的简单函数"><a href="#下面的算法可能要用到的简单函数" class="headerlink" title="下面的算法可能要用到的简单函数"></a>下面的算法可能要用到的简单函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Type int</span></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>&amp;a,<span class="type">int</span>&amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Input</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Output</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1、冒泡排序（必会）"><a href="#1、冒泡排序（必会）" class="headerlink" title="1、冒泡排序（必会）"></a>1、冒泡排序（必会）</h2><p>冒泡排序就是把小的元素往前调或者把大的元素往后调，比较是相邻的两个元素比较，交换也发生在这两个元素之间。<br>如果两个相邻的元素是相等的，就不需要将其在交换位置，如果相等的两个元素不相邻，通过交换之后两个元素相邻之后，其相对位置也不会改变，所以冒泡排序是一种稳定的排序算法。</p>
<h4 id="基本冒泡排序："><a href="#基本冒泡排序：" class="headerlink" title="基本冒泡排序："></a><strong>基本冒泡排序：</strong></h4><p>每次循环比较一轮，找到当前循环的最大值，将其放到最后；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubblueSort</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="comment">//因为最后一个元素不用进行排序，所以只需要进行n-2此排序就可以完成所有的排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">    		 <span class="comment">//每次循环都从首位开始比较，将这次排序中的最大值放到后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(br + j) &gt; *(br + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Swap_Int(&amp;br[j], &amp;br[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在整个排序的过程中，本来的数组已经是有序的，没有发生交换，那么就可以直接跳出循环了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubblueSort</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="type">bool</span> flag = flase;</span><br><span class="line">    <span class="comment">//因为最后一个元素不用进行排序，所以只需要进行n-2此排序就可以完成所有的排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">    		 <span class="comment">//每次循环都从首位开始比较，将这次排序中的最大值放到后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(br + j) &gt; *(br + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                Swap_Int(&amp;br[j], &amp;br[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用两个for循环将函数排序：<br>内循环是为了找出此次循环中的最大或者最小值，将其放到末尾，然后依次寻找次小值等，直到循环到最后一次。例如：<br>将原数组     Ar[]&#x3D;{12 ,35 ,43 ,56 ,32, 52,15,8}<br>按照从小到大的顺序进行排列<br><img src="https://img-blog.csdnimg.cn/df4ae0a06f654941abebee7a67fa2037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X5rex6KeB6bm_X3lq,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>总之就是外循环进行一次就进行一次比较，有n个数就循环n-1次。第一层循环是为了计数，第二层循环负责比较。</p>
<h4 id="改进之后的冒泡排序："><a href="#改进之后的冒泡排序：" class="headerlink" title="改进之后的冒泡排序："></a><strong>改进之后的冒泡排序：</strong></h4><p>每一次循环比较两次，先从上往下比较找到最大的，再从下往上比较找到最小的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> BubbleSort（<span class="type">int</span> *ar，<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(ar != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>,k=n-j<span class="number">-1</span>; j &lt; n - i &amp;&amp;  k &gt; <span class="number">0</span>  &amp;&amp;  k&gt;=j ; ++j,--k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(ar + j) &gt; *(ar + j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(ar[j], ar[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ar[k]&lt;ar[k<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="built_in">Swap</span>(ar[k],ar[k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>原理：</strong>二分查找的前提是有序数组，通过比较中位数和目标数据的大小，来定位下次寻找的区间。</p>
<p>给定一个有序数组nums，在数组中寻找目标值target，如果找到了返回目标值的下标，如果没找到目标值返回-1；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binaryLookUp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (right - left)/<span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eles</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环移动数组"><a href="#循环移动数组" class="headerlink" title="循环移动数组"></a>循环移动数组</h2><p>循环移动数组；<br>示例：<br>int ar[10]&#x3D;{1, 2 , 3 , 4 , 5 , 6 ，7 , 8 , 9 , 10};右移一个数据元素：<br>输出{ 10,1,2,3,4,5,6,7,8,9};<br>右移k个数据元素：<br>如k &#x3D; 3;输出{8，9，10，1，2，3，4，5，6，7}；<br>实现函数: Right_Move_Array;        &#x2F;&#x2F;   右移一个数据元素Right_Move_Array_K;    &#x2F;&#x2F;   右移k 个数据元素Left_Move_Array;<br> Left_Move_Array_K<br>循环移动可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap_Int</span><span class="params">(<span class="type">int</span>* ap, <span class="type">int</span>* bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ap != nullptr&amp;&amp;bp!=nullptr);</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp = *ap;</span><br><span class="line">    *bp = *ap;</span><br><span class="line">    *ap = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//让br[]数组的所有元素依次向左移动一位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Left_Move_Array</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    assert(br != nullptr);<span class="comment">//断言很重要，在程序运行的时候如果出现错误可以及时停止程序，减少时间的浪费</span></span><br><span class="line">    <span class="type">int</span> tmp = br[<span class="number">0</span>];</span><br><span class="line">    br[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        br[i<span class="number">-1</span>]=br[i];<span class="comment">//将第一个数取出之后，后面的数字依次向前挪一个位置然后让第一个数赋给最后一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    br[n - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">right_Array_move</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    <span class="type">int</span> tmp = br[n<span class="number">-1</span>];</span><br><span class="line">    br[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        br[i] = br[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    br[<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">left_move_array_k</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    k = k % n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Left_Move_Array(br, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*int tmp = br[n - k - 1];</span></span><br><span class="line"><span class="comment">    br[n - 1 - k] = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n - 1; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        br[i] = br[(i + k)%n];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    br[n - 1 - k] = tmp;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">right_move_array_k</span><span class="params">(<span class="type">int</span>* br, <span class="type">int</span> n, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(br != nullptr);</span><br><span class="line">    left_move_array_k(br, n, -k);</span><br><span class="line">    <span class="comment">/*k = k % n;</span></span><br><span class="line"><span class="comment">    while (k--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        right_Array_move(br, n);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-直接插入排序"><a href="#2-直接插入排序" class="headerlink" title="2. 直接插入排序"></a>2. 直接插入排序</h2><p><strong>原理：</strong>插入排序是在一个已经有序的小序列的基础上，一次插入一个一个元素。</p>
<p>最开始的时候这个有序的小序列只有一个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是<strong>想要插入的元素和已经有序的元素的最大值开始比较，如果比他大就直接插入在其后面，否则一直往前找知道找到他该插入的位置。</strong></p>
<p>如果碰到一个和准备插入元素相等的数据，那么把准备插入元素插入在其后面。所以插入排序不会改变相等元素的相对位置，所以插入排序是稳定的。</p>
<ul>
<li><p>例题：使用插入排序将一个含有n个元素的数据，按照升序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> tmp = nums[i];</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j+<span class="number">1</span>] = tmp;<span class="comment">//将tmp放到合适的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h2><p>希尔排序就是加强版的插入排序。无论是冒泡排序还是希尔排序，如果最大值刚好在第一位，要将他挪到正确的位置就需要n-1挪动。也就是说，原数组的一个元素如果距离他正确位置太远的话，则需要与相邻元素交换很多次才能到大正确的位置，这样相对来说比较耗费时间。</p>
<p><strong>希尔排序的思想：</strong>先让数组中任意间隔为h的元素有序，刚开始h的大小可以是h&#x3D;n&#x2F;2，接着h&#x3D;n&#x2F;4，让h一直缩小，当h&#x3D; 1时，也就是此时数组中任意间隔为1的元素有序，此时数组就是有序的了。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</li>
<li>当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> gap = n/<span class="number">2</span>;<span class="comment">//分组大小</span></span><br><span class="line">	<span class="comment">//每次循环使用插入排序的方式，将小分组里面的数据有序</span></span><br><span class="line">	<span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i - gap;</span><br><span class="line">			<span class="type">int</span> tmp = nums[i];<span class="comment">//将插入值提前保存下来，以免被覆盖</span></span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[i]; j -= gap)</span><br><span class="line">			&#123;</span><br><span class="line">				nums[j + gap] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j + gap] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> a : nums)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质上希尔排序就是，在插入排序之前先进性预排序，是的序列基本有序之后，在进行一次插入排序就达到效果。</p>
<p>其核心代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = i - gap;</span><br><span class="line">    <span class="comment">//将插入值提前保存下来，以免被覆盖</span></span><br><span class="line">    <span class="type">int</span> tmp = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[i]; j -= gap)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是将插入排序的步长<strong>从1改为了gap</strong></p>
<h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h2><p>选择排序就是每次选出待排序队列中的中的最小值，然后将其放到已排序队列的最后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="type">int</span> min = j;</span><br><span class="line">        <span class="keyword">for</span>(;j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            min = nums[j] &lt; nums[min] ? j : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;nums[i],&amp;nums[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每个数都要循环比较n次，所以时间复杂度是指数级别的。</p>
<h2 id="5-归并排序（必会）"><a href="#5-归并排序（必会）" class="headerlink" title="5. 归并排序（必会）"></a>5. 归并排序（必会）</h2><p><strong>思想：</strong>将一个大的无序数组有序，可以将这个大的数组分成两个，然后对这两个数组分别进行排序，之后再把这两个数组合并成一个有序数组。由于两个数组都是有序的，所以合并是很快的。</p>
<p>通过递归的方式，直到数组的大小为1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小合并为一个大小为2的，在依次合并直到整个数组都有序。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法采用的是分治法，</p>
<p><strong>步骤：</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergearray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> first,<span class="type">int</span> mid,<span class="type">int</span> last,<span class="type">int</span> temp[])</span>	<span class="comment">//将两个有序数组合并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=first,j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m=mid,n=last;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">			temp[k++]=a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">		temp[k++]=a[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">		temp[k++]=a[j++];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">		a[first+i]=temp[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> first,<span class="type">int</span> last,<span class="type">int</span> temp[])</span>	<span class="comment">//将两个任意数组合并排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(first&lt;last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid=(first+last)/<span class="number">2</span>+first;</span><br><span class="line">		<span class="built_in">mergesort</span>(a,first,mid,temp);	<span class="comment">//左边有序 </span></span><br><span class="line">		<span class="built_in">mergesort</span>(a,mid+<span class="number">1</span>,last,temp);	<span class="comment">//右边有序 </span></span><br><span class="line">		<span class="built_in">mergearray</span>(a,first,mid,last,temp);	<span class="comment">//再将两个有序数组合并 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">//分配一个有n个int型元素的数组所占空间，并将该数组的第一个元素的地址赋给int *型指针p。</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="built_in">mergesort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, p);  </span><br><span class="line">    <span class="keyword">delete</span>[] p;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者另一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortCore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; copy, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line">    <span class="comment">//这里减少了copy向nums的赋值部分，千万注意不要把copy 和 nums赋值反了</span></span><br><span class="line">	<span class="built_in">mergeSortCore</span>(copy, nums, low1, high1);</span><br><span class="line">	<span class="built_in">mergeSortCore</span>(copy, nums, low2, high2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> copyIndex = low1;</span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low1] &lt; nums[low2] ? nums[low1++] : nums[low2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (low2 &lt;= high2) </span><br><span class="line">    &#123;</span><br><span class="line">		copy[copyIndex++] = nums[low2++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; begin &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">copyNums</span><span class="params">(nums)</span></span>;<span class="comment">//这里要借助一个一模一样的数组的</span></span><br><span class="line">	<span class="built_in">mergeSortCore</span>(nums, copyNums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	nums.<span class="built_in">assign</span>(copyNums.<span class="built_in">begin</span>(), copyNums.<span class="built_in">end</span>());<span class="comment">//到最后copy数组是排序好的，记得要赋值一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序注重的是分治思想，先将大数组分成一个个的小数组，在从小到大依次合并，合并两个有序数组的时间复杂度可以降低到O(n)，分解的时间复杂度为log（n),那么最终的时间复杂度应该为，O(n*logn)。</p>
<h2 id="6-快速排序（必会）"><a href="#6-快速排序（必会）" class="headerlink" title="6. 快速排序（必会）"></a>6. 快速排序（必会）</h2><p>快速排序也是考察率较高的一种排序算法，主要操作步骤是每次选取一个划分元，将比这个划分元大的数都放到其右边，比划分元小的数都放到其左边，直到划分区间变为一停止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是依靠划分函数来进行排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp = nums[start];<span class="comment">//选取划分元</span></span><br><span class="line">    <span class="type">int</span> left = start , right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; nums[right] &lt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; nums[left] &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortFun</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">Partation</span>(nums,start,end);</span><br><span class="line">        <span class="built_in">quickSortFun</span>(nums,start,mid);</span><br><span class="line">        <span class="built_in">quickSortFun</span>(nums,mid + <span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="built_in">quickSortFun</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当快速排序遇到极特殊情况时，如有序数组，那么快速排序的时间复杂度将快速增大，最终退化成冒泡排序时间复杂度为O(n^2)，那么应该如何改进才能使得快速排序在任何情况下的时间复杂度都为 O(nlog(n)) 呢?</p>
<p>关键点在于划分元的选择上，详细描述在我的另一篇文章中有所描述：</p>
<p><a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=118046392">快排</a></p>
<p>非递归版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单趟排</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key = arr[begin];</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (key &lt;= arr[end] &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			--end;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[begin] = arr[end];</span><br><span class="line">		<span class="keyword">while</span> (key &gt;= arr[begin] &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			++begin;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end] = arr[begin];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[begin] = key;</span><br><span class="line">	<span class="type">int</span> meeti = begin;</span><br><span class="line">	<span class="keyword">return</span> meeti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSortNoR</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="comment">//先入右边</span></span><br><span class="line">	st.push(end);</span><br><span class="line">	<span class="comment">//再入左边</span></span><br><span class="line">	st.push(begin);</span><br><span class="line">	<span class="keyword">while</span> (!st.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//左区间</span></span><br><span class="line">		<span class="type">int</span> left = st.top();</span><br><span class="line">		st.pop();</span><br><span class="line">		<span class="comment">//右区间</span></span><br><span class="line">		<span class="type">int</span> right = st.top();</span><br><span class="line">		st.pop();</span><br><span class="line">		<span class="comment">//中间数</span></span><br><span class="line">		<span class="type">int</span> mid = PartSort(arr, left, right);</span><br><span class="line">		<span class="comment">//当左区间&gt;=mid-1则证明左区间已经排好序了</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; mid - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.push(mid - <span class="number">1</span>);</span><br><span class="line">			st.push(left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当mid+1&gt;=右区间则证明右区间已经排好序</span></span><br><span class="line">		<span class="keyword">if</span> (right &gt; mid + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.push(right);</span><br><span class="line">			st.push(mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><p>利用堆这种数据结构完成的排序算法,，堆排序算法是一种选择排序算法，他的最好，最坏时间复杂度都是O(nlogn)，是不稳定的排序算法。</p>
<p>对于堆排序难点在于，二叉树的顺序数组储存到大顶堆（小顶堆）的转换。从数据存储来看，数组存储方式和树的存储方式可以相互转换，既数组可以转换成树，树也可以转换成数组。</p>
<p>堆是具有以下特点的完全二叉树：每个节点都大于会等于其左右孩子节点的值，称为大顶堆；每个节点的值都小于或等于左右孩子的值，称为小顶堆。</p>
<p><strong>代码实现思路：</strong></p>
<ol>
<li><p><strong>构造初始堆</strong>：将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）。</p>
<ul>
<li><p>构建初始堆时，要注意，完全二叉树的第一个非叶子节点的下标是n&#x2F;2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大顶堆实现无序数组的升序排列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//此循环为构建初始堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>;i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断有没有越界</span></span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span> &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较知道根节点左右子树中的较大值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;nums[i],&amp;nums[j]);</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将数组的最大值也就是大顶堆的顶点，放到数组的最后面</span></span><br><span class="line">        <span class="built_in">Swap</span>(&amp;nums[i],&amp;nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//对剩下的n-1个值继续构建大顶堆,寻找次大值，依次循环，直到所有的数据排序完成</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">2</span>*k+<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;nums[k],&amp;nums[j]);</span><br><span class="line">                <span class="comment">//因为发生了交换，不知道有没有影响到子树成堆，所以需要继续比较</span></span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//构建初始堆，和大顶堆正好相反</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>((j + <span class="number">1</span>) &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swap</span>(nums[i], nums[j]);</span><br><span class="line">				i = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将最小值挪到最后</span></span><br><span class="line">		<span class="built_in">Swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">2</span> * k + <span class="number">1</span>) &lt; i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> ((j + <span class="number">1</span>) &lt; i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nums[k] &gt; nums[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Swap</span>(nums[k], nums[j]);</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h4><p>堆是一种常用的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">树形结构</a>，是一种特殊的<strong>完全二叉树</strong>，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。</p>
<h4 id="堆的特性："><a href="#堆的特性：" class="headerlink" title="堆的特性："></a>堆的特性：</h4><p>• 堆中某个节点的值总是不大于或不小于其父节点的值</p>
<p>• 堆总是一棵<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">完全二叉树</a></p>
<h4 id="大顶堆和小顶堆"><a href="#大顶堆和小顶堆" class="headerlink" title="大顶堆和小顶堆"></a>大顶堆和小顶堆</h4><p>大顶堆：所有的父节点大于等于孩子节点</p>
<p>小顶堆：所有的父节点小于等于孩子节点</p>
<h4 id="堆排序的基本步骤"><a href="#堆排序的基本步骤" class="headerlink" title="堆排序的基本步骤"></a>堆排序的基本步骤</h4><ol>
<li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p>
</li>
<li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</p>
</li>
<li><p>将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组</p>
</li>
</ol>
<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020">计数排序</a>是一个非基于比较的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。</p>
<p>它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当 <img src="https://private.codecogs.com/gif.latex?O(k)%3EO(nlogn)" alt="O(k)&gt;O(nlogn)"> 的时候其效率反而不如基于比较的排序，因为基于比较的排序的时间复杂度在理论上的下限是 <img src="https://private.codecogs.com/gif.latex?O(nlogn)" alt="O(nlogn)">。</p>
<h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h4><p>计数排序对输入的数据有附加的限制条件：</p>
<ol>
<li>输入的线性表的元素属于有限偏序集 S；</li>
<li>设输入的线性表的长度为 n，|S|&#x3D;k（表示集合 S 中元素的总数目为 k），则 k&#x3D;O(n)。</li>
</ol>
<p>在这两个条件下，计数排序的复杂性为O(n)。</p>
<p>​		计数排序的<strong>基本思想</strong>是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。<strong>当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。</strong></p>
<h4 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a><strong>算法过程：</strong></h4><ol>
<li>根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；</li>
<li>遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；</li>
<li>对额外空间内数据进行计算，得出每一个元素的正确位置；</li>
<li>将待排序集合每一个元素移动到计算得出的正确位置上。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> max = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//遍历数组找到最大值和最小值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		max = nums[i] &gt; max ? nums[i] : max;</span><br><span class="line">		<span class="comment">//min = nums[i] &lt; min ? nums[i] : min;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个额外数组，用来计数</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(max+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp[nums[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; (max + <span class="number">1</span>); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (tmp[i]--)</span><br><span class="line">		&#123;</span><br><span class="line">			nums[j++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="但是："><a href="#但是：" class="headerlink" title="但是："></a>但是：</h4><p>虽然计数排序看上去很强大，但是它存在两大局限性：</p>
<ol>
<li>当数列最大最小值差距过大时，并不适用于计数排序</li>
</ol>
<p>​        比如给定 20 个随机整数，范围在 0 到 1 亿之间，此时如果使用计数排序的话，就需要创建长度为 1 亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。</p>
<ol start="2">
<li>当数列元素不是整数时，并不适用于计数排序</li>
</ol>
<p>​        如果数列中的元素都是小数，比如 3.1415，或是 0.00000001 这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。</p>
<h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h2><p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>这里值得我们注意的是，桶的数量要取到一个适中值是比较困难的，通的数量过多或者过少都会导致桶排序退化，过多回退化成计数排序，太少回退化成比较排序。但是有没有一个特定的公式来确定桶的数量.所以我们还是只能自己确定桶的数量.但是有一个规则我们还是可以考虑进去的,那就是<code>最好让元素平均的分散到每一个桶里</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>1）算法描述</p>
<p>取得数组中的最大数，并取得位数</p>
<p>arr为原始数组，从最低位开始取每个位组成radix数组</p>
<p>对radix进行计数排序（利用计数排序适用于小范围数的特点）</p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>排序算法没有优劣，在适当的情况下使用相应的方法</em></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025225548181.png" alt="image-20221025225548181"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cllwc4xi9000vjsmo6bza8ric" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/29/%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/08/29/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>