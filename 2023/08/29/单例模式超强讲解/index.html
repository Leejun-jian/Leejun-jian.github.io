<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。  什么是单例模式    面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。 单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/08/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%B6%85%E5%BC%BA%E8%AE%B2%E8%A7%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。  什么是单例模式    面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。 单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130312524.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130333134.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130413359.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130437103.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130511456.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130543333.png">
<meta property="og:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130558303.png">
<meta property="article:published_time" content="2023-08-29T13:11:36.998Z">
<meta property="article:modified_time" content="2022-07-28T05:07:46.471Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130312524.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-单例模式超强讲解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%B6%85%E5%BC%BA%E8%AE%B2%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T13:11:36.998Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。</p>
<ol>
<li><h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4></li>
</ol>
<p>  面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。</p>
<p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130312524.png" alt="image-20220728130312524"></p>
<ol start="2">
<li><h4 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h4></li>
</ol>
<h5 id="单例模式有两种类型："><a href="#单例模式有两种类型：" class="headerlink" title="单例模式有两种类型："></a>单例模式有两种类型：</h5><p>懒汉式：在真正需要使用对象时才去创建该单例类对象<br>饿汉式：在类加载时已经创建好该单例对象，等待被程序使用</p>
<h4 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h4><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。，否则则先执行实例化操作。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130333134.png" alt="image-20220728130333134"></p>
<p>根据上面的流程图，就可以写出下面的这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。</p>
<p>以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。</p>
<h4 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h4><p>饿汉式在类加载时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130413359.png" alt="image-20220728130413359"></p>
<p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static final Singleton singleton = new Singleton();</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在</p>
<p>类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p>
<ol start="3">
<li>懒汉式如何保证只创建一个对象<br>我们再来回顾懒汉式的核心方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断singleton为空，那么它们都会去实例化一个Singleton对象，这就变成双例了。所以，我们要解决的是线程安全问题。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130437103.png" alt="image-20220728130437103"></p>
<p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;</span><br><span class="line">        singleton = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    synchronized(Singleton.class) &#123;   </span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</p>
<p>接下来要做的就是优化性能，目标是：如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p>
<p>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">        synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">            if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                singleton = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码已经完美地解决了并发安全+性能低效问题：</p>
<p>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；<br>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化<br>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可<br>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</p>
<p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：Double Check（双重校验） + Lock（加锁）</p>
<p>完整的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">            synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">                if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p>
<ol start="4">
<li>使用volatile防止指令重排<br>创建一个对象，在JVM中会经过三步：</li>
</ol>
<p>（1）为singleton分配内存空间</p>
<p>（2）初始化singleton对象</p>
<p>（3）将singleton指向分配好的内存空间</p>
<p>指令重排序是指：JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</p>
<p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130511456.png" alt="image-20220728130511456"></p>
<p>使用volatile关键字可以防止指令重排序，其原理较为复杂，这篇博客不打算展开，可以这样理解：使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换，这样在多线程环境下就不会发生NPE异常了。</p>
<p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</p>
<p>最终的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br><span class="line">            synchronized(Singleton.class) &#123; // 线程A或线程B获得该锁进行初始化</span><br><span class="line">                if (singleton == null) &#123; // 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>破坏懒汉式单例与饿汉式单例<br>无论是完美的懒汉式还是饿汉式，终究敌不过反射和序列化，它们俩都可以把单例对象破坏掉（产生多个对象）。</li>
</ol>
<p>1：演示利用反射破坏单例模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 获取类的显式构造器</span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    // 可访问私有构造器</span><br><span class="line">    construct.setAccessible(true); </span><br><span class="line">    // 利用反射构造新对象</span><br><span class="line">    Singleton obj1 = construct.newInstance(); </span><br><span class="line">    // 通过正常方式获取单例对象</span><br><span class="line">    Singleton obj2 = Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p>
<h5 id="2：利用序列化与反序列化破坏单例模式"><a href="#2：利用序列化与反序列化破坏单例模式" class="headerlink" title="2：利用序列化与反序列化破坏单例模式"></a>2：利用序列化与反序列化破坏单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 创建输出流</span><br><span class="line">    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;Singleton.file&quot;));</span><br><span class="line">    // 将单例对象写到文件中</span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    // 从文件中读取单例对象</span><br><span class="line">    File file = new File(&quot;Singleton.file&quot;);</span><br><span class="line">    ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">    Singleton newInstance = (Singleton) ois.readObject();</span><br><span class="line">    // 判断是否是同一个对象</span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>两个对象地址不相等的原因是：readObject() 方法读入对象时，它必定会返回一个新的对象实例，必然指向新的内存地址。</p>
<ol start="6">
<li>能让面试官鼓掌的枚举实现<br>我们已经掌握了懒汉式与饿汉式的常见写法了，在《大话设计模式》中的单例模式章节也止步于此。但是，追求极致的我们，怎么能够止步于此，在《Effective Java》书中，给出了终极解决方法，话不多说，学完下面，真的不虚面试官考你了。</li>
</ol>
<p>在 JDK1.5 后，使用 Java 语言实现单例模式的方式又多了一种：枚举</p>
<p>我们先来看看枚举如何实现单例模式的，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    System.out.println(&quot;这是枚举类型的单例模式！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要思考：使用枚举实现单例模式的优势在哪里？</p>
<p>我们从最直观的地方入手，第一眼看到这几行代码，就会感觉到“少”，没错，就是少，虽然这优势有些牵强，但写的代码越少，越不容易出错。</p>
<p>优势1：代码对比饿汉式与懒汉式来说，更加地简洁</p>
<p>其次，既然是实现单例模式，那这种写法必定满足单例模式的要求，而且使用枚举实现时，没有做任何额外的处理。</p>
<p>优势2：它不需要做任何额外的操作去保证对象单一性与线程安全性</p>
<p>我写了一段测试代码放在下面，这一段代码可以证明程序启动时仅会创建一个 Singleton 对象，且是线程安全的。</p>
<p>我们可以简单地理解枚举实现单例的过程：在程序启动时，会调用Singleton的空参构造器，实例化好一个Singleton对象赋给INSTANCE，之后再也不会实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    Singleton() &#123; System.out.println(&quot;枚举创建对象了&quot;); &#125;</span><br><span class="line">    public static void main(String[] args) &#123; /* test(); */ &#125;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Singleton t1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton t2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.print(&quot;t1和t2的地址是否相同：&quot; + t1 == t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&#x2F;&#x2F; 枚举创建对象了<br>&#x2F;&#x2F; t1和t2的地址是否相同：true<br>除了优势1和优势2，还有最后一个优势让枚举实现单例模式在目前看来已经是“无懈可击”了。</p>
<p>优势3：使用枚举可以防止调用者使用反射、序列化与反序列化机制强制生成多个单例对象，破坏单例模式。</p>
<h4 id="防破坏的原理如下："><a href="#防破坏的原理如下：" class="headerlink" title="防破坏的原理如下："></a>防破坏的原理如下：</h4><h5 id="（1）防反射"><a href="#（1）防反射" class="headerlink" title="（1）防反射"></a>（1）防反射</h5><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130543333.png" alt="image-20220728130543333"></p>
<p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p>
<h5 id="（2）防止反序列化创建多个枚举对象"><a href="#（2）防止反序列化创建多个枚举对象" class="headerlink" title="（2）防止反序列化创建多个枚举对象"></a>（2）防止反序列化创建多个枚举对象</h5><p>在读入Singleton对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的类型和变量名输出到文件中，在读入文件反序列化成对象时，利用 Enum 类的 valueOf(String name) 方法根据变量的名字查找对应的枚举对象。</p>
<p>所以，在序列化和反序列化的过程中，只是写出和读入了枚举类型和名字，没有任何关于对象的操作。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220728130558303.png" alt="image-20220728130558303"></p>
<h5 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h5><p>（1）Enum 类内部使用Enum 类型判定防止通过反射创建多个对象</p>
<p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），通过 valueOf() 方法匹配枚举名找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p>
<p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与饿汉式单例有异曲同工之妙。</p>
<ol start="7">
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ol>
<p>  （1）单例模式常见的写法有两种：懒汉式、饿汉式</p>
<p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</p>
<p>（3）饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p>
<p>（4）在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</p>
<p>（5）如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</p>
<p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加volatile关键字防止指令重排序</p>
<p>（7）最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%B6%85%E5%BC%BA%E8%AE%B2%E8%A7%A3/" data-id="cllwbvs9l000xd4moey20dohr" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/29/%E4%BA%8C%E5%8F%89%E6%A0%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/08/29/%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/29/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E9%9A%8F%E7%9D%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B4%E8%B5%B7%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%83%B3%E8%A6%81%E9%80%9A%E8%BF%87%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%E7%BB%9F%E4%B8%80%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AB%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%82/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E5%85%B3%E7%B3%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/29/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>